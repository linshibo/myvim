/*
 * =====================================================================================
 *
 *  @file  player.hpp 
 *
 *  @brief  处理跟玩家有关的函数
 *
 *  compiler  gcc4.3.2 
 *	
 *  platform  Linux
 *
 * copyright:  TaoMee, Inc. ShangHai CN. All rights reserved
 *
 * =====================================================================================
 */

#ifndef PLAYER_H_
#define PLAYER_H_

#include <set>
#include <map>
#include <vector>
#include <queue>

extern "C"{
#include <async_serv/net_if.h>
}
#include "cli_proto.hpp"
#include "common_def.hpp"
#include "dbproxy.hpp"
#include "./proto/ultraman_db.h"
#include "./proto/ultraman_db_enum.h"
#include "task.hpp"
#include "global_data.hpp"
#include "map.hpp"
#include "item_data.hpp"
/* 表示是否做过某件事的最大数组数目 */
//const uint32_t max_only_flag_index = 64;

/* cli_buf只能由后台写的起始type值 */
const uint32_t cli_buf_only_read_start_type = 100000;

/* player结构体中临时数据占用的内存大小 */
const int tmp_data_size = 1024;
enum {
	cli_buf_len = 50, /* svr用的buf的长度 */
	max_buf_index_only_read = 1000, /* 处理svr的buf的函数指针数组的最大值 */
	max_flag_bit =32,
};
enum{
	flag_forbid_add_friend=1,
};
class Cmessage;
struct player_packs;

/* @brief 等待处理的命令
 */
struct wait_queue_t {
	uint32_t len;
	void *data;	
};

struct cli_buf_t {
	uint8_t buf[cli_buf_len];
};



/* 玩家结构体信息 */
struct player_t {
	userid_t uid; /* 用户的米米号 */
	uint32_t role_tm; /* 角色创建时间 */

	//服务器相关结构
	uint32_t fd; /* socket fd */
	fdsession_t*    fdsess; /* fd fdsess */
	uint32_t waitcmd; /* 用户执行的命令 */
	uint32_t seqno; /* 与客户端校验用的版本号 */
	std::queue<wait_queue_t> *pending_cmd_queue; /* 等待处理的命令 */
	std::map<uint32_t, cli_buf_t> *cli_buf;
 	uint32_t tmp_data_len; /* 有效临时数据的长度 */
	uint8_t tmp_data[tmp_data_size]; /* 保存临时数据 */
	list_head_t online_player_list; /* 链接到uid_buckets链表中 */
    //地图钩子
    list_head_t     maphook;
	list_head_t	timer_list;  //for 下发系统时间定时器
	timer_struct_t *db_timer; /* DB超时的定时器 */
	uint16_t db_timer_wait_cmd; /* DB超时的用户执行的命令 */
	uint16_t db_timer_db_cmd; /* 超时的DB命令 */

	char nick[nick_len]; /* 用户的昵称 */
	uint8_t prof; /* 性别 */
	//uint32_t x; /* X坐标 */
	//uint32_t y; /* Y坐标 */
	uint32_t flag; /* 每bit对应一标记 */
    uint32_t        eye_model;
    uint32_t        resource_id;

	uint32_t login_time; /* 用户的登入时间,随时间增大的 */
	uint32_t login_time_for_msglog; /* 用户此次的登入时间，专门为统计所设 */
	uint32_t last_logout_time; /* 上次下线时间，专门为统计第一次注册用户在线时长所设 */
	uint32_t today_login_total_time; /* 用户今天登入的总时间 */

    //好友，黑名单 ,最近联系人
    std::set<uint64_t> *friends;
    std::set<uint64_t> *blacklist;
    std::vector<uint64_t> *recently_contacted_key;

    // 任务
    /*! 玩家的任务列表 (全量信息, 包括 buff) */
    tskmap_t        *tskmap;
    /*! 保存进行任务的地址列表*/
    tskmap_t        *inprogress_tskmap;
    /*! 更新 buff 时的cache, 为了保证跟db强一致, 更新的流程如下:
     * (1) task_setbuff()->task_setbuff_iface() 中把要修改的 buff 复制到 buff_cache 中;
     * (2) 尝试更新 buff_cache, 如果失败则直接返回客户端失败, 否则到 (3)
     * (3) 把 buff_cache 发送给db更新 buff;
     * (4.1) 如果db没有返回或者返回失败, 将直接返回客户端更新失败(此时任务的buff并没有改变)
     * (4.2) 如果db返回成功, 则用 buff_cache 覆盖掉任务的 buff, 然后返回客户端成功;
     *
     * 注意: buff_cache 的 size 必须和 task_t::buff 的 size 一样, 不能大也不能小;
     */
    char            buff_cache[MAX_TASK_BUFF_LEN];
    uint32_t        cache_tskid;
    /*! 客户端设置buff的时候需要返回设置的step,DB协议不带STEP 所以缓存在这里*/
    uint32_t        cache_step;
	//地图
    void reset_map();
    bool check_in_map();
    bool init_player_map();
    bool final_player_map();
	uint32_t get_cur_map_id();
    map_t*          cur_map;
    int32_t         cur_line_index;
    uint32_t        x_pos;
    uint32_t        y_pos;

    uint32_t        last_map_id;
    uint32_t        last_map_x;
    uint32_t        last_map_y;

    ///////装备//////////////////////////
    item_ptr        head;        
    item_ptr        eye;
    item_ptr        glass;
    item_ptr        body;
    item_ptr        tail;
    item_ptr        suit;
    //bool init_player_equip();
    //bool final_player_equip();
    //bool set_player_equip(item* p_item, uint32_t equip_pos);
    //bool check_valid_equip_pos(uint32_t pos);//检查是否合法的装备位置
    //bool check_valid_equip_id(uint64_t equip_id);//检查是否合法的装备id
    //bool check_if_wear_equip(uint64_t equip_id, uint32_t equip_pos);//检查是否在该位置穿着该装备
    //bool check_if_item_expired(uint64_t id);//检查物品是否过期
    //item_ptr        get_equip_by_pos(uint32_t body_index);
    //int pack_player_equip_h(uint8_t* buf);
    //获取人物和精灵的合体属性
    //uint32_t        get_merge_attr_value(uint32_t attr_type);
    ////设置人物和精灵的合体属性
    //void            set_merge_attr_value(uint32_t attr_type, uint32_t value);

};

/* 踢人信息 */
struct kick_pkg_t{
	int cmd; //命令号
	int err; //错误码
};

/* @brief 把Cmessage结构体拷贝到用户的tmp_data中，临时保存
 */
inline void copy_cmessage_to_sess(player_t *p, Cmessage *c_in)
{
	byte_array_t in_ba; //将传入数据写入ba的buf
	in_ba.init_postion();
	c_in->write_to_buf(in_ba);
	uint32_t len = in_ba.get_postion();
	p->tmp_data_len = len;
	memcpy(p->tmp_data, in_ba.get_buf(), len);
}


/* @brief 拷贝session里的内容给client
 */
inline void copy_sess_to_cli(player_t *p, Cmessage *c_in)
{
	byte_array_t ba((char *)p->tmp_data, p->tmp_data_len);
	c_in->read_from_buf(ba);
	send_msg_to_self(p, p->waitcmd, c_in, 1);
}


//#define CHECK_SWAP_ITEM_FN_ARG player_t* p, struct swap_info_t& swap_info, uint32_t& pin_num, std::vector<update_item_list_t>& db_add_item_vector, std::vector<update_item_list_t>&	db_del_item_vector, std::vector<insert_mon_info_t>& insert_mon_info

void init_hash_list();

player_t *get_player_by_fd(uint32_t fd);

player_t *get_player_by_uid(userid_t uid);

player_t *add_player(player_t *p);

void del_player(player_t *p);

int kick_all_usrs_offline(void* owner, void* data);

int notify_sys_time(void* owner, void* data);


/* @brief 打包一个数据到player结构体的零时存储区里
 * @param tmp_data 要打包的数据
 */
template <typename T>
void pack_player_tmp(player_t *p, T tmp_data)
{
	memcpy(p->tmp_data + p->tmp_data_len, &tmp_data, sizeof(T));	
	p->tmp_data_len += sizeof(T);
}

/* @brief 从用户临时存储区里解包出数据
 * @param var 返回解包的数据 
 */
template <typename T>
void unpack_player_tmp(player_t *p, T &var)
{
	memcpy(&var, p->tmp_data, sizeof(T));
}

static inline void cache_set_user_flag(player_t* p, int bit, int flag)
{
    if (flag)
        p->flag |= (1 << (bit-1));
    else
        p->flag &= ~(1 << (bit-1));
}

static inline int db_set_user_flag(player_t* p, uint32_t id,uint32_t role_tm, uint32_t bit, uint32_t flag)
{
    db_proto_set_user_flag_in db_in;
    db_in.pos=bit;
    db_in.val=flag; 
    return send_msg_to_dbproxy(p, id, role_tm, db_proto_set_user_flag_cmd, &db_in);
}
      
#endif
