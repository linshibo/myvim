#ifndef BT_ONLINE_H
#define BT_ONLINE_H
#ifdef __cplusplus
extern "C"
{
#endif

#include <string.h>

#include <async_serv/net_if.h>
#include <libtaomee/timer.h>
#include <libtaomee/list.h>

#include "onlineapi.h"
#include "proto.h"
#include "utils.h"
/**************lua include file**********************/
#include <stdio.h>
#include <math.h>
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
/**************lua include file**********************/
#ifdef __cplusplus
}
#endif

#define TYPEID_2008 2008  

#define TYPEID_2004 2004  
#define TYPEID_3017 3017 
#define TYPEID_2005 2005 

#define MAX_FD_NUM		30000
#define MAX_ONLINE_NUM	1200 + 1
#define PET_NICK_LEN		16
#define PET_CLOTH_MAX_CNT	1
#define PET_HONOR_MAX_CNT	1
#define PET_TASK_MAX_CNT	20

#define MAX_ENTRY_NUM_PER_MAP	32
#define MAX_PLAYERS_PER_GAME	20
#define USER_NICK_LEN			16

#define MAX_OWNED_MOLEGROUP_NUM		3
#define MAX_OWNED_MOLECLASS_NUM		10
#define MAX_MONTH_TASKS				48
#define MAX_DAILY_COUNT				3
#define START_DAY_LIMIT				1001
#define END_DAY_LIMIT				1003
#define MAX_NPC  					10

#define MAX_LATEST_ONLINE		60

#define MAX_FANJI_CNT			10
//在行动回合包中使用
#define UPDATE_WARRIOR_STATE	10000 
#define LAST_HEJI_WARR			(MAX_PLAYERS_PER_TEAM * 2)
//职业编号
enum{
	prof_none = 0,
	prof_swordman, // jian
	prof_ancher,   // gong jian shou
	prof_magician, // mofashi
	prof_churchman, // chuan jiao shi
};

//施加范围
enum {
	one_enemy	= 0,
	t_enemy		= 1,
	c_enemy		= 2,
	r_enemy		= 3,
	a_enemy		= 4,
};

//是否需要盾牌
enum {
	no_need_shield = 0,
	must_have_shield = 1,
	must_not_shield = 2,
};

//target_type
enum {
	self_only = 1,
	except_self = 2,//除自己以外
	self_team = 3,
	enemy_team = 4,
	all_attacked = 5,
	self_team_except_self = 6,
};

//usr_type,技能的使用者限制
enum {
	user_ren_only	= 0,//只有人使用
	user_pet_beast	= 1,//宠物和怪使用
	user_beast_only	= 2,//只用怪使用
};

//操作对象的生死类型
enum {
	attack_only_alive = 0,
	attack_only_dead = 1,
	attack_only_both = 2,
};
//输赢
enum {
	standoff	= 0,
	victory		= 1,
	fail		= 2,
};


enum {
	battle_challenging  = 0,
	battle_ready 		= 1,
	battle_started		= 2,
};
//单回合状态:one_loop_state
enum {
	one_loop_bit_huwei = 0,
	one_loop_bit_huiji = 1,
};

enum{
	btl_op_res_error = 0, // 错误
	btl_op_res_wait_skill = 1, // 等待发招
	btl_op_res_new_loop = 2, // 新一轮开始
	btl_op_res_over = 3, // 对战结束
};


enum {
	// 石化状态位
	shihua_bit				= 0,
	// 遗忘状态位
	yiwang_bit				= 1,
	// 混乱状态位
	hunluan_bit				= 2,
	// 诅咒状态位
	zuzhou_bit				= 3,
	// 中毒
	zhongdu_bit				= 4,
	// 昏睡
	hunshui_bit				= 5,

	// 攻击吸收
	gongji_xishou_bit		= 6,
	// 攻击反弹
	gongji_fantan_bit		= 7,
	// 攻击无效
	gongji_wuxiao_bit		= 8,

	// 魔法吸收
	mofa_xishou_bit			= 9,
	// 魔法反弹
	mofa_fantan_bit			= 10,
	// 魔法无效
	mofa_wuxiao_bit			= 11,

	// 再生之阵
	resume_hp1_bit			= 12,
	// 再生领域
	resume_hp2_bit			= 13,
	// 再生结界
	resume_hp3_bit			= 14,
	////灼伤 
	zhuoshang_bit			= 15,//灼伤

	muyedun_bit			= 16,
	// 逃跑
	run_away_bit 			= 32,
	// 被打死
	dead_bit	 			= 33,
	// 被打飞
	attacked_out_bit	 	= 34,
	// 被打
	attacked_bit			= 35,
	// 防御
	fangyu_bit				= 36,
	// 回避
	huibi_bit				= 37,
	// 魅影
	meiying_bit				= 38,
	// 幻盾
	huandun_bit				= 39,
	// 魔抗
	mokang_bit				= 40,
	// 停止行动
	stop_attack 			= 41,

	// 必杀
	bisha_bit				= 42,
	// 使用药瓶
	use_item_bit			= 43,
	// 救活
	revive_bit				= 44,
	// 回击
	huiji_bit               = 45,
	// 暂停行动
	pause_bit               = 46,
	// 抓宠成功
	catch_pet_succ          = 47,
	// 主人被打飞
	person_atk_out			= 48,
	// 掉线
	person_break_off		= 49,
	// 打飞结果同步
	attack_out_sync			= 50,

	//设置辅助宠物 callback 
	fuzhu_callback_bit	 	= 51,
};

enum {	
	shihua				= 1 << shihua_bit,//石化
	yiwang				= 1 << yiwang_bit,//遗忘
	hunluan				= 1 << hunluan_bit,//混乱
	zuzhou				= 1 << zuzhou_bit,//诅咒
	zhongdu				= 1 << zhongdu_bit,//中毒
	hunshui				= 1 << hunshui_bit,//昏睡
	
	gongji_xishou		= 1 << gongji_xishou_bit,
	gongji_fantan		= 1 << gongji_fantan_bit,
	gongji_wuxiao		= 1 << gongji_wuxiao_bit,
	mofa_xishou			= 1 << mofa_xishou_bit,
	mofa_fantan			= 1 << mofa_fantan_bit,
	mofa_wuxiao			= 1 << mofa_wuxiao_bit,

	resume_hp1			= 1 << resume_hp1_bit,
	resume_hp2			= 1 << resume_hp2_bit,
	resume_hp3			= 1 << resume_hp3_bit,
	zhuoshang			= 1 << zhuoshang_bit,//灼伤
};

/*
    *Type行动类型， 物理攻击1，Mp攻击2，防御技能3，Hp回复4，状态防御5，吸血魔法6，魔法攻击7，异常状态攻击8，防御状态赋予9，使用道具10，换位11，捕捉12，召唤13，待机14，吸血攻击15，逃>跑16，护卫17，死亡待机18
  */

enum skill_type{	
	physi_attack				= 1,
	mp_attack					= 2,
	defense						= 3,
	hp_resume					= 4,
	fh_magic					= 6,//吸血魔法
	magic_attack				= 7,
	
	abnormal_attack				= 8,//异常状态攻击
	set_fanyyu_state			= 9,//防御状态赋予
	use_medical					= 10,
	change_position             = 11,
	catch_pet_opt               = 12,
	recall_pet                  = 13,
	daiji                       = 14,//待机14
	xixue_gongji                = 15,//吸血攻击
	runaway               		= 16,//逃跑
};

//水晶属性
typedef struct pet_birth {
	uint8_t				earth;
	uint8_t				water;
	uint8_t				fire;
	uint8_t				wind;
}__attribute__((packed))pet_birth_t;

typedef struct use_item {
	uint32_t			itemid;
	int16_t				add_hp;
}__attribute__((packed))use_item_t;

typedef struct catch_pet {
    uint32_t            feng_mo_lv;//封魔
    uint32_t            itemid;//卡片id
    uint32_t            race_cnt;//个数
    uint32_t            race[MAX_RACE_TYPE];
}__attribute__((packed))catch_pet_t;

//保存勇士的当时状态
typedef struct warrior_state {
    uint64_t            state;//64位,每一位表不同的状态
    uint64_t            one_loop_state;//单回合状态, 
    int8_t              round_cnt[64]; //回合数,对应state的每一位
    int8_t              effect_cnt[64]; //回合数,对应state的每一位
    int8_t              resume_hp_level;
    int8_t              hundun_level;
    int8_t              meiyin_level;
    int8_t              huwei_level;
    int8_t              muyedun_level;

    use_item_t          ui;
    catch_pet_t         catchpet;
}__attribute__((packed))warrior_state_t;

typedef struct atk_info {
    uint8_t             atk_seq;//0,1

    uint32_t             atk_mark; // 0 self, 1 ememy
    int32_t              atk_pos;

    uint32_t            atk_type;
    uint8_t             atk_level;
    uint8_t             heji_seq;//atk_info_t[i]
    struct warrior*     wrior;//

    // this attack type is already deal
    uint8_t             atk_deal;//已经处理,该标志未使用
    // 
    uint8_t             atk_step;//表示打到第几次 目前用于( 追击)，
    uint8_t             confrm_decre_mp;//扣蓝(魔)方式 
    int16_t             atk_speed;//
    list_head_t         atk_info_list;//node
}__attribute__((packed))atk_info_t;

typedef struct reload_ai_script_timer_head {
	list_head_t	timer_list;
}reload_ai_script_timer_head_t;

typedef struct reload_ai_script_timer_info {
	off_t size;
	time_t mttime;
}reload_ai_script_timer_info_t;


enum pet_action_state
{
	// 在小屋里面
	// 注意online不可能传送一个带这个状态位的宠物过来，否则就是bug
	in_warehouse = 0,
	// 在背包里面
	just_in_bag=1,
	// 待命状态
	on_standby=2,
	// 战斗状态，online传送过来的宠物中，仅且仅有一只宠物携带有该状态位
	rdy_fight=3,
	on_fuzhu=4, //辅助
};

/*受伤状态*/
enum injury_state
{
	// 健康
	injury_health = 0,
	// 白伤
	injury_white  = 1,
	// 黄伤
	injury_yellow = 2,
	// 红伤
	injury_red    = 3,
};

enum
{
	// 还没有扣篮
	confrm_decre_mp_no_need = 0,
	// 等到实际行动后在扣篮
	confrm_decre_mp_after_atk = 1,
	// 预先扣篮
	confrm_decre_mp_when_set_state=2,
};


// 调整该结构时，要小心entry_len, 在初始化warrior 时会使用到它，
typedef struct warrior {
	userid_t				userid;
	uint32_t				petid;
	uint32_t				type_id;
	char					nick[USER_NICK_LEN];
	uint32_t				warrior_flag;//未使用
	uint32_t				vip;//vip
	uint32_t 				color;
	uint8_t					race;//种族
	uint8_t					prof;//职业
 	uint32_t				level;//等级
	
	uint16_t				physique;//体力
	uint16_t				strength;//力量
	uint16_t				endurance;//耐力
	uint16_t				quick;//敏捷
	uint16_t				intelligence;//智力
	uint16_t				attr_addition;//属性配点
	int32_t					hp;
	int32_t					mp;
	uint32_t				injury_lv; // 0 1 2 3
	uint8_t					in_front;//
	uint8_t					earth;
	uint8_t					water;
	uint8_t					fire;
	uint8_t					wind;
	//second level attr
	int32_t					hp_max;
	int32_t					mp_max;
	int16_t 				attack_value;
	int16_t 				mattack_value;
	int16_t 				defense_value;
	int16_t 				mdefense_value;
	int16_t					speed;
	int16_t					spirit; // jingshen
	int16_t					resume;//恢复力，
	int16_t					hit_rate;//命中率，不使用
	int16_t					avoid_rate; //不用
	int16_t					bisha;
	int16_t					fight_back;//反击 
	uint8_t					is_need_add_protect_exp;//是否需要增加守护经验,如果到达每日上限则设置为0
	uint8_t					cloth_cnt;
	body_cloth_t			clothes[MAX_ITEMS_WITH_BODY];
	uint8_t					skill_cnt;
	skill_info_t			skills[MAX_SKILL_NUM_PER_PERSON];
	

	// uint32_t                          beibaochong_cnt;
	uint32_t				weapon_type;
	uint32_t				shield; // 盾牌

	uint8_t					pet_cnt;    // bei bao chong wu shuliang
	uint16_t				catchable;  // if can be catch 0 unable, >0 able
	uint32_t				handbooklv; // chongwu tu jian
	uint32_t                pet_contract_lv; // jing ling qiyue
	uint8_t                 pet_state; // chong wu zhuangtai
	uint32_t				last_atk_type[2];
	uint8_t					last_atk_level[2];
	
	// 以下部分是程序自行定义的数据, 
	uint8_t					load_rate;
	uint8_t                 ready;
	uint32_t                load_time;
	atk_info_t				atk_info[2];
	int16_t					heji_hurt;
	warrior_state_t			waor_state;
	list_head_t				waor_list;
	list_head_t			    timer_list;
	timer_struct_t*		    loading_timer;

	list_head_t				huwei_list_header;
	list_head_t				huwei_list_node;
	int8_t                  huwei_pos;

	struct battle_users*	self_team;
	struct battle_users* 	enemy_team;
	uint32_t				flag;

	inline  bool flag_check_bit( uint32_t bit_value ){
		return (this->flag&bit_value )==bit_value ;
	}
	inline  void  flag_set_bit( uint32_t bit_value,bool value ){
		if (value ){
			this->flag|=bit_value ;
		}else{
			this->flag&=(0xFFFFFFFF-bit_value) ;
		}
	}

	//是否怪物技能ai已经处理
	inline bool is_beast_deal_attacked (){
		return this->flag_check_bit(0x01);
	}

	//设置是否怪物技能ai已经处理
	inline void set_is_beast_deal_attacked(bool value ){
		this->flag_set_bit(0x01,value );
	}

	inline bool pet_not_in_battle_mode() {
		return (this->petid && (this->pet_state != rdy_fight && this->pet_state != on_fuzhu ));
	}
} __attribute__ ((packed)) warrior_t;

typedef struct battle_users {
	uint32_t		teamid;
	uint8_t			victory;  // 1 victory
	uint8_t			ren_count;    // 人数 
	uint8_t         ren_alive_count; // 还活着的人数+活着npc个数
	
	uint8_t         count_ex; // ren & pet;
	uint8_t         alive_count; // ren & pet alive

	uint8_t         atk_out;

	uint16_t        ave_lvl; // ping jun dengji
	
	uint8_t         npc_fri_cnt_alive;//活着npc个数
	warrior_t*		players_pos[MAX_PLAYERS_PER_TEAM * 2];
	warrior_t		players[MAX_PLAYERS_PER_TEAM * MAX_GROUP_PLAYERS];
	uint32_t		online_id;
	uint32_t        team_type;
}__attribute__((packed))battle_users_t;
typedef struct nest_atk {
    uint32_t        uid;//攻击者
    uint32_t        petid;//petid
    uint8_t         fantan_ret; // 9

    uint32_t        atk_type;
    uint8_t         atk_level; // 5

    int16_t         fantan_hp;
    int16_t         fantan_mp;
    int16_t         add_hp;
    uint32_t        use_itemid; // 10

    uint32_t        atk_uid; //被攻击者
    uint32_t        atk_petid;//petid
    uint64_t        fightee_state; // 16

    int16_t         hurt_hp;
    int16_t         hurt_mp;    // 4
                                // = 9+5 + 10 + 16 + 4 := 44
    uint8_t         huwei_pos;//护卫不为0时,hurt_hp,hurt_mp,施加于huwei_pos上的护卫者
}__attribute__((packed))nest_atk_t;

typedef struct resolved_atk {
    uint32_t        seq; //第几个动作
    uint32_t        fighter;
    uint32_t        petid;
    uint32_t        atk_type;
    uint8_t         atk_level;
    uint8_t         heji_seq;
    uint64_t        fighter_state;
    int16_t         resume_hp1;
    int16_t         resume_hp2;
    int16_t         resume_hp3;
    int16_t         poison_hp;//中毒
    int16_t         curse_mp;//诅咒
    int16_t         zhushang_mp;//诅咒

    uint32_t        atk_uid;
    uint32_t        atk_petid;//petid
    uint32_t        topic_id;
    int32_t         hurthp_rate;
    int32_t         hurtmp_rate;

    uint16_t        atk_cnt;
    nest_atk_t      fanji[MAX_FANJI_CNT];//反击？！

    list_head_t     atk_list;
}__attribute__((packed))resolved_atk_t;


enum team_type
{
	team_person       = 0x01, // 人
	team_person_group = 0x02, // 组队
	team_beast        = 0x04, // 怪
	team_npc		  = 0x08, // 打npc
	team_npc_friend   = 0x10, // 己方队伍中存在npc
};

//偷袭标志,
enum touxi_type
{
	touxi_none = 0,// normal challge
	touxi_by_challger, // 挑战方 
	touxi_by_challgee, //接受方 
};


// battle info
typedef struct battle_info {
    battle_id_t         batid;//战队id
    uint32_t            batl_state;
    uint32_t  			groupid;//组id
    float  				difficulty;//难度系数,用于对方攻击修正
	uint32_t			round_timestamp;//回合时间戳,用来防外挂
    battle_users_t      challger;//创建者队伍
    battle_users_t      challgee;//挑战者队伍

    uint8_t             touxi; //偷袭 
	uint32_t  			flag;

    uint32_t            seq_in_round;//用于序列化播放列表 ,临时使用
    uint32_t            battle_loop;//第几轮
    uint8_t             rand_speed;//是否使用随机速度:0,1
    list_head_t         warrior_list;//header
    list_head_t         speed_list;//header
    list_head_t         timer_list;//header
    list_head_t         attack_list;//header
    timer_struct_t*     fight_timer;//发招定时器 120秒
    timer_struct_t*     load_timer;//加载定时器 120秒

	inline  bool flag_check_bit( uint32_t bit_value ){
		return (this->flag&bit_value )==bit_value ;
	}
	inline  void  flag_set_bit( uint32_t bit_value,bool value ){
		if (value ){
			this->flag|=bit_value ;
		}else{
			this->flag&=(0xFFFFFFFF-bit_value) ;
		}
	}


	inline bool is_one_person_pk_beast(){
		return this->flag_check_bit(0x01);
	}
	inline void set_is_one_person_pk_beast(bool value ){
		this->flag_set_bit(0x01,value );
	}

	/*章界王*/
	inline bool is_pk_beast_2008(){
		return this->flag_check_bit(0x00010000);
	}

	inline void set_is_pk_beast_2008(bool value ){
		this->flag_set_bit(0x00010000,value );
	}

	inline bool is_pk_beast_2004(){
		return this->flag_check_bit(0x00020000);
	}

	inline void set_is_pk_beast_2004(bool value ){
		this->flag_set_bit(0x00020000,value );
	}

	inline bool is_no_boss_lt_3_in_pk_beast_2004(){//
		return this->flag_check_bit(0x00040000);
	}

	inline void set_is_no_boss_lt_3_in_pk_beast_2004( bool value ){
		this->flag_set_bit(0x00040000,value );
	}


	inline bool is_pk_beast_3017(){
		return this->flag_check_bit(0x00080000);
	}

	inline void set_is_pk_beast_3017(bool value ){
		this->flag_set_bit(0x00080000,value );
	}

	inline bool is_pk_beast_2005(){
		return this->flag_check_bit(0x00100000);
	}

	inline void set_is_pk_beast_2005(bool value ){
		this->flag_set_bit(0x00100000,value );
	}








} battle_info_t;

#define PKG_STATE(b, v, j) \
	do { \
		*(uint32_t*)((b)+(j)) = htonl((uint32_t)v); (j) += 4; \
		*(uint32_t*)((b)+(j)) = htonl((uint32_t)(v >> 32)); (j) += 4; \
	} while (0)

#define SET_WARRIOR_STATE(state, state_bit)		((state) |= ((uint64_t)1 << (state_bit)))
#define RESET_WARRIOR_STATE(state, state_bit)	((state) &= (~((uint64_t)1 << (state_bit))))
#define CHK_WARRIOR_STATE(state, state_bit)		((state) & ((uint64_t)1 << (state_bit)))

#define WARRIOR_SHIHUA(p_)				CHK_WARRIOR_STATE((p_)->waor_state.state, shihua_bit)
#define WARRIOR_HUNSHUI(p_)				CHK_WARRIOR_STATE((p_)->waor_state.state, hunshui_bit)
#define WARRIOR_RUN_AWAY(p_)			CHK_WARRIOR_STATE((p_)->waor_state.state, run_away_bit)
#define WARRIOR_ATTACKED_OUT(p_)		CHK_WARRIOR_STATE((p_)->waor_state.state, attacked_out_bit)
#define WARRIOR_OFFLINE(p_)				CHK_WARRIOR_STATE((p_)->waor_state.state, person_break_off)

#define WARRIOR_DEAD(p_)				CHK_WARRIOR_STATE((p_)->waor_state.state, dead_bit)
#define SET_WARRIOR_DEAD(p_)			SET_WARRIOR_STATE((p_)->waor_state.state, dead_bit)
#define SET_WARRIOR_ALIVE(p_)			RESET_WARRIOR_STATE((p_)->waor_state.state, dead_bit)
#define WARRIOR_CATCHED_PET(p_)         CHK_WARRIOR_STATE((p_)->waor_state.state, catch_pet_succ)
//宠物不在战斗中
#define PET_NOTIN_BATTLE_MODE(p_)      ((p_)->petid && ((p_)->pet_state != rdy_fight && (p_)->pet_state != on_fuzhu ))

//检查宠物对应的人是不是被打飞了。
#define PETS_OWNER_ATTACK_OUT(p_)      ((p_)->petid && CHK_WARRIOR_STATE((p_)->waor_state.state, person_atk_out))

//以下几个要特别关注
#define CANNOT_ATTACK(p_)	(WARRIOR_SHIHUA(p_) || WARRIOR_HUNSHUI(p_) || WARRIOR_RUN_AWAY(p_) || WARRIOR_DEAD(p_) || WARRIOR_ATTACKED_OUT(p_) || WARRIOR_CATCHED_PET(p_) || (p_)->pet_not_in_battle_mode() || PETS_OWNER_ATTACK_OUT(p_))
#define NONEED_ATTACK(p_)	(WARRIOR_RUN_AWAY(p_) || WARRIOR_DEAD(p_) || WARRIOR_ATTACKED_OUT(p_) || WARRIOR_CATCHED_PET(p_) || (p_)->pet_not_in_battle_mode() || PETS_OWNER_ATTACK_OUT(p_))
#define DEAD_FIGHTER(p_)  (!WARRIOR_RUN_AWAY(p_) && WARRIOR_DEAD(p_) && !WARRIOR_ATTACKED_OUT(p_) && !WARRIOR_CATCHED_PET(p_) && !(p_)->pet_not_in_battle_mode() && !PETS_OWNER_ATTACK_OUT(p_))
#define NEED_2_ATTACK(p_)	(WARRIOR_RUN_AWAY(p_) || WARRIOR_ATTACKED_OUT(p_))

#define CANNOT_ATTACK_DISABLE(skill_, enemy_) ((skill_)->applystatus == attack_only_alive && NONEED_ATTACK(enemy_))
#define CANNOT_ATTACK_ENABLE(skill_, enemy_) ((skill_)->applystatus == attack_only_dead && (!NONEED_ATTACK(enemy_)))



#define IS_MAGIC_ATK_SKILL(skill) (skill >= skill_ma_yunshishu && skill <= skill_ma_longjuanren)
#define IS_PHYSI_ATK_SKILL(skill) (skill >= skill_pa_base_fight && skill <= skill_pa_meiying)
#define IS_DEF_SKILL(skill) (skill >= skill_pd_fangyu && skill <= skill_md_mokang)

#define IS_STATE_CHG_SKILL(skill) (skill >= skill_ms_shihuazhizhen && skill <= skill_ms_shuimianjiejie)
#define IS_MAGIC_AST_SKILL(skill) (skill >= skill_mas_zaishengzhizhen && skill <= skill_mas_mofabizhang)
#define IS_MAGIC_MED_SKILL(skill) (skill >= skill_rh_mingsi && skill <= skill_rs_bingqingjiejie)

#define IS_BASE_ATK_SKILL(skill) (skill == skill_pa_base_fight || skill == skill_pa_pet_base_fight)
#define IS_HEJI_SKILL(skill) (skill == skill_pa_heji || skill == skill_pa_pet_heji)

#define IS_PHYSI_DEFENSE_SKILL(skill) (skill == skill_pd_fangyu || skill == skill_pd_huandun || skill == skill_pd_pet_fangyu || skill == skill_pd_pet_huandun)

#define IS_BEAST(p_) 		(IS_BEAST_ID((p_)->userid) || (p_)->petid)


extern fdsession_t* online[];

int init_all_timer_type(int rstart);

int battle_info_op(void* buf, int len, fdsession_t* fdsess);
uint8_t init_battles();
void clean_fdsess_onlinex_down(int fd);
void response_battle_info (battle_info_t* abi, uint16_t cmd);
void response_attacks_info (battle_info_t* abi, uint16_t cmd);
void state_effect_hpmp(battle_info_t* abi, warrior_t* fighter, atk_info_t* aai);
uint32_t get_beast_topic_id(battle_info_t* abi, warrior_t* fighter, atk_info_t* aai);

uint8_t battle_attack_op_ex(userid_t uid, uint32_t online_id, battle_info_t* abi, 
 uint32_t petid, uint32_t enemy_mark,int32_t enemy_pos, uint32_t atk_type,uint32_t atk_level);
uint8_t chk_and_calc_attacks(battle_info_t* abi);
void calc_warrior_single_step_battle_result(battle_info_t* abi, resolved_atk_t* pra, atk_info_t* aai);
int battle_load_expired(void* owner, void* data);
uint8_t check_battle_start(battle_info_t* abi);
int attack_op_expired(void* owner, void* data);
skill_info_t* get_beast_skill(battle_info_t* abi, warrior_t* p);
void beast_intel_attack(battle_info_t* abi, warrior_t* p, atk_info_t* aai, int seq);
void clear_warrior_atkinfo(battle_info_t* abi, warrior_t* lp);
void set_fangyu_state_before_round_attack(battle_info_t* abi, warrior_t* fighter, atk_info_t* aai);
int calc_hit_rate(battle_info_t* abi, warrior_t* fighter, warrior_t* fightee);
int calc_hit_result(battle_info_t* abi, warrior_t* fighter, warrior_t* fightee, nest_atk_t* ana);

float calc_shuijing_xiangke(battle_info_t* abi, warrior_t* fighter, warrior_t* fightee);
int calc_phy_fight_hurt_value(battle_info_t* abi, warrior_t* fighter, warrior_t* fightee, atk_info_t* aai, int16_t* bisha_happen);
int calc_phy_hurt_value(battle_info_t* abi, warrior_t* fighter, warrior_t* fightee, atk_info_t* aai, int16_t* bisha_happen);
int calc_magic_fight_hurt_value(battle_info_t* abi, warrior_t* fighter, warrior_t* fightee, atk_info_t* aai);
int8_t chk_repeat_atkinfo_insert(battle_info_t* abi, atk_info_t* aai);

void report_user_fighted(battle_info_t* abi, uint32_t uid, uint32_t petid, uint16_t cmd);
int load_lua_script();
int warrior_load_expired(void* owner, void* data);


int get_pet_phy_pos(battle_users_t* team, int personpos, uint32_t petid);
float calc_team_ave_lv(battle_info_t* abi, battle_users_t* abu);
static inline int send_to_online(int cmd, int body_len, const void* body_buf, userid_t id, battle_id_t challenger, uint32_t opid, uint32_t online_id)
{
	static uint8_t bcpkg[bt_proto_max_len];

	int len = sizeof(batrserv_proto_t) + body_len;
	if (!online[online_id] || (body_len > (int)(sizeof(bcpkg) - sizeof(batrserv_proto_t))) ) {
		ERROR_RETURN( ("Failed to Send Pkg, fd=%d online_id=%d", (online[online_id]) ? online[online_id]->fd : 0, online_id), -1 );
	}

	batrserv_proto_t* pkg = (batrserv_proto_t*)bcpkg;
	pkg->len        = len;
	pkg->online_id  = online_id;
	pkg->cmd        = cmd;
	pkg->ret        = 0;
	pkg->id         = id;
	pkg->challenger = challenger;
	pkg->opid       = opid;
	memcpy(pkg->body, body_buf, body_len);

	return send_pkg_to_client(online[online_id], bcpkg, len);
}
//
typedef struct stru_svr_cli_proto{
		batrserv_proto_t 	svr_proto;
		protocol_t			cli_proto;
} __attribute__((packed)) svr_cli_proto_t;

static inline int send_msg_to_online(int svr_cmd, Cmessage *c_in, userid_t id, battle_id_t challenger, uint32_t cli_cmdid, uint32_t online_id)
{
	
	static svr_cli_proto_t svr_cli_proto;

	if (!online[online_id] ) {
		ERROR_RETURN( ("Failed to Send Pkg, fd=%d online_id=%d", (online[online_id]) ? online[online_id]->fd : 0, online_id), -1 );
	}


	svr_cli_proto.svr_proto.len        = sizeof(svr_cli_proto);
	svr_cli_proto.svr_proto.online_id  = online_id;
	svr_cli_proto.svr_proto.cmd        = svr_cmd;
	svr_cli_proto.svr_proto.ret        = 0;
	svr_cli_proto.svr_proto.id         = id;
	svr_cli_proto.svr_proto.challenger = challenger;
	svr_cli_proto.svr_proto.opid       =  cli_cmdid;

	svr_cli_proto.cli_proto.cmd= htons(cli_cmdid);
	svr_cli_proto.cli_proto.ret= 0;

	return send_msg_to_client(online[online_id],(char*)&svr_cli_proto,c_in,
			sizeof(svr_cli_proto.svr_proto ),true );
}

static inline void  i64tostring(battle_id_t l, char* buffer)
{
	sprintf(buffer, "%lu", l);
}

static inline int send_to_online_error(int cmd, uint32_t err, userid_t id, battle_id_t challenger, uint32_t opid, uint32_t online_id)
{
	static uint8_t bcpkg[bt_proto_max_len];

	if (!online[online_id]) {
		ERROR_RETURN(("Failed to Send Pkg, online_id=%d", online_id), -1);
	}

	batrserv_proto_t* pkg = (batrserv_proto_t*)bcpkg;
	pkg->len        = sizeof(batrserv_proto_t);
	pkg->online_id  = online_id;
	pkg->cmd        = cmd;
	pkg->ret        = err;
	pkg->id         = id;
	pkg->challenger = challenger;
	pkg->opid       = opid;

	return send_pkg_to_client(online[online_id], bcpkg, pkg->len);
}

static inline void send_to_2_leader(battle_info_t* abi, uint16_t cmd, const void* buf, int len)
{
	send_to_online(battle_info_msg, len, buf, abi->challger.teamid, abi->batid, cmd, abi->challger.online_id);
	if (!IS_BEAST_ID(abi->challgee.teamid)){
		send_to_online(battle_info_msg, len, buf, abi->challgee.teamid, abi->batid, cmd, abi->challgee.online_id);
	}
}
static inline void send_msg_to_2_leader(battle_info_t* abi, uint16_t cmd, Cmessage *c_in )
{
	send_msg_to_online(battle_info_msg, c_in, abi->challger.teamid, abi->batid, cmd, abi->challger.online_id);
	if (!IS_BEAST_ID(abi->challgee.teamid)){
		send_msg_to_online(battle_info_msg, c_in, abi->challgee.teamid, abi->batid, cmd, abi->challgee.online_id);
	}
}



void insert_atkinfo_to_list(battle_info_t* abi, atk_info_t* aai);
void clean_one_state(warrior_t* fighter, uint8_t state_bit, int8_t times);
void add_warrior_to_huweilist(battle_info_t* abi, warrior_t* fighter, uint8_t pos);
void chg_warrior_pos_from_huweilist(battle_info_t* abi, warrior_t* fighter, uint8_t pos);
void remove_warrior_from_huweilist(battle_info_t* abi, warrior_t* fighter);
void clean_warrior_huiwei_list(battle_info_t* abi, warrior_t* fighter);
warrior_t* get_warrior_from_huweilist(battle_info_t* abi, warrior_t* fighter);

static inline warrior_t* get_warrior_from_warriorlist(battle_info_t* abi, userid_t uid, uint32_t petid)
{
	uint32_t cnt = 0;
	list_head_t* lh;
	list_for_each(lh, &abi->warrior_list) {
		warrior_t* p = list_entry(lh, warrior_t, waor_list);
		if (p->userid == uid && p->petid == petid) {
			return p;
		}
		cnt++;
	}

	return NULL;
}

static inline warrior_t* get_pet_from_warriorlist(battle_info_t* abi, userid_t uid)
{
	list_head_t* lh;
	list_for_each(lh, &abi->warrior_list) {
		warrior_t* p = list_entry(lh, warrior_t, waor_list);
		if (p->userid == uid && p->petid &&  p->pet_state == rdy_fight ) {
			return p;
		}
	}
	return NULL;
}

static inline battle_users_t* get_enemy_team(warrior_t* awor)
{		
	return awor->enemy_team;
}
 
static inline warrior_t* get_warrior_by_pos(battle_users_t* team, int pos)
{
	// pos is not valid
	if (pos < 0 || pos >= 2 * MAX_PLAYERS_PER_TEAM){
		return NULL;
	}
	
	return team->players_pos[pos];
}

static inline warrior_t* get_attacked_warrior(warrior_t* attacker, atk_info_t* aai)
{
	if (aai->atk_mark){// 0 self, 1 ememy
		return get_warrior_by_pos(attacker->enemy_team, aai->atk_pos);
	}
	else{
		return get_warrior_by_pos(attacker->self_team, aai->atk_pos);
	}
}

static inline int get_rand_alive_catchable_pet_pos(battle_users_t* enemy)
{		
	int cnt = 0;
	int psw[2 * MAX_PLAYERS_PER_TEAM] = {0};
	int loop;
	for (loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		if (enemy->players_pos[loop] && enemy->players_pos[loop]->catchable && !NONEED_ATTACK(enemy->players_pos[loop])) {
			psw[cnt++] = loop;
		}
	}
	
	if (!cnt){
		return -1;
	}
	
	return psw[rand() % cnt];
}

static inline int get_rand_alive_warrior_pos( battle_users_t* enemy, uint32_t self_pet_state)
{
	int cnt = 0;
	int psw[2 * MAX_PLAYERS_PER_TEAM] = {0};
	int loop;
	for (loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		warrior_t* lp = enemy->players_pos[loop];
		if (!lp){
			continue;
		}
		
		if (NONEED_ATTACK(lp)) {
			continue;
		}
		if ( self_pet_state==on_fuzhu && lp->level==1  ){//辅助宠物不打一级
			continue;
		}
		
		psw[cnt++] = loop;
	}
	
	if (!cnt){
		return -1;
	}
	
	return psw[rand() % cnt];
}

static inline int get_rand_disable_warrior_pos(battle_users_t* enemy)
{		
	int cnt = 0;
	int psw[2 * MAX_PLAYERS_PER_TEAM] = {0};
	int loop;
	for (loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		if (enemy->players_pos[loop] && DEAD_FIGHTER(enemy->players_pos[loop])) {
			psw[cnt++] = loop;
		}
	}
	
	if (!cnt){
		return -1;
	}
	
	return psw[rand() % cnt];
}

static inline warrior_t* get_rand_catchable_beast(battle_users_t* enemy)
{		
	int cnt = 0;
	warrior_t* psw[2 * MAX_PLAYERS_PER_TEAM] = {0};
	int loop;
	for (loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		warrior_t* lp = enemy->players_pos[loop];
		if (lp && !NONEED_ATTACK(lp) && IS_BEAST_ID(lp->userid) && lp->catchable) {
			psw[cnt++] = enemy->players_pos[loop];
		}
	}
	
	if (!cnt){
		return NULL;
	}
	
	return psw[rand() % cnt];
}
//得到不是boss的，还活着的个数
static inline int get_no_boss_count(battle_users_t* abu, uint32_t  bossid)
{		
	int loop;
	int ret=0; 
	for (loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		warrior_t* lp = abu->players_pos[loop];
		if (lp ) {//存在
			if (! (WARRIOR_DEAD(lp) || WARRIOR_ATTACKED_OUT(lp) ) && lp->type_id!=bossid ){
				ret++;
			}
		}
	}
	return ret;
}


static inline int get_warrior_pos(battle_info_t* abi, battle_users_t* abu, userid_t uid, uint32_t petid)
{		
	int loop;
	for (loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		warrior_t* lp = abu->players_pos[loop];
		if (lp && lp->userid == uid && lp->petid == petid) {
			return loop;
		}
	}
	return -1;
}
//找个最近的随机敌人
static inline int get_near_rand_alive_warrior_pos(warrior_t* self, int pos )
{
	battle_users_t* self_team = self->self_team;
	battle_users_t* enemy_team = self->enemy_team;
	int cnt = 0;
	int psw[2 * MAX_PLAYERS_PER_TEAM] = {0};


	for (int loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
			 
		if (enemy_team->players_pos[loop] && 
				!NONEED_ATTACK(enemy_team->players_pos[loop])) {
			//可以攻击
			if (pos >= 0 && pos < MAX_PLAYERS_PER_TEAM){//自己在第一排
				if (!(self->pet_state==on_fuzhu 
							&& enemy_team->players_pos[loop]->level==1    )){
					psw[cnt++] = loop;
				}		

				continue;
			}
			
			if (loop >= 0 && loop < MAX_PLAYERS_PER_TEAM){ //对方在第一排
				if (!(self->pet_state==on_fuzhu 
							&& enemy_team->players_pos[loop]->level==1    )){
					psw[cnt++] = loop;
				}		


				continue;
			}

			int sub_pos = 0;

			//双方都在后排
			int self_front = pos - MAX_PLAYERS_PER_TEAM;
			int eme_front = loop - MAX_PLAYERS_PER_TEAM;
			warrior_t* lp_self_front = self_team->players_pos[self_front];
			if (!lp_self_front //自己前方有人
					|| NONEED_ATTACK(lp_self_front//自己前方不需要被攻击
						)){
				sub_pos++;
			}
			
			warrior_t*  lp_enemy_front = enemy_team->players_pos[eme_front];
			if (!lp_enemy_front || NONEED_ATTACK(lp_enemy_front)){
				sub_pos++;
			}

			if (sub_pos > 0){
				if (!(self->pet_state==on_fuzhu 
							&& enemy_team->players_pos[loop]->level==1    )){
					psw[cnt++] = loop;
				}		

			}
		}
	}
		
	if (!cnt){
		return -1;
	}

	return psw[rand() % cnt];
}

static inline void set_warrior_stop_attack(battle_info_t * abi, warrior_t* lp)
{
	if (!lp){
		return;
	}

	if (IS_BEAST_ID(lp->userid)){
		return;
	}
	
	SET_WARRIOR_STATE(lp->waor_state.state, stop_attack);
	if (lp->petid){
		return;
	}

	warrior_t* lp_pet = get_pet_from_warriorlist(abi, lp->userid);
	if (lp_pet == NULL){
		return;
	}

	SET_WARRIOR_STATE(lp_pet->waor_state.state, stop_attack);
}

static void clean_warrior_loop_state(warrior_t* fighter, uint8_t state_bit)
{
	if (!CHK_WARRIOR_STATE(fighter->waor_state.state, state_bit)) {
		return;
	}
	
	if (state_bit > resume_hp3_bit && state_bit < bisha_bit) {
		RESET_WARRIOR_STATE(fighter->waor_state.state, state_bit);
		return;
	}
	
	int8_t* efs = fighter->waor_state.effect_cnt;
	int8_t* rds = fighter->waor_state.round_cnt;
	efs[state_bit] = 0;
	rds[state_bit] = 0;
	RESET_WARRIOR_STATE(fighter->waor_state.state, state_bit);
}

static inline void reset_warrior_stop_attack(battle_info_t * abi, warrior_t* lp)
{
	if (!lp){
		return;
	}
	
	if (IS_BEAST_ID(lp->userid)){
		return;
	}
		
	RESET_WARRIOR_STATE(lp->waor_state.state, stop_attack);
	if (lp->petid){
		return;
	}

	warrior_t* lp_pet = get_pet_from_warriorlist(abi, lp->userid);
	if (lp_pet == NULL){
		return;
	}

	RESET_WARRIOR_STATE(lp_pet->waor_state.state, stop_attack);
}

static inline void decr_person_count(battle_info_t * abi, warrior_t* lp)
{
	if (lp->self_team == &abi->challgee){
		abi->challgee.ren_alive_count--; //challgee_cnt--;
		if (abi->challgee.team_type & team_npc_friend){
			abi->challgee.npc_fri_cnt_alive--;
		}
	}else{
		abi->challger.ren_alive_count--;//	abi->challger_cnt--;
		if (abi->challger.team_type & team_npc_friend){
			abi->challger.npc_fri_cnt_alive--;
		}
	}
}

static inline void set_warrior_attack_out(battle_info_t * abi, warrior_t* lp)
{
	if (!lp){
		return;
	}
	
	if (lp->huwei_pos){
		remove_warrior_from_huweilist(abi, lp);
	}
	

	if (CHK_WARRIOR_STATE(lp->waor_state.state, attacked_out_bit)){
		return;
	}
	
	SET_WARRIOR_STATE(lp->waor_state.state, attacked_out_bit);

	if ((abi->challger.team_type | abi->challgee.team_type) & team_beast ){
		//受攻击方等级<=15 不处理
		if (  lp->level>15 ){
			//直接设置红伤
			lp->injury_lv = injury_red;
		}
	}

	if (lp->waor_state.state & resume_hp1) { // zai sheng jiejie
		clean_warrior_loop_state(lp, resume_hp1_bit);
	}

	if (lp->waor_state.state & resume_hp2) { // zai sheng jiejie
		clean_warrior_loop_state(lp, resume_hp2_bit);
	}

	if (lp->waor_state.state & resume_hp3) { // zai sheng jiejie
		clean_warrior_loop_state(lp, resume_hp3_bit);
	}

	if (CHK_WARRIOR_STATE(lp->waor_state.state, pause_bit)){ // ting zhi xing dong biaozhiwei
		clean_one_state(lp, pause_bit, 1);
	}

	if (lp->petid){
		return;
	}

	decr_person_count(abi, lp);
	//如果是人被踢飞，则宠物也要被踢飞
	if (lp->self_team == &abi->challgee){
		abi->challgee.atk_out++;
	}else{
		abi->challger.atk_out++;
	}

	warrior_t* lp_pet = get_pet_from_warriorlist(abi, lp->userid);
	if (lp_pet == NULL){
		return;
	}

	if (lp_pet->huwei_pos){
		remove_warrior_from_huweilist(abi, lp_pet);
	}
	SET_WARRIOR_STATE(lp_pet->waor_state.state, person_atk_out);
}

static inline void set_warrior_dead_opt(battle_info_t * abi, warrior_t* lp)
{
	if (!lp){
		return;
	}

	if (CHK_WARRIOR_STATE(lp->waor_state.state, dead_bit)){
		return;
	}

	SET_WARRIOR_DEAD(lp);

	// fixme:
	// when other put <jiushu> skill on the dead object, there is a bug.
	// these bits are in using.
	// so clear follow bit when warrior is dead
	if (lp->waor_state.state & resume_hp1) { // zai sheng jiejie
		clean_warrior_loop_state(lp, resume_hp1_bit);
	}

	if (lp->waor_state.state & resume_hp2) { // zai sheng jiejie
		clean_warrior_loop_state(lp, resume_hp2_bit);
	}

	if (lp->waor_state.state & resume_hp3) { // zai sheng jiejie
		clean_warrior_loop_state(lp, resume_hp3_bit);
	}

	if (CHK_WARRIOR_STATE(lp->waor_state.state, pause_bit)){ // ting zhi xing dong biaozhiwei
		clean_one_state(lp, pause_bit, 1);
	}
	
	if (lp->petid){
		return;
	}

	decr_person_count(abi, lp);
}

static inline void set_warrior_alive_opt(battle_info_t * abi, warrior_t* lp)
{
	if (!lp){
		return;
	}

    // not in battle mode
	if (!CHK_WARRIOR_STATE(lp->waor_state.state, dead_bit)){
		return;
	}

	SET_WARRIOR_ALIVE(lp);

	if (lp->petid){
		return;
	}

	battle_users_t* team = &abi->challger;
	if (lp->self_team == &abi->challgee){
		team = &abi->challgee;
	}

	team->ren_alive_count++;
	if (IS_BEAST_ID(lp->userid)){
		team->npc_fri_cnt_alive++;
	}
}

static inline warrior_t* get_rand_alive_warrior_ex(battle_users_t* enemy, warrior_t* except)
{
	int cnt = 0;
	warrior_t* psw[2 * MAX_PLAYERS_PER_TEAM] = {0};
	int loop;
	for (loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		if (enemy->players_pos[loop] && !NONEED_ATTACK(enemy->players_pos[loop])) {
			if (enemy->players_pos[loop] != except){
				psw[cnt++] = enemy->players_pos[loop];
			}
		}
	}
	
	if (!cnt){
		return NULL;
	}
	
	return psw[rand() % cnt];

}


static inline int get_rand_alive_warrior_pos_ex(battle_users_t* enemy, warrior_t* except)
{
	int cnt = 0;
	int psw[2 * MAX_PLAYERS_PER_TEAM] = {0};
	int loop;
	for (loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		if (enemy->players_pos[loop] && !NONEED_ATTACK(enemy->players_pos[loop])) {
			if (enemy->players_pos[loop] != except){
				psw[cnt++] = loop;
			}
		}
	}
	
	if (!cnt){
		return -1;
	}
	
	return psw[rand() % cnt];

}

static inline warrior_t* get_rand_alive_warrior(battle_users_t* enemy,uint32_t self_pet_state )
{		
	int cnt = 0;
	warrior_t* psw[2 * MAX_PLAYERS_PER_TEAM] = {0};
	int loop;
	for (loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		if (enemy->players_pos[loop] && !NONEED_ATTACK(enemy->players_pos[loop])) {
			//辅助宠物，不打一级
			if (!((self_pet_state==on_fuzhu ) && enemy->players_pos[loop]->level==1   ) )
			{
				psw[cnt++] = enemy->players_pos[loop];
			}
			continue;
		}
	}
	
	if (!cnt){
		return NULL;
	}
	
	return psw[rand() % cnt];
}

static inline int get_front_rand_alive_warrior_pos(battle_users_t* enemy)
{		
	int cnt = 0;
	int psw[MAX_PLAYERS_PER_TEAM] = {0};
	int loop;
	
	for (loop = 0; loop < MAX_PLAYERS_PER_TEAM; loop++) {
		if (enemy->players_pos[loop] && !NONEED_ATTACK(enemy->players_pos[loop])) {
			psw[cnt++] = loop;
		}
	}
	
	if (!cnt){
		return -1;
	}
	
	return psw[rand() % cnt];
}

static inline warrior_t* get_rand_alive_warrior_pet(battle_users_t* enemy)
{		
	int cnt = 0;
	warrior_t* psw[2 * MAX_PLAYERS_PER_TEAM] = {0};
	int loop;
	for (loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		if (enemy->players_pos[loop] && enemy->players_pos[loop]->petid && !NONEED_ATTACK(enemy->players_pos[loop])) {
			psw[cnt++] = enemy->players_pos[loop];
		}
	}
	
	if (!cnt){
		return NULL;
	}
	
	return psw[rand() % cnt];
}

static inline warrior_t* get_front_rand_alive_warrior(battle_users_t* enemy)
{		
	int cnt = 0;
	warrior_t* psw[MAX_PLAYERS_PER_TEAM] = {0};
	int loop;
	for (loop = 0; loop < MAX_PLAYERS_PER_TEAM; loop++) {
		if (enemy->players_pos[loop] && !NONEED_ATTACK(enemy->players_pos[loop])) {
			psw[cnt++] = enemy->players_pos[loop];
		}
	}
	if (!cnt)
		return NULL;
	
	return psw[rand() % cnt];
}

static inline warrior_t* get_back_rand_alive_warrior(battle_users_t* enemy)
{		
	int cnt = 0;
	warrior_t* psw[2 * MAX_PLAYERS_PER_TEAM] = {0};
	int loop;
	for (loop = MAX_PLAYERS_PER_TEAM; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		if (enemy->players_pos[loop] && !NONEED_ATTACK(enemy->players_pos[loop])) {
			psw[cnt++] = enemy->players_pos[loop];
		}
	}
	if (!cnt)
		return NULL;
	
	return psw[rand() % cnt];
}

static inline int get_pet_pos(battle_info_t* abi, battle_users_t* abu, userid_t uid)
{		
	int loop;
	for (loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		warrior_t* lp = abu->players_pos[loop];
		if (lp && lp->userid == uid && lp->petid) {
			return loop;
		}
	}
	return -1;
}

static inline int get_warrior_pos_ex(battle_info_t* abi, userid_t uid, uint32_t petid, battle_users_t** apbu, int* apos)
{		
	battle_users_t* pbu = &abi->challger;
	warrior_t* lp = NULL;
	int loop;
	for (loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		lp = pbu->players_pos[loop];
		if (lp && lp->userid == uid && lp->petid == petid) {
			*apbu = pbu;
			*apos = loop;
			return 0;
		}
	}

	pbu = &abi->challgee;
	for (loop = 0; loop < 2 * MAX_PLAYERS_PER_TEAM; loop++) {
		lp = pbu->players_pos[loop];
		if (lp && lp->userid == uid && lp->petid == petid) {
			*apbu = pbu;
			*apos = loop;
			return 0;
		}
	}
	return -1;
}

static inline void confirm_dec_mp(warrior_t* p, uint32_t skill_type, atk_info_t* aai)
{
	if (aai){
		aai->confrm_decre_mp = (aai->confrm_decre_mp == confrm_decre_mp_no_need)?confrm_decre_mp_after_atk:aai->confrm_decre_mp;
	}
}

static inline void notify_use_medical(battle_info_t* abi, warrior_t* aw)
{	
	uint32_t buff[2] = {aw->userid, aw->waor_state.ui.itemid};
	send_to_online(battle_info_msg, 8, buff, aw->self_team->teamid, abi->batid, proto_bt_use_chemical, aw->self_team->online_id);
}

static inline void notify_chg_pos(battle_info_t* abi, warrior_t* aw)
{	
	send_to_online(battle_info_msg, 4, &aw->userid, aw->self_team->teamid, abi->batid, proto_bt_change_pos, aw->self_team->online_id);
}

static inline void notify_catch_pet(battle_info_t* abi, warrior_t* aw, uint32_t pet_type, int success, uint32_t petlevel)
{
	uint32_t buff[5] = {aw->userid, pet_type, aw->waor_state.catchpet.itemid, success, petlevel};
	send_to_online(battle_info_msg, 20, buff, aw->self_team->teamid, abi->batid, proto_bt_catch_pet, aw->self_team->online_id);
}

static inline void notify_recall_pet(battle_info_t* abi, warrior_t* aw, uint32_t cur_petid, uint32_t new_petid, int success)
{
	uint32_t buff[3] = {aw->userid, new_petid, cur_petid};
	if (success){
		send_to_online(battle_info_msg, 12, buff, aw->self_team->teamid, abi->batid, proto_bt_recall_pet, aw->self_team->online_id);
	}
	else{
		send_to_online_error(battle_info_msg, 1, aw->self_team->teamid, abi->batid, proto_bt_recall_pet, aw->self_team->online_id);
	}
}
void init_cli_handle_funs();

#endif
