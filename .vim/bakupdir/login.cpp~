/*
 * =====================================================================================
 *
 *  @file  login.cpp
 *
 *  @brief  处理登入相关的信息
 *
 *  compiler  gcc4.3.2 
 *	
 *  platform  Linux
 *
 * copyright:  TaoMee, Inc. ShangHai CN. All rights reserved
 *
 * =====================================================================================
 */

#include <string>

extern "C"{ 
#include <libtaomee/crypt/qdes.h>
#include <libtaomee/log.h>
#include <libtaomee/project/constants.h>
#include <libtaomee/project/utilities.h>
}
#include <libtaomee++/proto/Ccmd_map.h>
#include <libtaomee++/proto/proto_base.h>
#include <libtaomee++/proto/proto_util.h>

#include "./proto/ultraman_online.h" 
#include "./proto/ultraman_online_enum.h"
#include "./proto/main_login.h" 
#include "./proto/main_login_enum.h" 
#include "./proto/ultraman_db.h"
#include "./proto/ultraman_db_enum.h" 
#include "./share/share_funcs.hpp"
#include "./share/share_usr.hpp"

#include "player.hpp"
#include "login.hpp"
#include "dbproxy.hpp"
#include "switch.hpp"
#include "cli_dispatch.hpp"
#include "stat_log.hpp"


/************************************************************************/
/*                            _功能函数_                                */
/************************************************************************/

/* @brief 通过session服务器校验session是否正确
 * @param session session的内容
 * @param flag 1表示校验之后session服务器删除session，0表示不删除
 * @note  online校验session之后应删除session
 */
static int check_session(player_t *p, char session[], int game_id, int flag)
{
	main_login_check_session_in in;
	in.gameid = game_id;
	in.del_session_flag = flag;
	memcpy(in.session, session, login_session_len);

	memcpy(p->tmp_data, session, login_session_len);
	return send_msg_to_dbproxy(p, main_login_check_session_cmd, &in, p->uid);
}

int get_this_week_login_days(player_t *p, uint32_t last_login_time)
{
	uint32_t have_login_days = 0;
	//for (uint32_t i = 1; i < 4; i++) {
		//std::map<uint32_t, uint32_t>::iterator week_it = p->week_limit_info_map->find(i);
		//if (week_it != p->week_limit_info_map->end()) {
			//have_login_days++;
		//} else {
			//break;
		//}
	//}
	//bool day_not_first_login = time_is_today(last_login_time);	
	//if (have_login_days < 3 && !day_not_first_login) {
		//check_week_limit_and_update_db(p, 1, ++have_login_days, false);
	//}
	return have_login_days;
}






/************************************************************************/
/*                       Client  Request                                */
/************************************************************************/



/* @brief 通知用户服务器时间
 */
//int cli_notify_sys_time(player_t *p, Cmessage* c_in)
//{
	//cli_notify_sys_time_out out;
	//out.time = static_cast<uint32_t>(get_now_tv()->tv_sec);
	//return send_msg_to_self(p, cli_notify_sys_time_cmd, &out, 1);
//}

/************************************************************************/
/*                       Dbproxy  Callback                              */
/************************************************************************/

/* @brief 对校验session的DB返回包进行处理
 */
int main_login_check_session(player_t *p, Cmessage* c_in, uint32_t ret) 
{
	if (ret) {
		if (ret == SESSION_CHECK_ERR) {
			send_error_to_self(p, p->waitcmd, cli_session_is_wrong_err, 1);
			KERROR_LOG(p->uid, "online check session err");
			return -1;
		} else {
			/* 如果session服务器连接不上，则本地校验*/
			if (verify_login_session(p->uid, p->tmp_data) == -1) {
				send_error_to_self(p, p->waitcmd, cli_session_is_wrong_err, 1);
				KERROR_LOG(p->uid, "online check session err");
				return -1;
			}		
		}
	}
	return send_msg_to_dbproxy(p, db_proto_user_get_login_info_cmd, NULL, p->uid);
}



int main_login_check_session_new(player_t *p, Cmessage* c_in, uint32_t ret) 
{
	return 0;
}
