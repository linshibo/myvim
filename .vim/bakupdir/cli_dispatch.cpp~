/*
 * =====================================================================================
 *
 *  @file  cli_dispatch.cpp 
 *
 *  @brief  初始化协议处理函数和分发协议处理函数
 *
 *  compiler  gcc4.3.2 
 *	
 *  platform  Linux
 *
 * copyright:  TaoMee, Inc. ShangHai CN. All rights reserved
 *
 * =====================================================================================
 */

extern "C"{
#include <sys/types.h>
#include <sys/socket.h>
#include <async_serv/net_if.h>
#include <libtaomee/log.h>
}

#include <libtaomee++/proto/Ccmd_map.h>
#include <libtaomee++/proto/proto_base.h>
#include <libtaomee++/proto/proto_util.h>
#include <libtaomee++/utils/strings.hpp>
#include <libtaomee++/utils/tcpip.h>

#include "common_def.hpp"
#include "cli_dispatch.hpp"
#include "player.hpp"
#include "switch.hpp"
#include "global_data.hpp"
#include "./proto/ultraman_online.h"

//-------------------------------------------------------
//函数定义
#define PROTO_FUNC_DEF(proto_name)\
	int proto_name( player_t *p, Cmessage* p_in ) ;
#include "./proto/ultraman_online_func_def.h" 
//-------------------------------------------------------------
//对应的结构体
#include "./proto/ultraman_online.h"
//-------------------------------------------------------------
//命令绑定
typedef   int(*P_DEALFUN_T)( player_t *p, Cmessage* p_in );

#undef  BIND_PROTO_CMD
#define BIND_PROTO_CMD(cmdid,proto_name,c_in,c_out,md5_tag,bind_bitmap )\
	{cmdid, new (c_in), md5_tag,bind_bitmap ,proto_name },
Ccmd< P_DEALFUN_T> g_cmd_list[]={
#include "./proto/ultraman_online_bind_for_cli_request.h"
};


//命令map
Ccmd_map< Ccmd< P_DEALFUN_T> >  g_cmd_map;

#include "./proto/ultraman_online_enum.h" 


std::string g_version_str("2012021603");

/* @brief 根据不同的命令号调用相应的处理函数
 */
int cli_dispatch(void *data, fdsession_t *fdsess, bool first_tm)
{
   	cli_proto_head_t pkg_head;
    cli_proto_head_t * pkg = (cli_proto_head_t *)data;

    pkg_head.len = ntohl(pkg->len);
    pkg_head.cmd = ntohs(pkg->cmd);
    pkg_head.uid  = ntohl(pkg->uid);
    pkg_head.ret = ntohl(pkg->ret);
    pkg_head.seq = ntohl(pkg->seq);

	if(g_log_send_buf_hex_flag){
		char outbuf[13000];
		bin2hex(outbuf, (char*)data, pkg->len,1000);
		KDEBUG_LOG(pkg->uid, "I:[%s]", outbuf);	
	}
	report_cmd(pkg);
	if (pkg_head.cmd == cli_get_online_version_cmd) {
		KDEBUG_LOG(0, "get online version");
		cli_get_online_version(fdsess, pkg);
		return 0;
	}
	player_t *p = get_player_by_fd(fdsess->fd);
	if ((pkg_head.cmd != cli_login_cmd && !p) || (pkg_head.cmd == cli_login_cmd && p)
	   || (p && (p->uid != pkg_head.uid))) {
		KERROR_LOG(pkg_head.uid, "pkg err [cmd = %u] [p addr %p]", pkg_head.cmd, p);
		return -1;
	}
	//校验
	//if (first_tm && p && !g_log_send_buf_hex_flag) {
		//if (pkg_head.cmd != cli_login_cmd) {
			//if (is_invalid_seqno(p, pkg_head.len, pkg_head.seq_num, pkg_head.cmd)) {
				//KERROR_LOG(pkg_head.uid, "seq err: [cmd=%u]", pkg_head.cmd);
				//return send_error_to_self(p, pkg_head.cmd, cli_seqno_wrong_err, 1);
			//}
		//}
		//p->seqno = pkg_head.seq;
		//if (pkg_head.cmd != cli_login_cmd ) {
			////if (pkg_head.cmd != cli_login_cmd && (!check_body_sum(pkg_head.body, pkg_head.len - 18, pkg_head.ret))) {
			//KERROR_LOG(p->uid, "check error");
			//return send_error_to_self(p, pkg_head.cmd, cli_seqno_wrong_err, 1);
		//}
	//}

	/* 串行处理命令，如在处理命令当中，又接收到新命令则返回 */
	if (p && p->waitcmd != 0) {
		KDEBUG_LOG(pkg_head.uid, "waitcmd busy: [now_cmd = %u]", p->waitcmd);
		if (p->pending_cmd_queue->size() > 50) {
			KERROR_LOG(p->uid, "sys busy [now deal cmd %u] [wait cmd %u]",
			p->waitcmd, pkg_head.cmd);
			return send_error_to_self(p, p->waitcmd, cli_system_busy_err, 0);
		}
		KDEBUG_LOG(p->uid, "add cmd to queue [now deal cmd %u] [wait cmd %u]",
		p->waitcmd, pkg_head.cmd);

		wait_queue_t wait_info;
		wait_info.len = pkg_head.len;
		wait_info.data = g_slice_alloc0(pkg_head.len);
		memcpy(wait_info.data, data, pkg_head.len);
		p->pending_cmd_queue->push(wait_info);
		std::map<uint32_t, player_t *>::iterator it = g_pending_cmd_player.find(p->uid);
		if (it == g_pending_cmd_player.end()) {
			g_pending_cmd_player.insert(std::pair<uint32_t, player_t *>(p->uid, p));
		}
		return 0;
	}
	//if (p && !p->map && (pkg_head.cmd != cli_enter_map_cmd && pkg_head.cmd != cli_fight_wild_mon_cmd) 
		//&& !p->grp && !cmd_can_deal_not_in_map(pkg_head.cmd)) {
		//KERROR_LOG(pkg_head.uid, "user not in map: [cmd = %d] [map = %p] [grp = %p]", 
			//pkg_head.cmd, p->map, p->grp);
		//return send_error_to_self(p, p->waitcmd, cli_not_in_map_err, 0);
	//}
	if (pkg_head.cmd == cli_login_cmd) {
		/* 判断用户是否重复登入 */	
		player_t *old = get_player_by_uid(pkg_head.uid);
		if (old) {
			send_error_to_self(old, cli_notify_kick_user_offline_cmd, cli_multiple_login_err, 0);
			close_client_conn(old->fd);
			KERROR_LOG(old->uid, "multiple login");
		}

		player_t player = { };
		p = &player;
		p->uid = pkg_head.uid;
		p->fdsess = fdsess;
		p->fd = fdsess->fd;
		p->waitcmd = pkg_head.cmd;
		p->seqno = pkg_head.seq;
	}
	
	Ccmd< P_DEALFUN_T> * p_cmd_item =g_cmd_map.getitem(pkg_head.cmd);
	if (p_cmd_item == NULL) {
		KDEBUG_LOG(pkg_head.uid, "clicmd id not find: %u", pkg_head.cmd);
		return -1;
	}
	//还原对象
	p_cmd_item->proto_pri_msg->init( );
	byte_array_t in_ba ( ((char*)data)+sizeof(cli_proto_head_t),
		pkg_head.len-sizeof(cli_proto_head_t));
	in_ba.set_is_bigendian(true);
	//失败
	if (!p_cmd_item->proto_pri_msg->read_from_buf(in_ba)) {
		KDEBUG_LOG(pkg_head.uid, "client 还原对象失败 cmd:%u", pkg_head.cmd);
		return -1;	
	}
	//客户端多上传报文
	if (!in_ba.is_end()) {
		KDEBUG_LOG(pkg_head.uid, "client 过多报文 cmd:%u", pkg_head.cmd);
		return  -1;
	}
	KDEBUG_LOG(p->uid,"cmd=%u len=%u",pkg_head.cmd, pkg_head.len);	
	p->waitcmd = pkg_head.cmd;
	return p_cmd_item->func(p, p_cmd_item->proto_pri_msg);	
}


/* @brief 初始化处理客户端数据的函数数组
 */
void init_cli_handle_funs()
{
  	g_cmd_map.initlist(g_cmd_list,sizeof(g_cmd_list)/sizeof(g_cmd_list[0]));
}

/* @brief 判断命令是否用户不在地图中也可以处理
 * @return true表示可以，false不可以
 */
bool cmd_can_deal_not_in_map(uint32_t deal_cmd)
{
	uint32_t cmd[] ={

	};
		//{cli_get_mon_simple_info_cmd, cli_set_mon_status_cmd,
					  //cli_get_client_buf_info_cmd, cli_set_client_buf_info_cmd,
					  //cli_enter_map_cmd, cli_accept_task_cmd, cli_cancel_task_cmd,
					  //cli_get_task_info_cmd, cli_set_task_step_info_cmd,
					  //cli_get_spt_info_cmd,cli_get_online_can_swap_num_cmd};
	for (uint32_t i = 0; i < (sizeof(cmd) / sizeof(cmd[0])); i++) {
		if (deal_cmd == cmd[i]) {
			return true;
		}
	}
	return false;
}



#define REGISTER_TIMER_TYPE(nbr_, cb_) \
	do { \
	if (register_timer_callback(nbr_, cb_) == -1) { \
	ERROR_LOG("register timer type error\t[%u]", nbr_); \
	return -1; \
	}\
	} while(0)


/* @brief 绑定定时器类型和处理函数
 */
int init_all_timer_type()
{
	REGISTER_TIMER_TYPE(timer_connect_to_switch_timely, connect_to_switch_timely);
	REGISTER_TIMER_TYPE(timer_notify_sys_time, notify_sys_time);
	REGISTER_TIMER_TYPE(timer_send_sw_keepalive_pkg, send_sw_keepalive_pkg);
	//REGISTER_TIMER_TYPE(timer_update_today_total_time, update_today_total_time);
	REGISTER_TIMER_TYPE(timer_kick_all_usrs_offline, kick_all_usrs_offline);
	REGISTER_TIMER_TYPE(timer_connect_to_switch, connect_to_switch);
	REGISTER_TIMER_TYPE(timer_db_return_expired, db_return_expired);

	return 0;
}

/* @brief 处理缓存命令
 */
//xxxxxxxxxxxxxxx
void proc_waiting_cmd()
{
	for (std::map<uint32_t, player_t *>::iterator it = g_pending_cmd_player.begin();
	it != g_pending_cmd_player.end();) {
		player_t *p = it->second;
		if (p == NULL || p->waitcmd != 0) {
			it++;
			continue;
		}
		uint32_t size = p->pending_cmd_queue->size();
		for (uint32_t i = 0; i < size; i++) {
			if (p->waitcmd != 0) {
				break;
			}
			wait_queue_t wait_info = p->pending_cmd_queue->front();
			cli_proto_head_t *head = (cli_proto_head_t *)wait_info.data;
			KDEBUG_LOG(p->uid, "deal pengding cmd [cmd = %u]", head->cmd);
			p->pending_cmd_queue->pop();
			int err =  cli_dispatch(wait_info.data, p->fdsess, false);
			g_slice_free1(wait_info.len, wait_info.data);
			if (err == -1) {
				send_error_to_self(p, p->waitcmd, cli_critical_err, 1);
				uint32_t size = p->pending_cmd_queue->size();
				for (uint32_t i = 0; i < size; i++) {
					wait_queue_t info = p->pending_cmd_queue->front();
					g_slice_free1(info.len, info.data);
					p->pending_cmd_queue->pop();
				}
				break;
			}
		}
		if (!p->pending_cmd_queue->size()) {
			g_pending_cmd_player.erase(it++);
		} else {
			it++;
		}
	}
}

/* @brief 返回服务的版本号
 */
void cli_get_online_version(fdsession_t *fdsess, cli_proto_head_t *head)
{
	const uint32_t version_buf_len = 256;
	uint8_t version_buf[version_buf_len] = { };
	cli_proto_head_t *version_pkg = (cli_proto_head_t *)version_buf;
	version_pkg->len = version_buf_len;
	version_pkg->uid = head->uid;
	version_pkg->cmd = head->cmd;
	version_pkg->ret = 0;

	std::vector<std::string> file_name_list;
	strncpy((char*)version_pkg->body, get_version_str(g_version_str, file_name_list,false).c_str(),
	version_buf_len - sizeof(cli_proto_head_t));
	send_pkg_to_client(fdsess, version_pkg, version_buf_len);
}

/* @brief 计算当前命令的序列号
 * @param pkg_len 当前包的长度
 * @param seqno player保存的序列号
 * @param cmd 命令号
 */
uint32_t calc_seqno(uint32_t pkg_len, uint32_t seqno, uint16_t cmd)
{
	return seqno - seqno / 7 + 147 + pkg_len % 21 + cmd % 13;
}

/* @brief 校验序列号是否错误
 * @return true 表示序列号不正确，false 表示序列号正确
 */
bool is_invalid_seqno(player_t *p, uint32_t head_len, uint32_t head_seqno, uint16_t cmd)
{
	uint32_t cal_seqno = calc_seqno(head_len, p->seqno, cmd);
	if (cal_seqno != head_seqno) {
		KERROR_LOG(p->uid, "[cal_seqno = %u head_seqno = %u player_seqno = %u]", cal_seqno, head_seqno, p->seqno);
		return true;
	}
	return false;
}

/* @brief 汇报online的命令，以便对online的命令进行统计
 */
void report_cmd(cli_proto_head_t *head)
{
	report_cmd_head_t report_head;
	report_head.len = htonl(head->len);
	report_head.ver = 0;
	report_head.cmd = htonl(head->cmd);
	report_head.id = htonl(head->uid);
	report_head.ret = 0;

	if (!dbsvr_udp_fd[udp_report_cmd].send(reinterpret_cast<char *>(&report_head), sizeof(report_cmd_head_t))) {
		if (init_udp_socket(udp_report_cmd) < 0) {
			KERROR_LOG(head->uid, "send udp msg failed and init udp also socket failed: [index = %u]", udp_report_cmd);
			return;
		}
		////重发
		if (!dbsvr_udp_fd[udp_report_cmd].send((char *)(&report_head), sizeof(report_cmd_head_t))) {
			KERROR_LOG(head->uid, "send udp msg failed: [index = %u]", udp_report_cmd);
		}
	}
}
