/*
 * =====================================================================================
 *
 *  @file  common_def.hpp 
 *
 *  @brief  保存常用的结构体信息，和常量的定义。
 *
 *  compiler  gcc4.3.2 
 *	
 *  platform  Linux
 *
 * copyright:  TaoMee, Inc. ShangHai CN. All rights reserved
 *
 * =====================================================================================
 */

#ifndef COMMON_DEF_H_
#define COMMON_DEF_H_

extern "C"{
#include <libtaomee/tm_dirty/tm_dirty.h>
#include <inttypes.h>
#include<libtaomee/project/types.h>
#include <libtaomee/timer.h>
#include <libtaomee/list.h>
}
#include "libtaomee++/proto/proto_base.h"
enum {
	nick_len = 16,	/* 昵称的最大字节数 */
	money_day_limit = 5000, /* 一天获取的赛尔豆的上限 */
	max_sign_len  = 100, /* 签名的最大长度 */
};

/* 框架使用命令号 */
enum dbproxy_cmd{
	global_chat_add_cmd	= 0xF133, /* 聊天协议 */
	global_item_update_cmd	= 0xF135, /* 道具明细协议 */ 
	global_submit_msg_add_cmd = 0xF130, /* 投稿协议 */
};

/*定时器类型*/
enum timer_type_t{
	timer_connect_to_switch_timely	= 1,
	timer_notify_sys_time			= 2,
	timer_send_sw_keepalive_pkg		= 3,
	timer_player_rand_map_wild		= 4,
	timer_update_today_total_time	= 5,
	timer_kick_all_usrs_offline		= 6,
	timer_connect_to_switch			= 7,
	timer_db_return_expired			= 8,

};

enum udp_socket{
	udp_socket_cli_chat	= 0, /* udp类型：客户端聊天 */
	//cnc_udp_record_online_id = 1, /* 记录网通用户登入的online的ID号 */
	//tel_udp_record_online_id = 2, /* 记录电信用户登入的online的ID号 */
	//udp_submit_contribution = 3, /* 投稿 */
	udp_report_cmd = 1, /* 汇报命令频率 */
	udp_report_chat_content = 2, /* 上报聊天的内容 */
	max_udp_socket,  /* udp最大个数 */
};

enum tcp_socket_index_t {
	gf_dbproxy_cnc_fd_index = 0,
	gf_dbproxy_wt_fd_index = 1,
	tcp_index_max
};


/* 链表数组的大小 */
const int bucket_size = 200;



/** @brief 用于检查switch是否连接时的定时器中，传递给回调函数的第一个参数。
 */
struct timer_head_t {
	list_head_t	timer_list;
};


#pragma pack(1)


/** @brief 服务器间通信协议头
 */
struct svr_proto_header_t { 
	uint32_t len; /*协议总长度*/
	uint32_t seq; /*序列号*/
	uint16_t cmd; /*命令号*/
	uint32_t ret; /*返回值*/
	userid_t uid; /*米米号*/
	uint16_t area_id; /*区域服务器号*/
};

#pragma pack()

static inline uint64_t gen_key_by_uid_role(uint32_t user_id, uint32_t role_tm)
{       
    uint64_t key = user_id;
    key = (key << 32) | role_tm;
    return key;
}

#define CHECK_DIRTYWORD(p_, msg_) \
do { \
	int r_ = tm_dirty_check(7, reinterpret_cast<char*>(msg_)); \
	if(r_ > 0) { \
		KERROR_LOG((p_)->user_id, "check_dirty_word: msg[%s] ", msg_);\
		return send_to_self_error(p_, (p_)->wait_cmd, cli_dirty_word_err , 1); \
	} \
} while (0)

#define CHECK_INVALID_WORD(p_, msg_) \
	do { \
		const char* bad_char = "\n\v\t\f\r"; \
		if (((msg_)[0] == '\0') || strpbrk(reinterpret_cast<char*>(msg_), bad_char)) { \
			return send_to_self_error(p_, (p_)->wait_cmd, cli_dirty_word_err, 1); \
		} \
	} while (0)

#define SAFE_DELETE(P) \
{\
	delete (P);\
	(P) = NULL;\
}

#define FOREACH(container,it) \
	for(typeof((container).begin()) it = (container).begin();it!=(container).end();++it)

#define CHECK_CALLBACK_ERR(p_, base_, err_) \
        do { \
            if ( (err_) ) { \
                return send_error_to_self(p_, (p_)->waitcmd, base_ + (err_), 1); \
            } \
        } while (0)

#define CHECK_DBERR(p_, err_) CHECK_CALLBACK_ERR(p_,cli_db_err,err_)
#define SET_BIT(x,y) x|=(1<<y) //将X的第Y位置1
#define CLR_BIT(x,y) x&=!(1<<y) //将X的第Y位清0
#endif
