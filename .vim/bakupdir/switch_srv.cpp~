/*
* =====================================================================================
*
*  @file  switch_srv.cpp 
*
*  @brief  初始化协议处理函数和分发协议处理函数
*
*  compiler  gcc4.3.2 
*	
*  platform  Linux
*
* copyright:  TaoMee, Inc. ShangHai CN. All rights reserved
*
* =====================================================================================
*/
#include <cerrno>
#include <cstdlib>
#include <cstring>
#include <algorithm>

extern "C" {
#include <stdint.h>
#include <libtaomee/utils.h>
#include <libtaomee/timer.h>
#include <libtaomee/conf_parser/config.h>
}
#include <libtaomee++/inet/pdumanip.hpp>
#include <dbser/proto_header.h>
#include <libtaomee++/proto/proto_base.h>
#include <libtaomee++/proto/Ccmd_map.h>
#include <libtaomee++/proto/proto_util.h>
#include <libtaomee++/utils/strings.hpp>

#include "switch_srv.hpp"
#include "dbproxy.hpp"
#include "../proto/ultraman_switch_enum.h"
#include "../proto/ultraman_db.h"
#include "../proto/ultraman_db_enum.h"
#include "../proto/ultraman_online.h"
#include "../proto/ultraman_online_enum.h"
#include "../share/share_funcs.hpp"
#include "../share/share_usr.hpp"
using namespace taomee;
/*                       public  function                               */
/************************************************************************/

void SwitchServ::init()
{
	max_usr_id = config_get_intval("max_uid", 0);
	user_num_limit = config_get_intval("user_num_limit", 200);
	stat_file = config_get_strval("statistic_file");
	idc_zone = config_get_intval("idc_zone", 2);
	DEBUG_LOG(" --------------------switch start --------------------- ");
	DEBUG_LOG("   idc=%u static_flile=%s max_num=%u",idc_zone, stat_file, user_num_limit);
	DEBUG_LOG(" ------------------------------------------------------ ");
	
	/*添加定时事件*/
	timeval tv;
	gettimeofday(&tv, 0);
	tv.tv_sec += 1;
	alive_event = emgr.add_event(*this, &SwitchServ::keep_online_alive_event, tv, interval_keepalive * 1000, -1);
	tv.tv_sec += 1;
	svr_event = emgr.add_event(*this, &SwitchServ::get_recommend_svr_event, tv, interval_get_recommended_svr * 1000, -1);
	tv.tv_sec += 1;
	usr_num_event = emgr.add_event(*this, &SwitchServ::get_total_usr_num_event, tv, interval_get_usr_num * 1000, -1);

}

void SwitchServ::fini()
{
	/*删除定时事件*/
	emgr.remove_event(alive_event);
	emgr.remove_event(svr_event);
	emgr.remove_event(usr_num_event);
	//清楚区域服务器
	for( uint32_t loop=0 ; loop<aserver.size() ; loop++){
		delete aserver[loop];
	}
}


/** @brief 处理所有定时事件
*/
void SwitchServ::proc_event()
{
	emgr.process_events();
}


/** @brief 处理某online关闭情况
*/
void SwitchServ::close_online(int fd)
{
	clear_online_info_by_FD(fd);	
}

int SwitchServ::handle_recommend_svr_list(svr_proto_header_t* head, Cmessage* c_in, fdsession_t* fdsess)
{
	uint32_t ret = 0;
	svr_proto_header_t ph;
	set_svr_proto_head(&ph, head->uid, sizeof(svr_proto_header_t), head->seq, 
			svr_proto_recommend_svr_list_cmd, ret, 0);
	svr_proto_recommend_svr_list_out out;
	std::map<uint16_t,AreaServ*>::iterator ait=aserver.begin();
	for(  ; ait != aserver.end() ; ait++ ){
		AreaServ *pas=(ait->second);
		if(pas->online_info.size()){
			online_info_t& oi= pas->get_online_by_recommond(user_num_limit);
			recommend_area_list_t tmp;
			tmp.online_id=oi.online_id;	
			tmp.online_port=oi.online_port;
			memcpy(tmp.online_ip,oi.online_ip,sizeof(tmp.online_ip));
			tmp.user_num=pas->user_num;
			tmp.area_id=pas->aid;
			out.svrlist.push_back(tmp);
			KDEBUG_LOG(head->uid,"recommand svr =%u online=%u", tmp.area_id, tmp.online_id);
		}
	}
	KDEBUG_LOG(head->uid, "get recommend svr list [size = %lu]", out.svrlist.size());
	return send_msg_to_client(fdsess, (char*)&ph, &out);
}


/** @brief 处理新启动的online发过来的注册信息
 */
int SwitchServ::handle_register_online(svr_proto_header_t* head, Cmessage* c_in, fdsession_t* fdsess)
{
	svr_proto_register_online_info_in* p_in = P_IN;
	KDEBUG_LOG(head->uid, "online register info:[area=%u] [id=%u] [fd=%d]", 
			head->areaid,p_in->online_id, fdsess->fd);
	//找到区域服务器
	AreaServ *pas=get_area_serv(head->areaid);
	if( !pas ){
		pas= new AreaServ(head->areaid);
	}
	aserver.insert(std::make_pair(head->areaid, pas));
	fdmap.insert(std::make_pair(fdsess->fd, pas));

	if((p_in->online_id > max_online_num) || (p_in->online_id == 0)){
		KERROR_LOG(head->uid, "invalid online: [id = %u] [fd = %d]", p_in->online_id, fdsess->fd);
		return -1;
	}

	/*online重复注册*/
	online_info_t& oldonline = pas->find_online_by_ID(p_in->online_id);
	if (&oldonline) {
		KERROR_LOG(head->uid, "online id repeated: [id = %u] [pre_ip = %s] [pre_port = %u] [fd=%u] [new_fd=%u]", 
			oldonline.online_id, oldonline.online_ip, oldonline.online_port, oldonline.m_fdsess->fd, fdsess->fd);
		close_client_conn(oldonline.m_fdsess->fd);
		return 0;
	}

	online_info_t  info;
	info.online_id = p_in->online_id;
	memset(info.online_ip, 0, sizeof(info.online_ip));
	memcpy(info.online_ip, p_in->online_ip, sizeof(p_in->online_ip));
	info.online_port = p_in->online_port;
	info.user_num = p_in->user_list.size();
	for (size_t i = 0; i < p_in->user_list.size(); ++i) {
		if (p_in->user_list.at(i) >= max_usr_id) {
			KERROR_LOG(head->uid, "uid err! [uid  = %u]", p_in->user_list.at(i));
			continue;
		}
		user_info_t ui;
		ui.online_id=info.online_id;
		pas->userinfo.insert(std::make_pair(p_in->user_list.at(i),ui));
		pas->online_user_info[info.online_id].push_back(p_in->user_list.at(i));
	}
	
	info.m_fdsess = fdsess;
	info.last_active_time = get_now_tv()->tv_sec;
	pas->online_info.push_back(info);

	/*更新推荐服务器列表*/
	get_recommend_svr_event();
	return 0;
}

/** @brief 获取一定范围的服务器列表
 */
int SwitchServ::handle_get_ranged_svrlist(svr_proto_header_t* head, Cmessage* c_in, fdsession_t* fdsess)
{
	uint32_t ret = 0;
	svr_proto_get_ranged_svrlist_in* p_in = P_IN;
	AreaServ *pas=get_area_serv(head->areaid);

	if ((p_in->start_id == 0) || (p_in->start_id > p_in->end_id) 
		|| ((p_in->end_id - p_in->start_id) > max_get_online_num) 
		|| ((p_in->start_id == p_in->end_id) && (p_in->end_id > max_online_num))
		|| ((p_in->start_id == p_in->end_id) && 
			(p_in->mon_highest_level >= new_comer_max_level))){
		svr_proto_header_t ph;
		svr_proto_get_ranged_svrlist_out out;
		set_svr_proto_head(&ph, head->uid, sizeof(svr_proto_header_t), head->seq, 
			svr_proto_get_ranged_svrlist_cmd, 0,head->areaid);
		KERROR_LOG(head->uid, "invalid info: start=%u end=%u mon_highest_level=%u", 
				   p_in->start_id, p_in->end_id, p_in->mon_highest_level);
		return send_msg_to_client(fdsess, (char*)&ph, &out);
	}

	/*KDEBUG_LOG(head->uid, "login send info: start=%u end=%u mon_highest_level=%u",
			     p_in->start_id, p_in->end_id, p_in->mon_highest_level);*/

	if (p_in->end_id > max_online_num) {
		p_in->end_id = max_online_num;
	}
	
	Sort_type_ex less;
	pas->online_info.sort(less);

	svr_proto_get_ranged_svrlist_out out;
	size_t count = p_in->end_id - p_in->start_id + 1;
	for (std::list<online_info_t>::iterator it = pas->online_info.begin(); (it != pas->online_info.end()) 
		&& (out.svr_list.size() <= count); ++it) {
		if (it->online_id == 0) {
			KERROR_LOG(head->uid, "invalid online id: [ip=%s, port=%u]", it->online_ip, it->online_port);
		}

		if ((it->online_id >= p_in->start_id) && (it->online_id <= p_in->end_id) && (it->online_id)) {
			recommend_svr_list_t info;
			info.online_id = it->online_id;
			memcpy(info.online_ip, it->online_ip, sizeof(it->online_ip));
			info.online_port = it->online_port;
			info.user_num = it->user_num;
			info.friend_num = 0;
			//info.is_new_comer_svr = is_new_comer_svr;
			out.svr_list.push_back(info);

		}
	}

	svr_proto_header_t ph;
	set_svr_proto_head(&ph, head->uid, sizeof(svr_proto_header_t), head->seq, 
		svr_proto_get_ranged_svrlist_cmd, ret,head->areaid);

	/*KDEBUG_LOG(head->uid, "get ranged svrlist: [out.size=%lu] [start=%u] [end=%u]", 
		out.svr_list.size(), p_in->start_id, p_in->end_id);*/
	
	return send_msg_to_client(fdsess, (char*)&ph, &out);
}

/** @brief 得到online心跳包
 */
int SwitchServ::handle_online_keepalive(svr_proto_header_t* head, Cmessage* c_in, fdsession_t* fdsess)
{
	AreaServ *pas=get_area_serv(head->areaid);
	online_info_t& online = pas->find_online_by_FD(fdsess->fd);
	if (&online) {
		online.last_active_time = get_now_tv()->tv_sec;
		return 0;
	}else {
		ERROR_RETURN(("unregister online send keepalive pkg [fd = %u]", fdsess->fd), -1);
	}
}



int SwitchServ::handle_transmit(svr_proto_header_t* head, Cmessage* c_in, fdsession_t* fdsess)
{
	svr_proto_transmit_in*p_in=P_IN;
	AreaServ *pas=get_area_serv(head->areaid);
	user_info_t& ui=pas->get_userinfo_by_uid(p_in->recvid);
	online_info_t& oi=pas->find_online_by_ID(p_in->recvid);

	svr_proto_transmit_out out;
	out.msg.msg_len=p_in->msg.msg_len;
	memcpy(out.msg.msg, p_in->msg.msg, sizeof(p_in->msg.msg));
	if(&ui && &oi && ui.role_tm == p_in->recv_role_tm) {
		svr_proto_header_t ph;
		set_svr_proto_head(&ph, p_in->recvid, sizeof(svr_proto_header_t), 0, 
				svr_proto_transmit_cmd, 0, head->areaid);
		KDEBUG_LOG(head->uid, "transmit across svr(online):  [sender_id=%u][receiver = %u] ", 
				head->uid, p_in->recvid);
		return send_pkg_to_client(oi.m_fdsess, p_in->msg.msg, p_in->msg.msg_len);
	}else {
		uint16_t cmd= (head->seq)&0xFFFF; 
		switch (cmd){
			case  cli_add_friend_cmd:
			case  cli_chat_private_msg_cmd:
				send_msg_to_dbproxy(head->areaid,p_in->recvid,p_in->recv_role_tm
						,db_proto_send_offline_msg_cmd, &out);			
				break;
			default :
				break;
		}
	}
	return 0;
}

/** @brief 用户上线报告
 */
int SwitchServ::handle_user_login_online(svr_proto_header_t* head, Cmessage* c_in, fdsession_t* fdsess)
{
	svr_proto_user_login_report_in *p_in=P_IN;	
	AreaServ *pas=get_area_serv(head->areaid);
	online_info_t& info = find_online_by_FD(fdsess->fd);
	if (&info) {
		//已登录在某online
		std::map<uint32_t,user_info_t>::iterator it=pas->userinfo.find(head->uid);
		if (it !=  pas->userinfo.end()) {
			KERROR_LOG(head->uid, "muti login [pre_online = %u] [now_online = %u]", 
					info.online_id, info.online_id); 
			kick_user_off(head->areaid, head->uid, 0, 0);
		}
		user_info_t tmp;
		tmp.online_id=info.online_id;
		tmp.role_tm = p_in->role_tm;
		pas->userinfo.insert(std::make_pair(head->uid,tmp));
		pas->online_user_info[info.online_id].push_back(head->uid);
		++(info.user_num);
		pas->user_num++;
		KDEBUG_LOG(head->uid, "user login [area=%u online=%u, usr_size=%u total=%u]", 
				pas->aid, info.online_id, info.user_num,pas->user_num); 
	}else {
		KERROR_LOG(head->uid, "unregister online [cmd = %u]", head->cmd);
		return -1;
	}

	return 0;
}

/** @brief 用户下线报告
 */
int SwitchServ::handle_user_logout_online(svr_proto_header_t* head, Cmessage* c_in, fdsession_t* fdsess)
{
	AreaServ *pas=get_area_serv(head->areaid);
	online_info_t& info = find_online_by_FD(fdsess->fd);
	if (&info) {
		uint16_t online_id = 0;
		std::map<uint32_t,user_info_t>::iterator it=pas->userinfo.find(head->uid);
		if (it!=pas->userinfo.end() && (online_id=it->second.online_id)) {
			if (info.online_id != online_id) {
				KERROR_LOG(head->uid, "login/logout err. online_id=%u, offline_id=%u",
						online_id, info.online_id);
			}else{
				pas->userinfo.erase(head->uid);
				pas->online_user_info[info.online_id].remove(head->uid);
				if (info.user_num > 0) {
					--(info.user_num);
					pas->user_num--;
				}else{
					KERROR_LOG(head->uid, "~~usr < 0");
				}
				KDEBUG_LOG(head->uid, "user logout [online = %u]", info.online_id);
			}
		}
	}else {
		KERROR_LOG(head->uid, "unregister online send user logout [cmd = %u]", 
				head->cmd);
		return -1;
	}	
	return 0;
}

/** @brief 查看用户是否在线(若switch重启，将不知道各online上的用户名单，因此此函数将返回不正确数据)
 */
int SwitchServ::handle_check_users_onoff(svr_proto_header_t * head, Cmessage* c_in, fdsession_t* fdsess)
{
	svr_proto_check_users_onoff_in * p_in = P_IN;
	svr_proto_check_users_onoff_out out;
	uint16_t online_id;
	user_onoff_status_t st;
	AreaServ *pas=get_area_serv(head->areaid);
	for (size_t i = 0; i < p_in->user_list.size(); ++i) {
		uint32_t uid=p_in->user_list.at(i).user_id, role_tm=p_in->user_list.at(i).role_tm;
		if (p_in->user_list.at(i).user_id < max_usr_id) {
		 	online_id = pas->find_onlineid_by_uid(uid);
			user_info_t &ui=pas->get_userinfo_by_uid(uid);
			if( ui.role_tm != role_tm){
				online_id=0;
			}
			st.user_id = uid;
			st.role_tm = role_tm;
			st.online_id = online_id;
			out.user_status_list.push_back(st);
		}
	}
	svr_proto_header_t ph;
	set_svr_proto_head(&ph, head->uid, sizeof(svr_proto_header_t), head->seq, 
		svr_proto_check_users_onoff_cmd, 0, head->areaid);

	KDEBUG_LOG(head->uid, "check user onoff [in_size = %lu] [out_size = %lu]", 
		p_in->user_list.size(), out.user_status_list.size()); 

	return send_msg_to_client(fdsess, (char*)&ph, &out);
}


/************************************************************************/
/*                     SwitchServ private function                               */
/************************************************************************/
/** @brief 从map(online_user_info)中清除相应online上的用户，并更新online人数
 */
int SwitchServ::send_error_to_online(fdsession_t *fdsess,uint16_t areaid,uint32_t uid, uint16_t cmd,uint32_t err)
{
	svr_proto_header_t ph;
	set_svr_proto_head(&ph, uid, sizeof(svr_proto_header_t), 0, cmd, err, areaid);
	return send_pkg_to_client(fdsess, &ph, sizeof(svr_proto_header_t));
}

bool SwitchServ::check_area_serv(uint16_t area_id)
{
	std::map<uint16_t, AreaServ*>::iterator ait=aserver.find(area_id);
	if( ait==aserver.end()){
		return false;
	}
	return true;
}

AreaServ* SwitchServ::get_area_serv(uint16_t area_id)
{
	std::map<uint16_t, AreaServ*>::iterator ait=aserver.find(area_id);
	if( ait==aserver.end()){
		return NULL;
	}
	return ait->second;
}

int SwitchServ::kick_user_off(uint16_t areaid,uint32_t uid, uint32_t seq, uint32_t reason)
{
	AreaServ* pas=get_area_serv(areaid);
	online_info_t* poi=pas->kick_user_off(uid);
	if(poi){
		svr_proto_header_t ph;
		set_svr_proto_head(&ph, uid, sizeof(svr_proto_header_t), seq, 
			svr_proto_kick_user_offline_cmd, 0, pas->aid);
		svr_proto_kick_user_offline_out out;
		out.reason = reason;
		return send_msg_to_client(poi->m_fdsess, (char*)&ph, &out);
	}
	else {
		KERROR_LOG(uid, "Failed to kick user off(unregister online) [uid = %u] ", uid );
	}

	return 0;
}

void SwitchServ::clear_online_info_by_FD(int fd)
{
	//DEBUG_LOG("Switch:try clear_online_info_by_FD:%d",fd);
	std::map<int,AreaServ*>::iterator it=fdmap.find(fd);
	if( it != fdmap.end() ){
		it->second->clear_online_info_by_FD(fd);	
		fdmap.erase(fd);
	}
}

online_info_t& SwitchServ::find_online_by_FD(int fd)
{
	std::map<int,AreaServ*>::iterator it=fdmap.find(fd);
	if( it != fdmap.end() ){
		return it->second->find_online_by_FD(fd);	
	}
	return *(reinterpret_cast<online_info_t *>(0));
}


/** @brief 定时事件：对所有online服务器进行排序
 */
int SwitchServ::get_recommend_svr_event()
{
	std::map<uint16_t, AreaServ*>::iterator ait=aserver.begin();
	for(  ; ait != aserver.end() ; ait++ ){
		AreaServ *pas=ait->second;
		Sort_type less;
		pas->online_info.sort(less);
			
		pas->recommend_svrs_set.clear();
		for (std::list<online_info_t>::iterator iter = pas->online_info.begin(); 
				iter!=pas->online_info.end(); ++iter) {
			//KDEBUG_LOG(0, "id=%u usr=%u", iter->online_id, iter->user_num);
			pas->recommend_svrs_set.push_back(iter->online_id);
		}

	}
	return 0;
}

/** @brief 填充与其他服务器通信的协议头
 */
void SwitchServ::set_svr_proto_head(svr_proto_header_t *hdr, userid_t uid, uint32_t pkglen, 
									uint32_t seq, uint16_t cmd, uint32_t ret, uint16_t areaid)
{
	hdr->len = pkglen;
	hdr->seq = seq;
	hdr->cmd = cmd;
	hdr->ret = ret;
	hdr->uid = uid;
	hdr->areaid=areaid;
}

/** @brief 定时事件：查询是否有死掉的online
 */
int SwitchServ::keep_online_alive_event()
{
	clear_dead_onlines();
	get_recommend_svr_event();
	return 0;
}

/** @brief 从列表online_info中清除死掉的online
 */
void SwitchServ::clear_dead_onlines()
{
	std::map<uint16_t,AreaServ*>::iterator ait=aserver.begin();
	for(  ; ait != aserver.end() ; ait++ ){
		AreaServ *pas=(ait->second);
		int time = get_now_tv()->tv_sec;
		std::list<online_info_t>::iterator it = pas->online_info.begin();
		//DEBUG_LOG("clear dead online areaid %u %lu",pas->aid, pas->online_info.size());
		for ( ; it != pas->online_info.end(); ) {
			//DEBUG_LOG("online size %lu onlineid %u",pas->online_info.size(),it->online_id);
			if ( (time - (it->last_active_time)) > interval_keepalive) {
				KDEBUG_LOG(0, "dead online [area_id =%u online_id = %u] [ip = %s] [port = %u] [interval = %u]", 
					pas->aid,it->online_id, it->online_ip, it->online_port, time - (it->last_active_time));
				close_client_conn((it->m_fdsess)->fd);
				it = pas->online_info.begin();
			}else{
				++it;
			}
		}
	}
}

/** @brief 定时事件：获得所有online的用户数
 */
int SwitchServ::get_total_usr_num_event()
{
	std::map<uint16_t,AreaServ*>::iterator ait=aserver.begin();
	uint32_t num = 0;
	for(  ; ait != aserver.end() ; ait++ ){
		uint32_t count=0;
		AreaServ *pas=ait->second;
		typedef std::list<online_info_t>::iterator iter;
		for (iter it = pas->online_info.begin(); it != pas->online_info.end(); ++it) {
			count += it->user_num;
		}
		num += count;
		pas->user_num=count;
	}
	uint32_t stat_tmp[] = { num };
	if (idc_zone == 0) {
		statistic_msglog(stat_id_online_usr_num_0, stat_tmp, sizeof(stat_tmp));
	}else if (idc_zone == 1)	{
		statistic_msglog(stat_id_online_usr_num_1, stat_tmp, sizeof(stat_tmp));
	}
	return 0;
}

//
/************************************************************************/
/*                     AreaServ pub  function                               */
/************************************************************************/

user_info_t& AreaServ::get_userinfo_by_uid(uint32_t uid)
{
	std::map<uint32_t, user_info_t>::iterator it=userinfo.find(uid);
	if( it == userinfo.end() ){
		return *(reinterpret_cast<user_info_t *>(0));
	}
	return (it->second);
}

online_info_t& AreaServ::get_online_by_recommond(uint32_t max_user)
{
	typedef std::list<online_info_t>::iterator iter;
	for (iter oit = online_info.begin(); oit != online_info.end(); ++oit) {
		if (oit->user_num <= max_user) {
			return *oit;
		}
	}
	return *(online_info.begin());
}

uint16_t AreaServ::find_onlineid_by_uid( userid_t uid)
{
	std::map<uint32_t,user_info_t>::iterator it=userinfo.find(uid);
	if (it == userinfo.end()) {
		return 0;
    }
	return it->second.online_id;
}

/** @brief 根据fd在online_info中查找online信息
 */
online_info_t& AreaServ::find_online_by_FD(int fd)
{
	typedef std::list<online_info_t>::iterator iter;
	for (iter oit = online_info.begin(); oit != online_info.end(); ++oit) {
		if ((oit->m_fdsess)->fd == fd) {
			return *oit;
		}
	}
	return *(reinterpret_cast<online_info_t *>(0));
}


/** @brief 根据online_id在online_info中查找online信息
 */
online_info_t& AreaServ::find_online_by_ID( uint16_t online_id)
{
	typedef std::list<online_info_t>::iterator iter;
	for (iter it = online_info.begin(); it != online_info.end(); ++it) {
		if (it->online_id == online_id) {
			return *it;
	    }
	}
	return *(reinterpret_cast<online_info_t *>(0));
}

/** @brief 以fd清除此online上的所有用户
 */
void AreaServ::clear_online_info_by_FD(int fd)
{	
	online_info_t & online = find_online_by_FD(fd);
	//DEBUG_LOG("Area:try clear_online_info_by_FD:%d",fd);
	if (&online) {
		online_user_list user_list = online_user_info[online.online_id];
		userinfo.erase(userinfo.begin(),userinfo.end());
		user_list.clear();
		/*online_info中剔除此online*/
		typedef std::list<online_info_t>::iterator iter;
		for (iter it = online_info.begin(); it != online_info.end();) {
			if (it->online_id == online.online_id) {
				online_info.erase(it);
				KDEBUG_LOG(0, "clear online usr online list [online = %u]", online.online_id);
				break;
			} else {
				++it;
			}
		}
	} else {
		KERROR_LOG(0, "error when find online to clear usr list [fd = %d]", fd);
	}
}

/** @brief 清除online_info列表中ID号为online_id的信息 
 */
void AreaServ::clear_online_info_by_ID(uint16_t online_id)
{	
	online_info_t & online = find_online_by_ID( online_id);
	if (&online) {
		online_user_list user_list = online_user_info[online.online_id];
		/*将原来这个online的在线人员对应online_id置0*/
		for(std::list<userid_t>::iterator iter = user_list.begin(); iter != user_list.end(); ++iter) {   
			userinfo.erase(*iter) ;
		}
		/*此online对应的user列表清除*/
		user_list.clear();

		/*online_info中剔除此online*/
		typedef std::list<online_info_t>::iterator iter;
		for (iter it = online_info.begin(); it != online_info.end(); ++it) {
			if (it->online_id == online_id) {
			 online_info.erase(it);
			 DEBUG_LOG("clear online [id = %u] [ip = %s]", online.online_id, online.online_ip);
			 break;
			}
		}
	}
	else {
		ERROR_LOG("error clear online [id = %u]", online_id);
	}
}

/** @brief 从map(online_user_info)中清除相应online上的用户，并更新online人数
 */
online_info_t* AreaServ::kick_user_off(uint32_t uid)
{
	uint16_t online_id = find_onlineid_by_uid(uid);
	online_user_info[online_id].remove(uid);
	userinfo.erase(uid);

	online_info_t& online = find_online_by_ID(online_id);
	if (&online && online.user_num > 0) {
		KDEBUG_LOG(uid, "kick usr off [online = %u ]", online.online_id);
		--(online.user_num);
		user_num--;
	} else {
		KERROR_LOG(uid, "Failed to kick user off(unregister online) [uid = %u] [online = %u] %u", uid, online_id ,online.user_num);
		return NULL;
	}
	return &online;
}
