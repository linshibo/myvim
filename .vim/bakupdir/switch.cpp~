/**
 * =====================================================================================
 *
 * @file  switch.cpp
 *
 * @brief 处理和switch服务器相关的命令
 *
 * compiler  GCC4.1.2
 * platform  Linux
 *
 * copyright:  TaoMee, Inc. ShangHai CN. All rights reserved.
 * 		
 * =====================================================================================
 */


extern "C"{
#include <string.h>
#include <libtaomee/project/utilities.h>
#include <libtaomee/conf_parser/config.h>
#include <libtaomee/log.h>
#include <libtaomee/timer.h> 
#include <async_serv/dll.h> //get_server_id() ...
}

#include "switch.hpp"
#include "global_data.hpp"
#include "common_def.hpp"
#include "../proto/ultraman_online_enum.h"
#include "../proto/ultraman_switch_enum.h"

//-------------------------------------------------------------
//函数定义
#undef  BIND_PROTO_CMD
#define BIND_PROTO_CMD(cmdid,proto_name,c_in,c_out,md5_tag,bind_bitmap )\
    int proto_name ## _callback( player_t *p, Cmessage* c_in, uint32_t ret) ;
#include "./proto/ultraman_switch_bind_sw_for_online.h"
#undef  BIND_PROTO_CMD

//对应的结构体
#include "../proto/ultraman_switch.h"
//-------------------------------------------------------------
//命令绑定
typedef   int(*P_DEALFUN_T)(player_t *p, Cmessage* c_in, uint32_t ret);

#undef  BIND_PROTO_CMD
#define BIND_PROTO_CMD(cmdid,proto_name,c_in,c_out,md5_tag,bind_bitmap )\
{cmdid, new (c_out), md5_tag,bind_bitmap ,proto_name ## _callback },

Ccmd< P_DEALFUN_T> g_switch_cmd_list[]={
#include "../proto/ultraman_switch_bind_sw_for_online.h" 
};

//命令map
Ccmd_map< Ccmd< P_DEALFUN_T> >  g_switch_cmd_map;



/* @brief 处理switch返回的包，分发到相应的处理函数中
 * @param data 返回包
 * @param len switch返回包的长度 
*/
void handle_switch_return(svr_proto_header_t* data, uint32_t len)
{
	player_t* p = NULL;
	svr_proto_header_t *pkg = data;

	if (data->seq) {
		uint32_t waitcmd = data->seq & 0xFFFF; //低16位命令
		int	  connfd  = data->seq >> 16; //高16位fd

		p = get_player_by_fd(connfd);
		if (!p || p->waitcmd != waitcmd) {
			KERROR_LOG(pkg->uid, "sw re err: [p = %p] [uid = %u] [cmd = %u] [seq = %u]",
				p, pkg->uid, pkg->cmd, pkg->seq);
			return;
		}
	}else{
		p = get_player_by_uid(pkg->uid);
		if (!p && (pkg->uid)) {
			KERROR_LOG(pkg->uid, "sw re err: [p = %p] [uid = %u] [cmd = %u] [seq = %u]",
				p, pkg->uid, pkg->cmd, pkg->seq);
			return;
		}
	}
	
	KDEBUG_LOG(pkg->uid, "switch return\t[user_id = %u %u] [cmd = %u] [ret =%u] len:%u",
		pkg->uid, pkg->uid, pkg->cmd, pkg->ret, pkg->len);

	//----------------------------------------------------
	Ccmd< P_DEALFUN_T> * p_cmd_item =g_switch_cmd_map.getitem( pkg->cmd );
	if (p_cmd_item == NULL) {
		DEBUG_LOG("sw re cmd id not find: %u", pkg->cmd);
		return;
	}

	int sw_ret = pkg->ret;
	Cmessage * msg;

	if (sw_ret == 0){//成功
		//还原对象
		p_cmd_item->proto_pri_msg->init( );

		byte_array_t in_ba ( (char *)data+sizeof(svr_proto_header_t), pkg->len - sizeof(svr_proto_header_t));
		//失败
		if (!p_cmd_item->proto_pri_msg->read_from_buf(in_ba)) {
			DEBUG_LOG("sw 还原对象失败");
			return;	
		}

		//客户端多上传报文
		if (!in_ba.is_end()) {
			DEBUG_LOG("sw re 过多报文");
			return;
		}
		msg = p_cmd_item->proto_pri_msg;
	} else {
		msg = NULL;
	}
	p_cmd_item->func(p, msg, sw_ret);	
}


/* @brief 向switch发送包
 * @param cmd 发送DB的命令号
 * @param msg 发送DB的包体的内容，不包括包头
 * @param user_id 用户米米号
 */
int send_msg_to_switch(player_t* p, uint16_t cmd, Cmessage *msg,  userid_t user_id)
{
	if (switch_fd == -1) {
		connect_to_switch(NULL, NULL);
	}

	if (switch_fd == -1) {
		ERROR_LOG("SEND TO SWITCH FAILED: [FD = %d]", switch_fd );
		//if (p) {
			////return send_to_self_error(p, p->waitcmd, cli_critical_err, 1);
		//}
		return 0;
	}

	svr_proto_header_t pkg;
	pkg.len = sizeof(svr_proto_header_t);
	pkg.seq = (p ? ((p->fd << 16) | p->waitcmd) : 0);
	pkg.cmd = cmd;
	pkg.ret = 0;
	pkg.uid  = user_id;
	pkg.area_id=area_id;

	KDEBUG_LOG(user_id,"SEND TO SW: [sw_cmd = %u] ", cmd);
	return net_send_msg(switch_fd, reinterpret_cast<char *>(&pkg), msg);
}


/* @brief 初始化命令处理函数列表
 */
void init_switch_handle_funs()
{
	g_switch_cmd_map.initlist( g_switch_cmd_list,sizeof(g_switch_cmd_list)/sizeof(g_switch_cmd_list[0]) );
}

int svr_proto_register_online_info(player_t *p, Cmessage* c_in);
/* @brief 首次连接switch，并向其发送online信息
 */
int connect_to_switch(void* owner, void* data)
{
	switch_fd = connect_to_service(config_get_strval("service_switch"), 0, 65535, 1);
	//switch_fd = connect_to_svr(config_get_strval("switch_ip"), config_get_intval("switch_port", 0), 65535, 1);
	if (switch_fd != -1) {
		svr_proto_register_online_info(NULL, NULL);
	}
	return 0;
}

/* @brief 添加定时器，3秒重连switch
 */
int connect_to_switch_timely(void* owner, void* data)
 {
	 KERROR_LOG(0, "[owner:%p, data:%p, switch_fd:%d]", owner, data, switch_fd);
	 if (!data) {
		 ADD_TIMER_EVENT_EX(&timer_events, timer_connect_to_switch_timely, reinterpret_cast<void*>(1), get_now_tv()->tv_sec + 3);
	 } else if (switch_fd == -1) {
		 ADD_TIMER_EVENT_EX(&timer_events, timer_connect_to_switch, reinterpret_cast<void*>(0), get_now_tv()->tv_sec + 5);
	 }
	 return 0;
 }


 /************************************************************************/
 /*                       Online  Request                                */
 /************************************************************************/

/* @brief online向switch注册信息
 */
int svr_proto_register_online_info(player_t *p, Cmessage* c_in)
{
	svr_proto_register_online_info_in out;
	out.online_id = static_cast<uint16_t>(get_server_id());
	snprintf(out.online_ip, sizeof(out.online_ip),"%s", get_server_ip());
	out.online_port = static_cast<uint16_t>(get_server_port());
	list_head_t* cur;
	list_head_t* next;
	for (int i = 0 ; i < bucket_size; ++i) {
		list_for_each_safe (cur, next, &(uid_buckets[i])) {
			player_t* p = list_entry(cur, player_t, online_player_list);
			out.user_list.push_back(p->uid);
		}
	}

	DEBUG_LOG("register online info: [online_id=%u, ip=%s, port=%u, usr_size=%lu] ",
		out.online_id, out.online_ip, out.online_port, out.user_list.size());

	return send_msg_to_switch(p, svr_proto_register_online_info_cmd, &out, 0);
}

/* @brief 添加定时器，30秒向switch发送心跳包
 */
int send_sw_keepalive_pkg(void* owner, void* data)
{
	send_msg_to_switch(0, svr_proto_keepalive_cmd, 0, 0);   
	ADD_TIMER_EVENT_EX(&timer_events, timer_send_sw_keepalive_pkg, 0, get_now_tv()->tv_sec + 30);
	return 0;
}

/* @brief 用户上线报告
 */
int svr_proto_user_login_report(player_t *p)
{
	svr_proto_user_login_report_in out;
	out.role_tm=p->role_tm;
	return send_msg_to_switch(NULL, svr_proto_user_login_report_cmd, &out, p->uid);
}

/* @brief 用户下线报告
 */
int svr_proto_user_logout_report(player_t *p, Cmessage* c_in)
{
	return send_msg_to_switch(NULL, svr_proto_user_logout_report_cmd, c_in, p->uid);
}

 /************************************************************************/
 /*                       switch callback								*/
 /************************************************************************/

int svr_proto_check_users_onoff_callback( player_t *p, Cmessage* c_in, uint32_t ret)
{
	svr_proto_check_users_onoff_out *p_in=P_IN; 
	KDEBUG_LOG(p->uid,"svr_proto_check_users_onoff");
	for( uint32_t loop=0 ; loop<p_in->user_status_list.size() ; loop++){
		DEBUG_LOG("uid=%u role_tm=%u online_id=%u",
				p_in->user_status_list[loop].user_id,p_in->user_status_list[loop].role_tm,
				p_in->user_status_list[loop].online_id);
	}
	return 0;
}

int svr_proto_transmit_callback( player_t *p, Cmessage* c_in, uint32_t ret)
{
	svr_proto_transmit_out *p_in=P_IN;
	if(p){
		KDEBUG_LOG(p->uid,"svr_proto_transmit");
		send_pkg_to_self(p, p_in->msg.msg, p_in->msg.msg_len,1);
	}
	return 0;
}

int svr_proto_kick_user_offline_callback( player_t *p, Cmessage* c_in, uint32_t ret)
{
	if(p){
		KDEBUG_LOG(p->uid, "be kick off");
		send_error_to_self(p, cli_login_cmd, cli_login_otherwhere_err, 1);
		del_player(p);
	}
	return 0;
}

