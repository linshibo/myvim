#include "cli_proto.hpp"
#include "cli_dispatch.hpp"
#include "player.hpp"
#include "global_data.hpp"
extern "C"{
#include <sys/types.h>
#include <sys/socket.h>
#include <async_serv/net_if.h>
#include <libtaomee/log.h>
}

#include <libtaomee++/proto/Ccmd_map.h>
#include <libtaomee++/proto/proto_base.h>
#include <libtaomee++/proto/proto_util.h>
#include <libtaomee++/utils/strings.hpp>
#include <libtaomee++/utils/tcpip.h>

uint8_t pkgbuf[1 << 21];

/* @brief 向所有用户发信息
*/
void send_msg_to_all(uint16_t cmd, Cmessage* c_in)
{
	list_head_t* cur;
	list_head_t* next;
	for (int i = 0 ; i < bucket_size; ++i) {
		list_for_each_safe(cur, next, &(uid_buckets[i])) {
			player_t* p = list_entry(cur, player_t, online_player_list);
			send_msg_to_self(p, cmd, c_in, 0);
		}
	}
}
void init_cli_proto_head(void* header, player_t* p, uint16_t cmd, uint32_t len)
{
    cli_proto_head_t* proto = reinterpret_cast<cli_proto_head_t*>(header);
    proto->uid  = htonl(p->uid);
    proto->len = htonl(len);
    proto->cmd = htons(cmd);
    proto->ret = htonl(0);
    proto->seq = htonl(p->seqno);
}
void init_cli_proto_head(void* header, userid_t uid, uint32_t seqno, uint16_t cmd, uint32_t len, uint32_t ret)
{
    cli_proto_head_t* proto = reinterpret_cast<cli_proto_head_t*>(header);
    proto->uid  = htonl(uid);
    proto->len = htonl(len);
    proto->cmd = htons(cmd);
    proto->ret = htonl(ret);
    proto->seq = htonl(seqno);
}
/* @brief 向client发送包
 */
int send_msg_to_cli(player_t *p, uint16_t cmd, Cmessage *msg)
{
	cli_proto_head_t st;
	st.len = htonl(sizeof(cli_proto_head_t));
	st.cmd = htons(cmd);
	st.ret = htonl(0);
	st.seq= htonl(p->seqno);
	st.uid = htonl(p->uid);
	return send_msg_to_client_bigendian(p->fdsess, (char *)&st, msg);
}

int send_pkg_to_self(player_t* p,  const void* pkg, const int pkglen, int completed)
{
    if (send_pkg_to_client(p->fdsess, pkg, pkglen) == -1) {
		ERROR_LOG("FAILED TO ERR TO CLIENT [UID=%u] ", p->uid);
	    return -1;
	}

    if (completed) {
		p->waitcmd = 0;
	    p->tmp_data_len = 0;
	}
    return 0;	
}

/* @brief 给客户端返回错误码
 * @param completed 如果为1表示命令处理结束，可接受下一条命令
 * 		  如果为0表示命令处理未结束
 */
int send_error_to_self(player_t* p, int cmd, int err, int completed)
{
	cli_proto_head_t proto = { };
    proto.uid = htonl(p->uid);
    proto.cmd = htons(cmd);
	proto.len = htonl(sizeof(cli_proto_head_t));
	proto.ret = htonl(err);

    if (send_pkg_to_client(p->fdsess, &proto, sizeof(cli_proto_head_t)) == -1) {
		ERROR_LOG("FAILED TO ERR TO CLIENT [UID=%u] [CMD=%u]", p->uid, cmd);
	    return -1;
	}

    if (completed) {
		p->waitcmd = 0;
	    p->tmp_data_len = 0;
	}
	
	KERROR_LOG(p->uid, "ERR RETURN [CMD %u] [ERR CODE %d]", cmd, err);
	
	//send_stat_err_code(p->uid, cmd, err);
    return 0;	
}

/* @brief 发送数据包到p用户
 * @param completed 如果为1则表示命令处理结束，0为未结束
 */
int send_msg_to_self(player_t *p, uint16_t cmd, Cmessage *c_out, int completed)
{
	
	if (send_msg_to_cli(p, cmd, c_out) == -1) {
		ERROR_LOG("failed to send pkg to client: uid=%u cmd=%u fd=%d", p->uid, cmd, p->fdsess->fd);
		return -1;
	}
	if (completed) {
		p->waitcmd = 0;
		p->tmp_data_len = 0;
	} 

	return 0;   
}

int send_pkg_to_map(player_t *p, char *pkg, uint32_t len, bool if_skip_notifier, bool if_clear_waitcmd)
{
    int completed = (if_clear_waitcmd == true) ?DO_CLEAR_WAITCMD :DONT_CLEAR_WAITCMD;
    if (p->cur_map == NULL) {
        return send_pkg_to_self(p, pkg, len, completed);
    }
    list_head_t * l = NULL;
    list_for_each(l, &(p->cur_map->player_list)) {
        player_t *p_dest = list_entry(l, player_t, maphook);
        if (p == p_dest) {
            if(if_skip_notifier == 1) continue;
            send_pkg_to_self(p_dest, (char*)pkgbuf, len, completed);
        } else {
		    send_pkg_to_self(p_dest, (char*)pkgbuf, len, DONT_CLEAR_WAITCMD);
	    }
    }
    return 0;
}

int send_msg_to_map(player_t * p, Cmessage * p_out, uint16_t cmd, bool if_skip_notifier, bool if_clear_waitcmd)
{
    int completed = (if_clear_waitcmd == true) ?DO_CLEAR_WAITCMD :DONT_CLEAR_WAITCMD;
    if (p->cur_map == NULL) {
        return send_msg_to_self(p, cmd, p_out, completed);
    }
    list_head_t * l = NULL;
    list_for_each(l, &(p->cur_map->player_list)) {
        player_t *p_dest = list_entry(l, player_t, maphook);
        if (p == p_dest) {
            if(if_skip_notifier == DO_SKIP_NOTIFIER) continue;
            send_msg_to_self(p_dest, cmd, p_out, completed);
        } else {
		    send_msg_to_self(p_dest, cmd, p_out, 0);
	    }
    }
    return 0;
}
