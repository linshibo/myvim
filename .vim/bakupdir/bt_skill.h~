#ifndef BT_SKILL_H
#define BT_SKILL_H
#ifdef __cplusplus
extern "C"
{
#endif

#include <string.h>
#include <libxml/tree.h>
#include <async_serv/net_if.h>

#include "utils.h"
#include "proto.h"
#ifdef __cplusplus
}
#endif

#include "bt_online.h"

enum{
	near_attack = 1,
	remote_attack = 2,
};

typedef struct skill_lv_info {
	//uint32_t			cool_round;
	uint8_t				target_scale;//目标类型与 skill_attr里的是同一个,当技能等级不同时发生变化则配置此子段
	uint8_t				round_cnt;//持续回合数
	uint8_t				atk_cnt;//对个体伤害几次
	uint8_t				atk_rate;//伤害倍率(100%)
	uint8_t				target_cnt;//攻击的目标个数,skill_attr里的target_scale==0或者1时有效 
	uint8_t				add_hp_rate;//增加hp百分比
	uint8_t				add_mp_rate;//增加mp百分比
	uint8_t				fantan_rate;//反弹的概率
	uint8_t				fanji_rate;//反击的概率
	uint8_t				anti_atk_rate;//抵抗物理或者魔法攻击的比率
}__attribute__((packed)) skill_lv_info_t;

typedef struct skill_use_mp {
	uint32_t			id;
	uint8_t				prof;
	int16_t				mp_a;
	int16_t				mp_b;
	uint32_t			exp_para;
	skill_lv_info_t		lvinfo[MAX_SKILL_LEVEL];
}__attribute__((packed))skill_mp_exp_t;
enum{
	target_asc=1,//	随机目标 按照速度由低到高
	target_desc=2,//随机目标 按照速度由高到低	
	target_row=3,//排目标	
	target_all=4,//全体目标	
};
typedef struct skill_attr {
	uint32_t			id;
	uint8_t				weapon;
	uint8_t				skill_type;
	uint8_t				target_scale;//目标类型 0 1随机几个  2 排  3 全体  详见target_asc
	uint8_t				target_type;
	uint8_t				nature;
	uint8_t             applystatus;//ApplyStatus指令选中对象状态， 0正常，1击倒，2全部
	uint8_t             usr_type;

	uint8_t				prof;
	int16_t				mp_a;
	int16_t				mp_b;
	uint32_t			exp_para;
	//uint8_t             use_person;
	skill_lv_info_t		lvinfo[MAX_SKILL_LEVEL+1];
}__attribute__((packed))skill_attr_t;

/*enum{*/
/*topic_type_beitouxi = 1,*/
/*topic_type_touxi=2,*/
/*topic_type_hp=3,*/
/*topic_type_usr_define = 10,*/

/*topic_type_phy_atk=(topic_type_usr_define + 1),*/
/*topic_type_mp_atk=(topic_type_usr_define + 2),*/
/*};*/

/*typedef struct beast_topic{*/
/*uint8_t  topic_type;*/
/*uint32_t topic_id;*/
/*uint16_t topic_rate;*/
/*}__attribute__((packed))beast_topic_t;*/

typedef struct pet_skill_attr{
	uint32_t          id;
	uint32_t          lv;
}__attribute__((packed))pet_skill_attr_t;


//skill_mp_exp_t* get_skill_mp_exp(uint32_t skill_type, uint8_t prof);
skill_attr_t* get_skill_attr(uint32_t skill_type);
/*beast_topic_t* get_beast_topic(uint32_t type, uint32_t topicid);*/

//int load_skill_use_mp(xmlNodePtr cur);
int load_skill_attr(xmlNodePtr cur);
/*int load_beast_topic(xmlNodePtr cur);*/
/*int get_rand_beast_topic_id(uint8_t type);*/


void init_attck_proc_func();
void init_attck_proc_pet_func();
void get_valid_alive_enemy_pos(battle_info_t* abi, warrior_t* p, atk_info_t* aai, skill_attr_t* psa);
warrior_t* get_valid_attack_warrior(battle_info_t* abi, warrior_t* p, atk_info_t* aai, skill_attr_t* psa);
warrior_t* get_valid_attack_warrior_ex(battle_info_t* abi, warrior_t* p, atk_info_t* aai);

void resolve_and_calc_step_battle_result(battle_info_t* abi, atk_info_t* aai);
void set_fangyu_state_after_first_attack(warrior_t* p_fighter, atk_info_t* aai);

void change_attr_before_attack(warrior_t* p, resolved_atk_t* ara, battle_info_t* abi);
void change_attr_after_attack(warrior_t* p, resolved_atk_t* ara, battle_info_t* abi);

void calc_warrior_prop_for_prepare_skill(warrior_t* p, atk_info_t* aai);

resolved_atk_t* common_resolve_sprite_atk(warrior_t* p, atk_info_t* aai, battle_info_t* abi, battle_users_t* enemy);
static inline resolved_atk_t* alloc_resolve_atk(warrior_t* p, atk_info_t* aai, battle_info_t* abi, int inc_seq)
{
	KDEBUG_LOG(p->userid,"petid=%d action:atk=(skill:%u,lv:%d,pos:%d,mark:%u)",
			p->petid,aai->atk_type,aai->atk_level,aai->atk_pos,aai->atk_mark);
	resolved_atk_t* pra = (resolved_atk_t*)g_slice_alloc0(sizeof(resolved_atk_t));
	pra->seq     = (inc_seq) ? (++abi->seq_in_round) : abi->seq_in_round;
	pra->fighter_id = p->userid;
	pra->petid = p->petid;
	pra->atk_type = aai->atk_type;
	pra->atk_level = aai->atk_level;
	//pra->heji_seq = aai->heji_seq;
	pra->change_hp=0;
	pra->change_mp=0;
	
	list_add_tail(&pra->atk_list, &abi->attack_list);
	return pra;
}


#endif
