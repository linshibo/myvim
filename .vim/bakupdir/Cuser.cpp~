/**
 * =====================================================================================
 *
 * @file  Cuser.cpp
 *
 * @brief 用户基本信息
 *
 * compiler  gcc4.3.2
 *
 * platform  Linux
 *
 * copyright:  TaoMee, Inc. ShangHai CN. All rights reserved.
 * 		
 * =====================================================================================
 */

#include <string>
#include <algorithm>
#include <cmath>
#include "Cuser.h"
#include "benchapi.h"
#include "stat_log.h"

#include <libtaomee++/utils/strings.hpp>
#include <libtaomee++/proto/proto_util.h>
#include <libtaomee++/bitmanip/bitmanip.hpp>

//#include "./share/share_funcs.hpp"
//#include "./share/share_usr.hpp"

#define DB_USER_INFO "USER_INFO"
#define T_BASE_INFO "t_user"


enum {
	nick_len = 16,
	once_msg_len  = 140, /* 一条离线消息的最大长度 */	
	msg_buf_len	= 2048, /* 离线消息存储最大长度 */
	max_offline_msg_num	= 14, /* 离线消息存储最大数量 */
};

enum {
	forbid_24 = 1, /* 用户被禁24小时 */
	forbid_7 = 2, /* 用户被禁一周 */
	forbid_14 = 4, /* 用户被禁两周 */
	forbid_forever = 8, /* 用户永久被禁 */
};

Cuser::Cuser(mysql_interface *db):CtableRoute(db, DB_USER_INFO, T_BASE_INFO, "user_id")
{

}

int Cuser::get_role_info(uint16_t area_id, userid_t user_id, db_proto_get_role_info_out & out)
{
	GEN_SQLSTR(this->sqlstr, "select role_tm,nick,prof from %s where user_id=%u  and area_id=%u",
			this->get_table_name(user_id),
			user_id,
			area_id
			);
	STD_QUERY_WHILE_BEGIN_NEW(this->sqlstr,out.roles);
		INT_CPY_NEXT_FIELD(item.role_tm);
		BIN_CPY_NEXT_FIELD(item.nick, nick_len);
		INT_CPY_NEXT_FIELD(item.prof);
	STD_QUERY_WHILE_END_NEW();
	return 0;
}

int Cuser::get_friend_info(DEFAULT_ARGS, db_proto_get_user_info_out & out)
{
	GEN_SQLSTR(this->sqlstr, "select nick from %s where user_id=%u and area_id=%u and role_tm=%u",
			this->get_table_name(user_id),
			user_id,
			area_id,
			role_tm);
	STD_QUERY_ONE_BEGIN(this->sqlstr,KEY_EXISTED_ERR);
		BIN_CPY_NEXT_FIELD(out.nick, nick_len);
	STD_QUERY_ONE_END();
	return 0;
}

int Cuser::get_user_login_info(uint16_t area_id, userid_t user_id,uint32_t role_tm, db_proto_user_login_out* out)
{
	int count=0;
	char buf[msg_buf_len];
	GEN_SQLSTR(this->sqlstr, "select nick,prof,map_x,map_y,msglist from %s where user_id=%u and area_id=%u and role_tm=%u",
			this->get_table_name(user_id),
			user_id,
			area_id,
			role_tm
			);
	STD_QUERY_ONE_BEGIN(this->sqlstr,KEY_EXISTED_ERR);
		INT_CPY_NEXT_FIELD(out->prof);
		BIN_CPY_NEXT_FIELD(out->nick, nick_len);
		INT_CPY_NEXT_FIELD(out->map_x);
		INT_CPY_NEXT_FIELD(out->map_y);
		BIN_CPY_NEXT_FIELD(buf, msg_buf_len);
        out->offline_msg_list.read_from_buf_ex(buf,sizeof(buf));
		out->role_tm=role_tm;
	STD_QUERY_ONE_END();
	return count;	
}

int Cuser::get_role_num(uint16_t area_id, userid_t user_id, uint32_t *count)
{
	GEN_SQLSTR(this->sqlstr, "select count(role_tm) from %s where  user_id=%u and area_id=%u ",
			this->get_table_name(user_id),
			user_id,
			area_id
			);
	STD_QUERY_ONE_BEGIN(this->sqlstr,KEY_EXISTED_ERR);
		INT_CPY_NEXT_FIELD(*count);
	STD_QUERY_ONE_END();
	return 0;	
}

int Cuser::set_flag(DEFAULT_ARGS, uint32_t flag)
{
	GEN_SQLSTR(this->sqlstr, "update %s set flag=%u where user_id=%u and area_id=%u and role_tm=%u",
			this->get_table_name(user_id),
			flag,
			user_id,
			area_id,
			role_tm);
	return this->exec_insert_sql(this->sqlstr, KEY_EXISTED_ERR);	

}
int Cuser::create_raw_role(uint16_t area_id, userid_t user_id, uint32_t role_tm,char* nick, uint8_t prof)
{
	char nick_mysql[mysql_str_len(nick_len)];
	set_mysql_string(nick_mysql, nick, nick_len);
	GEN_SQLSTR(this->sqlstr, "insert into %s"
			"(user_id,area_id,role_tm, nick, prof) "
			"values(%u, %u, %u, '%s', %u)",
			this->get_table_name(user_id),
			user_id,
			area_id,
			role_tm,
			nick_mysql,
			prof);
	return this->exec_insert_sql(this->sqlstr, KEY_EXISTED_ERR);	

}

/** @brief 检查用户是否存在 
 */
int Cuser::check_user(DEFAULT_ARGS)
{
    uint32_t count = 0;
    GEN_SQLSTR(this->sqlstr, "select count(*)"
        " from %s where user_id = %u and area_id=%u and role_tm=%u",
        this->get_table_name(user_id),
        user_id,
		area_id,
		role_tm);
    STD_QUERY_ONE_BEGIN(this->sqlstr, USER_ID_NOFIND_ERR);
        INT_CPY_NEXT_FIELD(count);
    STD_QUERY_ONE_END_WITHOUT_RETURN();

    if (count== 0) { //
        return USER_ID_NOFIND_ERR;
    }
    return SUCC;
}

int Cuser::set_int_value(DEFAULT_ARGS, const char* field,uint32_t value)
{
    GEN_SQLSTR(this->sqlstr, "update %s set %s=%u where user_id = %u and  area_id=%u and role_tm=%u",
        this->get_table_name(user_id),
		field,
		value,
        user_id,
		area_id,
		role_tm);
	return this->exec_update_sql(this->sqlstr, KEY_NOFIND_ERR);
}

int Cuser::update_logout_data(DEFAULT_ARGS, db_proto_logout_save_data_in* in)
{
	GEN_SQLSTR(this->sqlstr, "update %s set map_x=%u ,map_y=%u ,map_id=%u where user_id = %u and area_id=%u and role_tm=%u",
		this->get_table_name(user_id),
		in->map_x,
		in->map_y,
		in->map_id,
		user_id,
		area_id,
		role_tm);
	return this->exec_update_sql(this->sqlstr, KEY_NOFIND_ERR);
}

int Cuser::set_int_value_bit(DEFAULT_ARGS, const char* field,uint32_t bitid, uint32_t value)
{
	if( value ){
		GEN_SQLSTR(this->sqlstr, "update %s set %s=%s&(1<<%u) where user_id = %u and  area_id=%u and role_tm=%u",
			this->get_table_name(user_id),
			field,
			field,
			bitid,
			user_id,
			area_id,
			role_tm);
	}else{
		GEN_SQLSTR(this->sqlstr, "update %s set %s=%s|~(1<<%u) where user_id = %u and area_id=%u and role_tm=%u",
			this->get_table_name(user_id),
			field,
			field,
			bitid,
			user_id,
			area_id,
			role_tm);
	}
	return this->exec_update_sql(this->sqlstr, KEY_NOFIND_ERR);
}

int Cuser::get_int_value(DEFAULT_ARGS, const char* field,uint32_t* value)
{
    GEN_SQLSTR(this->sqlstr, "select %s from %s where user_id = %u and area_id=%u and role_tm=%u",
		field,
        this->get_table_name(user_id),
        user_id,
		area_id,
		role_tm);
    STD_QUERY_ONE_BEGIN(this->sqlstr, USER_ID_NOFIND_ERR);
        INT_CPY_NEXT_FIELD(*value);
    STD_QUERY_ONE_END_WITHOUT_RETURN();
	return 0;
}

int Cuser::get_offline_msg(DEFAULT_ARGS, msg_list_t *p_msg )
{
    GEN_SQLSTR(this->sqlstr, "select msglist from %s where user_id = %u and  area_id=%u and role_tm=%u",
            get_table_name(user_id),
            user_id,
			area_id,
            role_tm );
    char buf[ msg_buf_len ] ={0};
    STD_QUERY_ONE_BEGIN(this->sqlstr, USER_ID_NOFIND_ERR);
        BIN_CPY_NEXT_FIELD(buf, sizeof(buf));
        p_msg->read_from_buf_ex(buf,sizeof(buf));
    STD_QUERY_ONE_END();
}

int Cuser::update_offline_msg(DEFAULT_ARGS, msg_list_t *p_msg )
{

    char buf[ msg_buf_len] ={0};
    char buf_mysql[mysql_str_len(sizeof(buf) )] ={0};

    uint32_t  real_buf_len;
    //set to buf
    bool ret=p_msg->write_to_buf_ex(buf,sizeof( buf), &real_buf_len  );
    if (!ret ) {
        DEBUG_LOG("rest space not enough[offline msg]");
        return -1;
    }
    set_mysql_string(buf_mysql, buf , real_buf_len );

    GEN_SQLSTR(this->sqlstr, "UPDATE %s SET offline_msg ='%s' where user_id = %u and area_id=%u and role_tm=%u",
            get_table_name(user_id),
            buf_mysql,
            user_id,
			area_id,
            role_tm);
    return exec_update_sql(sqlstr, USER_ID_NOFIND_ERR);
}

