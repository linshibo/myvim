#include <libtaomee++/inet/pdumanip.hpp>
extern "C"
{
#include <arpa/inet.h>
#include <libtaomee/timer.h>
#include <libtaomee/crypt/qdes.h>
#include <libtaomee/project/constants.h>
#include <libtaomee/dataformatter/bin_str.h>
#include <libtaomee/project/utilities.h>
}

#include "friends.hpp"
#include "db_friends.hpp"
#include "global_data.hpp"
#include "cli_dispatch.hpp"
#include "proto/ultraman_db.h"
#include "proto/ultraman_db_enum.h"
#include "proto/ultraman_switch.h"
#include "proto/ultraman_switch_enum.h"
#include "switch.hpp"
using namespace taomee;

int db_check_user_exist(player_t *p, uint32_t checked_uid, uint32_t role_tm)
{
	return send_msg_to_dbproxy(p,  checked_uid,role_tm, db_proto_check_user_exist_cmd, NULL);	
}

int db_proto_check_user_exist_callback(DB_DEFAULT_ARG)
{
	db_proto_check_user_exist_out *p_in = P_IN;
	KDEBUG_LOG(p->uid,"db_proto_check_user_exist_callback");
	switch (p->waitcmd) {
		case cli_add_friend_cmd :
			if (ret) {
				return send_error_to_self(p,p->waitcmd, ret, 1);
			} else {
				player_t* pdest=get_player_by_uid(p_in->userid);
				if(pdest &&  pdest->role_tm==p_in->role_tm ){
					//在线，即时通知
					cli_friend_notify_added_out noti_out;	
					noti_out.user.user_id = p->uid;
					noti_out.user.role_tm = p->role_tm;
					memcpy(noti_out.user_nick, p->nick, sizeof(noti_out.user_nick));
					send_msg_to_self(pdest,cli_friend_notify_added_cmd, &noti_out,  1);
				}else{
					//通知
					svr_proto_transmit_in out;
					out.recvid=p_in->userid;
					out.recv_role_tm=p_in->role_tm;
					int idx = sizeof(cli_proto_head_t);
					pack(out.msg.msg, p->uid, idx);
					pack(out.msg.msg, p->role_tm, idx);
					pack(out.msg.msg, p->nick, sizeof(p->nick), idx);
					init_cli_proto_head(out.msg.msg, p_in->userid,0,cli_friend_notify_added_cmd,idx,0);
					DEBUG_LOG("xxxx msg size:%lu",sizeof(out.msg.msg));
					out.msg.msg_len = idx;
					send_msg_to_switch(0, svr_proto_transmit_cmd, &out, p->uid);   
				}
				return do_add_friend(p, p_in->userid, p_in->role_tm, FORBID_ADD_FRIEND(p->flag));
			}
			send_msg_to_self(p, p->waitcmd, 0, 1);
			break;
		case cli_add_to_blacklist_cmd :
			if (ret) {
				return send_error_to_self(p,p->waitcmd, ret, 1);
			} else {
				return do_add_to_blacklist(p, p_in->userid, p_in->role_tm);
			}
			break;
		default :
			break;
	}
	return 0;
}

int db_add_friend(player_t *p, uint32_t user_id, uint32_t role_tm)
{
 	KDEBUG_LOG(p->uid,"db_add_friend:%u %u",user_id, role_tm);
	db_proto_add_friend_in out;
	out.ufriend.user_id = user_id;
	out.ufriend.role_tm = role_tm;
	return send_msg_to_dbproxy(p, p->uid, p->role_tm, db_proto_add_friend_cmd, &out);
}

int db_del_friend(player_t *p, uint32_t user_id, uint32_t role_tm)
{
	db_proto_del_friend_in out;
	out.ufriend.user_id = user_id;
	out.ufriend.role_tm = role_tm;
	return send_msg_to_dbproxy(p, p->uid, p->role_tm, db_proto_del_friend_cmd, &out);
}

int db_add_to_blacklist(player_t *p, uint32_t user_id, uint32_t role_tm)
{
	db_proto_add_to_blacklist_in out;
	out.blacked_user.user_id = user_id;
	out.blacked_user.role_tm = role_tm;
	return send_msg_to_dbproxy(p, p->uid, p->role_tm, db_proto_add_to_blacklist_cmd, &out);
}

int db_del_from_blacklist(player_t *p, uint32_t user_id, uint32_t role_tm)
{
	db_proto_del_from_blacklist_in out;
	out.unblacked_user.user_id = user_id;
	out.unblacked_user.role_tm = role_tm;
	return send_msg_to_dbproxy(p, p->uid, p->role_tm, db_proto_del_from_blacklist_cmd, &out);
}

int db_get_user_info(player_t *p, uint32_t user_id, uint32_t role_tm)
{
	return send_msg_to_dbproxy(p, user_id, role_tm,  db_proto_get_user_info_cmd, NULL);	
}

int db_proto_get_user_info_callback(DB_DEFAULT_ARG)
{
	CHECK_DBERR(p, ret);
	db_proto_get_user_info_out *p_in = P_IN;
	cli_get_user_info_out out;
	out.userid=p_in->userid;
	out.role_tm=p_in->role_tm;
	memcpy(out.nick, p_in->nick, sizeof(out.nick));
	return send_msg_to_self(p, cli_get_user_info_cmd, &out, 1);
}

