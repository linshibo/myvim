/*
 * =====================================================================================
 *
 *       Filename:  login_impl.hpp
 *
 *    Description:  副登录
 *
 *       Revision:  none
 *       Compiler:  gcc
 *
 *        Company:  TaoMee, Inc. ShangHai CN
 *
 * =====================================================================================
 */
#ifndef LOGIN_IMPL_HPP
#define LOGIN_IMPL_HPP

#include <vector>

#include <main_login/cli_proto.hpp>
#include <main_login/main_login.hpp>
#include <main_login/user_manager.hpp>
#include <libtaomee++/inet/pdumanip.hpp>

extern "C" {
#include <libtaomee/tm_dirty/tm_dirty.h>
}

#include "proto.hpp"
enum {
	/* DB的返回的错误码加上此值，返回给CLIENT */
	db_base_err = 100000,
};



typedef Login<CliProto2>  MainLogin;


class UmanLogin : public MainLogin {
public:
	virtual bool init_service()
	{
	/*	if (tm_load_dirty("./data/tm_dirty.dat")) {
			ERROR_LOG("load_dirty world error");
		}*/

		m_switch_fd = FD_UNSET;
		init_timer();
		idc=config_get_intval("service_switch",0);
		return true;
	}

	virtual void fini_service() 
	{}

	/** @brief 获得从其他服务器的包体的长度
	 */
	virtual int get_other_svrs_pkg_len(int fd, const void *avail_data, int avail_len)
	{
		const svr_proto_t * pkg = reinterpret_cast<const svr_proto_t*> (avail_data);

		return pkg->len;
	}

	/** @brief 处理其他服务器断开的情况
	*/
	virtual void on_other_svrs_fd_closed(int fd)	
	{
		if ( fd == m_switch_fd) {
			KDEBUG_LOG(0, "switch serv connect closed\t [fd=%d]", m_switch_fd);
			m_switch_fd = FD_UNSET;
			send_warning(0, warning_switch, get_remote_ip(fd));
		}
	}

	/** @brief 处理client发来的其他请求包，除了用户名_密码验证
    */
	virtual int proc_other_cmds(usr_info_t *usr, uint8_t *body, uint32_t bodylen)
	{
		KDEBUG_LOG(usr->uid,"cli cmd:%u",usr->waitcmd);
		switch (usr->waitcmd) {
			case cli_proto_get_recommend_svr_list:
				return handle_get_recommend_svr_list(usr, body, bodylen);
				//case cli_proto_get_ranged_svr_list:
				//return handle_get_ranged_svr_list(usr, body, bodylen);
			case cli_proto_create_role:
				return handle_create_role(usr, body, bodylen);
			case cli_proto_check_role:
				return handle_check_role(usr, body, bodylen);
			case cli_proto_get_role_info:
				return handle_get_role_info(usr, body, bodylen);
				//case cli_check_role_in_our_db:
				//return handle_check_role_in_our_db(usr, body, bodylen);
			case cli_proto_keep_alive:
				m_clipkg->init(cli_proto_keep_alive, usr->uid, 0);
				return send_to_user(usr);
				//case cli_proto_get_version:
				//return handle_get_version(usr, body, bodylen);
			default:
				KERROR_LOG(usr->uid, "error unknown cmd %u", usr->waitcmd);
				break;
		}
		return 0;
	}
	
	/** @brief 处理dbproxy的返回包
	*/
	virtual int proc_other_dbproxy_return(usr_info_t * p, uint16_t cmdid, const uint8_t *body,
		   	uint32_t bodylen, uint32_t ret)
	{
		KDEBUG_LOG(p->waitcmd,"dbproxy cmd:0x%X ret:%u",cmdid,ret);
		//db的包需要特殊处理   包头里的area_id  role_tm
		uint32_t db_extra_len=6;
		switch (cmdid) {
			case svr_proto_ld_check_loginsession_new:
				return handle_check_loginsession_callback(p, ret);
			case svr_proto_ld_check_loginsession:
				return handle_check_loginsession_callback(p, ret);
			//case svr_proto_ld_get_user_info:
				//return handle_get_user_info_callback(p, body, bodylen, ret);
			case svr_proto_ld_create_role:
				return handle_create_role_callback(p, body+db_extra_len, bodylen-db_extra_len,  ret);
			case svr_proto_ld_get_role_info:
				return handle_get_role_info_callback(p, body+db_extra_len, bodylen-db_extra_len, ret);
			case svr_proto_ld_get_gameflag:
				return handle_get_gameflag_callback(p, body, bodylen, ret);
			default:
				KERROR_LOG(p->uid, "db return unknown cmd:%u", cmdid);
				break;
		}
		return 0;
	}

	/** @brief 处理switchSrv返回包
	*/
	virtual void proc_other_svrs_return(int fd, void *data, uint32_t pkglen)
	{
		if (fd == m_switch_fd) {
			switch_return(fd, data, pkglen);
		}
		else {
			ERROR_LOG("unknown server return pkg from fd = %d", fd);
			return;
		}
	}

	
private:
	static int send_to_switch_for_backup(void* bodybuf, int bodylen);
	void pack_svr_list(sw_get_recommend_svr_t& st);
	void pack_frd_list(usr_info_t *p);
	void pack_is_new_comer(usr_info_t *p);
	static int send_recommend_svr_list(usr_info_t *p);
	//static int send_ranged_svrlist(usr_info_t *p);
	static int get_backup_svr_list(usr_info_t* p);
	static void init_cli_proto_head(void* buf, uint32_t len, uint16_t cmd, uint32_t uid, uint32_t ret);
	static void init_serv_proto_head(void* buf, uint32_t len, uint16_t cmd, uint32_t uid, uint32_t ret);
	static int send_to_self(usr_info_t* p, const uint8_t *buf, uint32_t len);

	int handle_check_loginsession_callback(usr_info_t *p, int ret);
	//int handle_get_user_info_callback(usr_info_t *p, const uint8_t *body, uint32_t bodylen, uint32_t ret);
	int handle_get_role_info_callback(usr_info_t *p, const uint8_t *body, uint32_t bodylen, uint32_t ret);
	int handle_create_role_callback(usr_info_t *p,  uint8_t* body, uint32_t bodylen ,int ret);
	int handle_get_recommend_svr_list_callback(usr_info_t *p, uint8_t* body, uint32_t bodylen);
	//int handle_get_ranged_svr_list_callback(usr_info_t *p, uint8_t* body, uint32_t bodylen);
	int handle_get_gameflag_callback(usr_info_t *p, const uint8_t *body, uint32_t bodylen, uint32_t ret);
	//int handle_check_role_in_our_db_callback(usr_info_t *p, uint32_t ret);

	int handle_create_role(usr_info_t* p, uint8_t *bodybuf, int bodylen);
	int handle_get_recommend_svr_list(usr_info_t *p, uint8_t *body, int bodylen);
	int handle_get_role_info(usr_info_t* p, uint8_t *bodybuf, int bodylen);
	//int handle_get_ranged_svr_list(usr_info_t *p, uint8_t *bodybuf, int bodylen);
	int handle_check_role(usr_info_t* p, uint8_t *bodybuf, int bodylen);
	//int handle_check_role_in_our_db(usr_info_t* p, uint8_t *bodybuf, int bodylen); 
	int handle_get_version(usr_info_t* p, uint8_t *bodybuf, int bodylen); 

	int send_to_switch(usr_info_t *p, userid_t uid, uint16_t cmd, void* bodybuf, int bodylen, uint32_t seq = 0); 
	static	int switch_timeout(void *owner, void *data);	
	void switch_return(int fd, void *data, uint32_t pkglen);

	void init_timer();

	int pack_user_info_callback(usr_info_t *p, const uint8_t *body, uint32_t bodylen);
	static int update_svrlist_backup(void* owner, void* data);
	int update_svrlist_backup_callback(const uint8_t *body, uint32_t bodylen, uint32_t ret);
	int check_areaid_exist(uint16_t areaid);

	int send_error_to_self(usr_info_t *p, uint32_t cmd, uint32_t ret);
	int send_to_db(usr_info_t* p,uint16_t area_id, uint32_t role_tm, uint16_t cmd, const void* dbpkgbuf, uint32_t body_len);

private:
	static int m_switch_fd;
	int idc;
};


extern UmanLogin login;

#endif
