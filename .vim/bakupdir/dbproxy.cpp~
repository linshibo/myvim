/*
 * =====================================================================================
 *
 *  @file  dbproxy.cpp 
 *
 *  @brief  处理DB相关的命令 
 *
 *  compiler  gcc4.3.2 
 *	
 *  platform  Linux
 *
 * copyright:  TaoMee, Inc. ShangHai CN. All rights reserved
 *
 * =====================================================================================
 */
#include <string.h>

extern "C"{
#include <libtaomee/inet/tcp.h>
#include <libtaomee/project/utilities.h>
#include <libtaomee/conf_parser/config.h>
#include <libtaomee/log.h>
#include <libtaomee/timer.h>
#include <async_serv/dll.h>
}
#include <libtaomee++/utils/tcpip.h>
#include <libtaomee++/proto/Ccmd_map.h>
#include <libtaomee++/proto/proto_base.h>
#include <libtaomee++/proto/proto_util.h>
#include <main_login/common.hpp>

#include "player.hpp"
#include "dbproxy.hpp"
#include "common_def.hpp"
#include "global_data.hpp"
#include "../proto/ultraman_online_enum.h"

//-------------------------------------------------------
//函数定义
#undef  BIND_PROTO_CMD
#define BIND_PROTO_CMD(cmdid,proto_name,c_in,c_out,md5_tag,bind_bitmap) \
	int proto_name ## _callback( player_t *p, Cmessage* c_in, uint32_t ret);
//#include "../../proto/trunk/main_login_bind_for_check_session.h"
//#include "../../proto/trunk/main_login_bind_for_add_session.h"
#include "./proto/ultraman_db_bind_for_online.h"
#undef  BIND_PROTO_CMD

//-------------------------------------------------------------
//对应的结构体
#include "../proto/ultraman_db.h"
//-------------------------------------------------------------
//命令绑定
typedef   int(*P_DEALFUN_T)( player_t *p, Cmessage* c_in, uint32_t ret);

#undef  BIND_PROTO_CMD
#define BIND_PROTO_CMD(cmdid,proto_name,c_in,c_out,md5_tag,bind_bitmap )\
	{cmdid, new (c_out), md5_tag,bind_bitmap ,proto_name ## _callback },

Ccmd< P_DEALFUN_T> g_proxy_cmd_list[]={
//#include "./proto/main_login_bind_for_add_session.h"
//#include "./proto/main_login_bind_for_check_session.h" 
#include "./proto/ultraman_db_bind_for_online.h" 
};
 
//命令map
Ccmd_map< Ccmd< P_DEALFUN_T> >  g_proxy_cmd_map;


/** @brief 创建udp socket fd
  * @param flag	fd类型，定义了三种：客户端聊天fd、（后面两个目前还没加）
 */
int init_udp_socket(uint8_t flag)
{
	const char *port, *ip;

	if (flag == udp_socket_cli_chat) {
		port = "dbsvr_udp_chat_port";
		ip = "dbsvr_udp_chat_ip";
	//} else if (flag == cnc_udp_record_online_id){
		//port = "cnc_record_online_id_port";
		//ip = "cnc_record_online_id_ip";
	//}else if (flag == tel_udp_record_online_id)  {
		//port = "tel_record_online_id_port";
		//ip = "tel_record_online_id_ip";
	//}else if (flag == udp_submit_contribution){
		//port = "dbsvr_udp_contribution_port";
		//ip = "dbsvr_udp_contribution_ip";
	}else if (flag == udp_report_cmd) {
		ip =  "report_cmd_ip";
		port = "report_cmd_port";
	}else if (flag == udp_report_chat_content) {
		ip = "udp_report_chat_content_ip";
		port = "udp_report_chat_content_port";
	}else {
		return -1;
	}
	DEBUG_LOG("init udp %u %s %s",flag, ip, port);
	//DEBUG_LOG("xxx %s %s",ip,port);
	if (dbsvr_udp_fd[flag].get_fd() != -1) {
		dbsvr_udp_fd[flag].close_socket_udp();
	}

	dbsvr_udp_fd[flag].init(config_get_strval(ip), config_get_intval(port, 0));
	return dbsvr_udp_fd[flag].get_fd();
}

/** @brief 初始化所有udp socket fd
 */
int	init_all_udp_sockets()
{
	for (size_t i = 0; i < max_udp_socket/*sizeof(dbsvr_udp_fd)/sizeof(dbsvr_udp_fd[0])*/; ++i) {
		if (init_udp_socket(i) < 0) {
			KERROR_LOG(0, "Failed to init udp sockets: [id = %lu]", i);
			return -1;
		}
	}

	return 1;
}

/* @brief 增加TCP的ip地址和端口号到全局变量里
 */
int add_tcp_info(const char *ip_name, const char *port_name, tcp_socket_index_t index)
{
	if (index >= tcp_index_max) {
		KERROR_LOG(0, "out of max index [index = %u max_index = %u]", index, tcp_index_max);
		return -1;
	}
	struct fd_ip_port_t *info = &g_tcp_info[index];
	info->fd = -1;
	info->ip = config_get_strval(ip_name);
	info->port = config_get_intval(port_name, 0);
	if (info->ip == NULL || info->port == 0) {
		KERROR_LOG(0, "info.ip = %p info.port = %u index = %u", info->ip, info->port, index);
		return -1;
	}
	return 0;
}

/* @brief 初始化TCP的IP地址和端口号
 */
int init_tcp_socket()
{
	//if (add_tcp_info("gf_dbproxy_cnc_ip", "gf_dbproxy_cnc_port", gf_dbproxy_cnc_fd_index) != 0) {
		//return -1;
	//}
	//if (add_tcp_info("gf_dbproxy_wt_ip", "gf_dbproxy_wt_port", gf_dbproxy_wt_fd_index) != 0) {
		//return -1;
	//}
	return 0;
}

/* @brief db命令超时
 */
int db_return_expired(void* owner, void* data)
{
	player_t *p = (player_t *)owner;
	KERROR_LOG(p->uid, "DB timeout\t[wait_cmd = %u, db_cmd = %u]", p->db_timer_wait_cmd, p->db_timer_db_cmd);
	p->db_timer = NULL;
	//send_warning("db_timeout", p->uid, p->db_timer_wait_cmd, p->db_timer_db_cmd, 0);
	return 0;
}

/* @brief 向DBproxy发送UDP包
 */
int send_udp_msg_to_dbproxy(int cmd, Cmessage *msg,  userid_t user_id, uint8_t index)
{
	db_proto_head_t  pkg;
	pkg.len = sizeof(db_proto_head_t);
	pkg.seq_num = 0;
	pkg.cmd = cmd;
	pkg.ret = 0;
	pkg.user_id  = user_id;
	if (!dbsvr_udp_fd[index].send_msg(reinterpret_cast<char *>(&pkg), msg)) {
		if (init_udp_socket(index) < 0) {
			KERROR_LOG(user_id, "send udp msg failed and init udp also socket failed: [index = %u]", index);
			return -1;
		}
		//重发
		if (!dbsvr_udp_fd[index].send_msg((char *)(&pkg), msg)) {
			KERROR_LOG(user_id, "send udp msg failed: [index = %u]", index);
		}
	}

	return 0;
}

/* @brief 发送udp道具消息包给公司级服务器
 */
//int report_item_msg_to_dbproxy(uint32_t user_id, userinfo_2_update_item_info_in& db_in)
//{
	//for (size_t i = 0; i < db_in.item_add_list.size(); ++i) {
		//update_item_list_t st = db_in.item_add_list.at(i);
		//if (st.item_id == item_is_coins) {
			//send_item(user_id, 1, st.item_id, st.count);
		//}else{
			//send_item(user_id, 2, st.item_id, st.count);
		//}
	//}
	
	//for (size_t i = 0; i < db_in.item_del_list.size(); ++i) {
		//update_item_list_t st = db_in.item_del_list.at(i);
		//if (st.item_id == item_is_coins) {
			//send_item(user_id, 1, st.item_id, 0 - st.count);
		//}else{
			//send_item(user_id, 2, st.item_id, 0 - st.count);
		//}
	//}

	//return 0;
//}
//
/* @brief 向DB发送包
 * @param msg 发送DB的包体的内容，不包括包头
 */
//int send_msg_to_dbproxy(player_t *p, int cmd, Cmessage *msg,  userid_t user_id)
//{
	//if (proxy_fd == -1) {
		//proxy_fd = connect_to_service(config_get_strval("service_dbproxy"), 0, 65535, 1);
	//}
	//if (proxy_fd == -1) {
		//KERROR_LOG(user_id, "send to dbproxy failed [fd = %d] [wait_cmd = %u] [db_cmd = %X]",
		//proxy_fd, p ? p->waitcmd :0,  cmd);
		//if (p) {
			//return send_error_to_self(p, p->waitcmd, cli_connect_db_err, 1);		
		//}else{
			//player_t * usr = get_player_by_uid(user_id);
			//if (usr){
				//usr->waitcmd = 0;
				//return 0;
			//}
		//}
		//return -1;
	//}
	///*  命令是否超时 */
	//if (p) {
		//p->db_timer = ADD_TIMER_EVENT_EX(p, timer_db_return_expired, 0, get_now_tv()->tv_sec + 5);
		//p->db_timer_wait_cmd = p->waitcmd;
		//p->db_timer_db_cmd = cmd;
	//}

	//db_proto_head_t  pkg;
	//pkg.len = sizeof(db_proto_head_t);
	//pkg.seq_num = (p ? ((p->fd << 16) | p->waitcmd) : 0);
	//pkg.cmd = cmd;
	//pkg.ret = 0;
	//pkg.user_id  = user_id;

	//return net_send_msg(proxy_fd, reinterpret_cast<char *>(&pkg), msg);
//}

/* @brief 向DB发送包
 * @param msg 发送DB的包体的内容，不包括包头
 */
int send_msg_to_dbproxy(player_t *p, userid_t user_id, uint32_t role_tm, int cmd, Cmessage *msg)
{
	if (proxy_fd == -1) {
		proxy_fd = connect_to_service(config_get_strval("service_dbproxy"), 0, 65535, 1);
	}
	if (proxy_fd == -1) {
		KERROR_LOG(user_id, "send to dbproxy failed [fd = %d] [wait_cmd = %u] [db_cmd = %X]",
		proxy_fd, p ? p->waitcmd :0,  cmd);
		if (p) {
			return send_error_to_self(p, p->waitcmd, cli_connect_db_err, 1);		
		}else{
			player_t * usr = get_player_by_uid(user_id);
			if (usr){
				usr->waitcmd = 0;
				return 0;
			}
		}
		return -1;
	}
	/*  命令是否超时 */
	if (p) {
		p->db_timer = ADD_TIMER_EVENT_EX(p, timer_db_return_expired, 0, get_now_tv()->tv_sec + 5);
		p->db_timer_wait_cmd = p->waitcmd;
		p->db_timer_db_cmd = cmd;
	}

	db_proto_head_t  pkg;
	pkg.len = sizeof(db_proto_head_t);
	pkg.seq_num = (p ? ((p->fd << 16) | p->waitcmd) : 0);
	pkg.cmd = cmd;
	pkg.ret = 0;
	pkg.user_id  = user_id;
	pkg.area_id = area_id;
	pkg.role_tm = role_tm;

	return net_send_msg(proxy_fd, reinterpret_cast<char *>(&pkg), msg);
}

/* @brief 处理DB返回的包，分发到相应的处理函数中
 * @param db_pkg DB的返回包
 * @param len DB返回包的长度 
 */
void handle_db_return(db_proto_head_t *db_pkg, uint32_t len)
{
	uint32_t wait_cmd = db_pkg->seq_num & 0xFFFF;
	int conn_fd = db_pkg->seq_num >> 16;
	player_t *p = get_player_by_fd(conn_fd);

	/* 如无需等DB返回的命令处理到此结束*/
	if (!db_pkg->seq_num || !db_pkg->cmd) {
		KDEBUG_LOG(0, "DB NO WAIT RETURN [user id = %u, wait_cmd = %u db_cmd = %x ret = %u]",
		p ? p->uid : 0, p ? p->waitcmd : 0, db_pkg->cmd, db_pkg->ret);
		return;
	}

	if (p && p->db_timer) {
		REMOVE_TIMER(p->db_timer);
		p->db_timer = NULL;
	}
	if (!p || (p->waitcmd != wait_cmd)) {
		KERROR_LOG(0, "CONNECTION HAS BEEN CLOSED [P = %p] [UID = %u] [CMD = 0x%X %u] [SEQ = %X]", 
				p, db_pkg->user_id, db_pkg->cmd, wait_cmd, db_pkg->seq_num);
		return;
	}
	KDEBUG_LOG(0, "DB RETURN\t[user id = %u %u cmd = %u %#x ret =%u]",
	         p->uid, db_pkg->user_id, wait_cmd, db_pkg->cmd, db_pkg->ret);

	//----------------------------------------------------
	Ccmd< P_DEALFUN_T> * p_cmd_item =g_proxy_cmd_map.getitem( db_pkg->cmd );
	if (p_cmd_item == NULL) {
		KDEBUG_LOG(0, "db cmd id not find: %#x", db_pkg->cmd);
		return;
	}

	Cmessage * msg;

	if (db_pkg->ret == 0) {//成功
		//还原对象
		p_cmd_item->proto_pri_msg->init( );

		byte_array_t in_ba((char *)db_pkg->body, db_pkg->len - sizeof(db_proto_head_t));

		//失败
		if (!p_cmd_item->proto_pri_msg->read_from_buf(in_ba)) {
			KDEBUG_LOG(0, "db 还原对象失败");
			return;	
		}

		//客户端多上传报文
		if (!in_ba.is_end()) {
			KDEBUG_LOG(0, "db re 过多报文");
			return;
		}
		msg=p_cmd_item->proto_pri_msg;
	} else {
		msg = NULL;
		//deal_frd_no_found_err(p, db_pkg->cmd, db_pkg->user_id, db_pkg->ret);
	}
	int ret = p_cmd_item->func(p,msg, db_pkg->ret);	
	if (ret) {
		close_client_conn(p->fd);
	}
}

/* @brief 初始化DB的返回的处理函数
 */
void init_db_handle_funs()
{
  	g_proxy_cmd_map.initlist(g_proxy_cmd_list,sizeof(g_proxy_cmd_list)/sizeof(g_proxy_cmd_list[0]));
}


/* @brief 发送数据包
 */
int send_msg_by_tcp(player_t *p, tcp_socket_index_t index, const void* buf, int total)
{
	if (g_tcp_info[index].fd == -1) {
		g_tcp_info[index].fd = safe_tcp_connect(g_tcp_info[index].ip, g_tcp_info[index].port, 0, 1);
	}
	if (g_tcp_info[index].fd == -1) {
		KERROR_LOG(0, "connect tcp error [index = %u]", index);
		return -1;
	}
	return safe_tcp_send_n(g_tcp_info[index].fd, buf, total);
}

