#include <cstdio>
#include <libtaomee++/inet/pdumanip.hpp>
#include <libtaomee++/conf_parser/xmlparser.hpp>

extern "C" 
{
#include <glib.h>
#include <libtaomee/timer.h>
#include <libtaomee/utils.h>
#include <async_serv/service.h>
#include <async_serv/net_if.h>
}
#include <string>


#include "utils.hpp"
#include "battle.hpp"
#include "player.hpp"
#include "room.hpp"
#include "battle_switch.hpp"
#include "db_pet.hpp"
#include "stat.hpp"
#include "db_player.hpp"
#include "prize.hpp"
#include "db_item.hpp"

using namespace taomee;
using namespace std;

#define         max_battle_svr_num   100

typedef struct battle_server_t
{
    battle_server_t()
    {
        memset(this, 0, sizeof(battle_server_t));
    }
    char 	svr_name[16];	
    int16_t id;
}battle_server_t;

battle_server_t battle_svrs[max_battle_svr_num];

int             battle_svr_cnt = 0;

int             battle_fds[max_battle_svr_num] = {-1};

static uint8_t btlpkgbuf[btl_proto_max_len];

///////////////////////////////////////////////////////////////////////////////////
bool is_alloc_player_cmd(uint32_t cmd)
{
    return ( (cmd >= online_proto_create_btl_cmd) && (cmd <= online_proto_syn_player_info_cmd));	
}


battle_grp_t* alloc_battle_grp()
{
    return reinterpret_cast<battle_grp_t*>(g_slice_alloc0( sizeof(battle_grp_t)));	
}


void free_battle_grp(battle_grp_t* grp)
{
    g_slice_free1(sizeof(battle_grp_t), grp);
}


void init_btl_proto_head(const player_t* p, userid_t id, void* header, int len, uint32_t cmd)
{
    btl_proto_t* pkg = reinterpret_cast<btl_proto_t*>(header);

    pkg->len = len;
    pkg->seq = ((p && p->battle_grp) ? p->battle_grp->id : 0);
    pkg->cmd = cmd;
    pkg->ret = 0;
    pkg->id  = id;
}

int send_to_battle_svr(player_t* p, const void* btlpkgbuf, uint32_t len, int index)
{
	//const btl_proto_t* pkg = reinterpret_cast<const btl_proto_t*>(btlpkgbuf);
    if(!(index >=0 && index < max_battle_svr_num))
    {
        ERROR_TLOG("invalid battle fd index = %d", index);
        goto ERROR;
    }
    if(len > btl_proto_max_len)
    {
        ERROR_TLOG("invalid btlpkgbuf len = %u", len);
        goto ERROR;
    }
    if((battle_fds[index] == -1)) 
    {
        battle_fds[index] = connect_to_service(battle_svrs[index].svr_name, battle_svrs[index].id, 65535, 1);
    }
    if(battle_fds[index] == -1)
    {
        ERROR_TLOG("connect_to_service failed: index = %d", index);
        goto ERROR;
    }
	
	//KDEBUG_LOG(p->id, "---------->>>>>SEND 2 BTL\t[cmd %u]", pkg->cmd);
    return net_send_ex(battle_fds[index],  btlpkgbuf, len);

ERROR:
    free_battle_grp(p->battle_grp);
    p->battle_grp = NULL;
    return 0;
}

int send_to_battle_svr(player_t* p, Cmessage *p_out, uint16_t cmd, int index)
{
	if(!(index >=0 && index < max_battle_svr_num)) {
        ERROR_TLOG("invalid battle fd index = %d", index);
        goto ERROR;
    }
    if((battle_fds[index] == -1)) {
        battle_fds[index] = connect_to_service(battle_svrs[index].svr_name, battle_svrs[index].id, 65535, 1);
    }
    if(battle_fds[index] == -1) {
        ERROR_TLOG("connect_to_service failed: index = %d", index);
        goto ERROR;
    }

	btl_proto_t head;
	head.len = sizeof(btl_proto_t);
    head.seq = ((p && p->battle_grp) ? p->battle_grp->id : 0);
    head.cmd = cmd;
    head.ret = 0;
    head.id  = p->id;
	
    return net_send_msg(battle_fds[index], (char *)&head, p_out);

ERROR:
	if (p && p->battle_grp) {
    	free_battle_grp(p->battle_grp);
    	p->battle_grp = NULL;
	}
    return 0;
}

int get_btlsvr_fd_idx(int fd) 
{
    for (int i = 0; i < battle_svr_cnt; ++i) {   
        if (fd == battle_fds[i]) {   
            return i;
        }   
    }   
    return -1; 
}

void clear_players_battle(void* key, void* player, void* userdata)
{
    struct clear_players_battle_in_t {
        int btl_fd;	
    };

    clear_players_battle_in_t* p_btlinfo = reinterpret_cast<clear_players_battle_in_t*>(userdata);
    player_t* p = reinterpret_cast<player_t*>(player);
    if (p->battle_grp){
        if (p->battle_grp->fd_idx < max_battle_svr_num) {
            if (battle_fds[p->battle_grp->fd_idx] == p_btlinfo->btl_fd) {
				/* 
				 *  这里打个error_log，记录当玩家处于战斗状态时，可能会存储的waitcmd，用作分析
				 *  正常情况：此时玩家的waitcmd == 0，因为战斗状态时，online基本都是转发
				 *			  cli的包至btl，会在第一时间清掉waitcmd。
				 */
				if (p->waitcmd != 0) {
					ERROR_TLOG("btlsvr crashed! user %u is processing waitcmd %u", p->id, p->waitcmd);
					p->clear_waitcmd();
				}
                free_battle_grp(p->battle_grp);
                p->battle_grp = NULL;
            }
        }
    }
}

void do_while_battle_svr_crashed(int btl_fd)
{
    g_hash_table_foreach(all_players, clear_players_battle, &btl_fd);	
}

bool init_battle_server_config(const char* xml)
{
    battle_svr_cnt = 0;
    memset(battle_svrs, 0, sizeof(battle_svrs));

    if(xml == NULL){
        return false;	
    }
    char err_msg[4096] = {0};
    xmlDocPtr 	doc = NULL;
    xmlNodePtr 	root = NULL;
    xmlNodePtr  server_node = NULL;

    doc = xmlParseFile(xml);
    if(doc == NULL) {
        sprintf(err_msg, "xml file %s is not exist", xml);
        throw XmlParseError(err_msg);
        return false;
    }

    root = xmlDocGetRootElement(doc);
    if(root == NULL) {
        xmlFreeDoc(doc);
        sprintf(err_msg, "xml file %s content is empty", xml);
        throw XmlParseError(err_msg);
        return false;
    }

    server_node = root->xmlChildrenNode;
    while(server_node) {
        if( xmlStrcmp(server_node->name, reinterpret_cast<const xmlChar*>("Server")) == 0) {
            if(battle_svr_cnt >= max_battle_svr_num) {
                xmlFreeDoc(doc);
                sprintf(err_msg, "too many battle servers: cnt= %u", battle_svr_cnt);
                throw XmlParseError(err_msg);
                return false;
            }
            string svr_name;
            get_xml_prop(svr_name, server_node, "SvrName");
            if(svr_name.length() >= 16) {
                xmlFreeDoc(doc);
                sprintf(err_msg, "invalid server name: %s idx = %d", svr_name.c_str(), battle_svr_cnt);	
                throw XmlParseError(err_msg);
                return false;
            }
            int16_t   svr_id = 0;
            get_xml_prop(svr_id, server_node, "SvrId");
            if(svr_id == 0) {
                xmlFreeDoc(doc);
                sprintf(err_msg, "invalid svr_id: %d idx = %d", svr_id, battle_svr_cnt);
                throw XmlParseError(err_msg);
                return false;
            }
            strncpy(battle_svrs[battle_svr_cnt].svr_name, svr_name.c_str(), sizeof(battle_svrs[battle_svr_cnt].svr_name));
            battle_svrs[battle_svr_cnt].id = svr_id;
            battle_svr_cnt++;
        }
        server_node = server_node->next;
    }
    xmlCleanupParser();
    xmlFreeDoc(doc);
    return true;	
}

bool final_battle_server_config()
{
    battle_svr_cnt = 0;
    memset(battle_svrs, 0, sizeof(battle_svrs));
    return true;	
}


void handle_battle_svr_return(btl_proto_t* data, uint32_t len, int bs_fd)
{
    player_t* p = get_player(data->id);

    if( !(data->cmd > btl_cmd_start && data->cmd < btl_cmd_max)){
        ERROR_TLOG("invalid btl_cmd userid = %u, cmd = %u, seq = %u, ret = %u",
                data->id, data->cmd, data->seq, data->ret);	
        return;
    }	
    if(p == NULL){
        ERROR_TLOG("can not find player in btl handle return userid = %u, cmd = %u, seq = %u, ret = %u",
                data->id, data->cmd, data->seq, data->ret);			
        return;
    }
    if(p->battle_grp == NULL){
        ERROR_TLOG("btl ended in  btl handle return userid = %u, cmd = %u, seq = %u, ret = %u",
                data->id, data->cmd, data->seq, data->ret);
        return;
    }

    if (p->battle_grp->fd_idx >= max_battle_svr_num) {
        ERROR_TLOG("btl ended in  btl handle return userid = %u, cmd = %u, seq = %u, ret = %u",
                data->id, data->cmd, data->seq, data->ret);
        return;
    }

    if(battle_fds[p->battle_grp->fd_idx] != bs_fd){
        ERROR_TLOG("invalid btl svr fd in  btl handle return userid = %u, cmd = %u, seq = %u, ret = %u",
                data->id, data->cmd, data->seq, data->ret);	
        return;	
    }
    if(p->battle_grp->id != data->seq &&  !is_alloc_player_cmd(data->cmd) ){
        ERROR_TLOG("invalid data seq in  btl handle return userid = %u, cmd = %u, seq = %u, ret = %u",
                data->id, data->cmd, data->seq, data->ret);	
        return;
    }
    if(data->ret) {
        send_error_to_player(p, data->ret);	
        return;
    }

    int cmd = data->cmd;
    const bind_proto_cmd_t *p_cmd = find_battle_cmd_bind(data->cmd);
    if (!p_cmd) {
        ERROR_TLOG("battle_svr_ret_inv_cmd, cmd=%u, u=%u", cmd, p->id);
        return;
    }
    uint32_t body_len = data->len - sizeof(btl_proto_t);
    bool unpack_ret = p_cmd->p_out->read_from_buf_ex((char*)data + sizeof(btl_proto_t), body_len);
    if (!unpack_ret) {
        ERROR_TLOG("inv_pkglen, cmd=%u, read_len=%u", data->cmd, data->len);
        return; 
    }

    int err_code = p_cmd->func(p, p_cmd->p_out, NULL, NULL);
    if (err_code) {
        ERROR_TLOG("close_player_fd: u=%u, fd=%d", p->id, p->fd);
        close_client_conn(p->fd);
    }
}

bool init_player_btl_grp(player_t* p)
{
    battle_grp_t* grp = p->battle_grp;
    if(grp == NULL) {
        p->battle_grp = alloc_battle_grp();
        p->battle_grp->fd_idx = p->id % battle_svr_cnt;
        return true;
    }
    return false;
}

bool final_player_btl_grp(player_t* p)
{
    battle_grp_t* grp = p->battle_grp;
    if(grp) {
        free_battle_grp(grp);
        grp = NULL;
        return true;
    }
    return false;	
}

int btlsvr_init_battle(player_t* p, uint32_t stage, uint32_t player_count,
		uint8_t room_type, uint8_t room_mode, uint32_t cmd)
{
    int idx = sizeof(btl_proto_t);
    pack_h(btlpkgbuf, get_server_id(), idx);
    pack_h(btlpkgbuf, stage, idx);
    pack_h(btlpkgbuf, player_count, idx);
    pack_h(btlpkgbuf, p->id, idx);
    pack_h(btlpkgbuf, room_type, idx);
    init_btl_proto_head(p, p->id, btlpkgbuf, idx, cmd);
    return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}

//============================================================
// implement funcstions 
//============================================================
void end_battle_with_task_relate_stuff(player_t *p, online_proto_battle_end_out *rsp)
{
	/* TODO(zog->singku): 先hardcode发内测版, singku 你回来后改成从配置读的tskid 和 step */
	if (is_player_win_the_battle(rsp->player_win_flag)) {
		/* int task_setbuff_noack(player_t *p, uint32_t tskid, uint32_t step, uint32_t setter, uint32_t count); */
        if (p->room.type == room_type_pvp)  {
            //1表示打了一次 false表示更新buff不等DB返回
            update_task_by_pvp(p, p->room.red_player_count, 1, false);
        } else {
            update_task_by_pve(p, p->room.map_id, p->room.map_lv, 1, false);
        }
	}
}

void end_battle_room_transcript_stuff(player_t *p, online_proto_battle_end_out *rsp)
{
	if (p->room.type != room_type_pve) {
		TRACE_TLOG("not_pve_in_transcript, u=%u", p->id);
		return ;
	}
	if (!is_player_win_the_battle(rsp->player_win_flag)) {
		TRACE_TLOG("not_win_pve_in_transcript, u=%u", p->id);
		return ;
	}

	uint32_t map_mark = get_map_mark(p->room.map_id);
	TRACE_TLOG("fin_transcript, u=%u, role_tm=%d, map_mark=%u, mapid=%u, maplv=%u",
			p->id, p->role_tm, map_mark, p->room.map_id, p->room.map_lv);
	transcript_map_iter_t iter = p->transcript_map->find(map_mark);
	if (iter == p->transcript_map->end()) {
		/* 从没打过这个map_mark, 需要记录 */
		p->transcript_map->insert(make_pair(map_mark, p->room.map_lv));
		db_record_transcript_info_noack(p, map_mark, p->room.map_lv);
		TRACE_TLOG("add_trans_info, u=%u, role_tm=%d, "
				"map_mark=%u, mapid=%u, maplv=%hhu",
				p->id, p->role_tm, map_mark, p->room.map_id, p->room.map_lv);
	} else {
		if (iter->second + 1 == p->room.map_lv) {
			iter->second = p->room.map_lv;
			db_record_transcript_info_noack(p, map_mark, p->room.map_lv);
			TRACE_TLOG("update_trans_info, u=%u, role_tm=%d, "
					"map_mark=%u, mapid=%u, maplv=%hhu",
					p->id, p->role_tm, map_mark, p->room.map_id, p->room.map_lv);
		}
	}
}

void destory_battle_for_room_stuff(player_t *p)
{
	p->room.blue_player_count = 0;
	p->room.red_player_count = 0;
	p->room.btl_team_id = 0;
	send_to_btlsw_forme(p, btlsw_pvp_destory_battle_cmd, 0, 0); // 不等返回
}

void end_battle_for_room_stuff(player_t *p, online_proto_battle_end_out *rsp)
{
	/* 同步更新房间的相关数据 */
	btlsw_pvp_end_battle_in out, *p_out = &out;
	p_out->player_level = p->get_player_attr_value(OBJ_ATTR_LEVEL);
	send_to_btlsw_forme(p, btlsw_pvp_end_battle_cmd, p_out, 0); // 不等返回

	/* 地图副本信息 */
	end_battle_room_transcript_stuff(p, rsp);
}

int battle_end_add_player_rewards(player_t *p, std::vector<parse_item> &reward_items)
{
	return add_player_rewards(p, reward_items, true);
}

int add_player_rewards(player_t *p, std::vector<parse_item> &reward_items, bool need_ack)
{
	for (uint32_t i = 0; i < reward_items.size(); i++) {
		uint32_t item_id = reward_items[i].item_id;
		uint32_t count = reward_items[i].item_count;
		DEBUG_TLOG("add_battle_end_rewards after battle user_id:%u item_id:%u count:%u", 
						p->id, item_id , count);
	}

	std::vector<db_add_item_request_t> item;
	int ret = prepare_item_for_db(p, reward_items, item);
	if (ret != 0) {
		ERROR_TLOG("user %u add_battle_end_rewards prepare_add_item failed", p->id);
		return -1;
	}

	return db_add_item(p, item, need_ack);
}



//============================================================
// battle server callbacks
//============================================================

int online_proto_create_btl_callback(DEFAULT_ARG)
{
    online_proto_create_btl_out *p_in = P_IN;
    p->battle_grp->id = p_in->battle_id;
    return pvp_room_tell_players_start_battle(p, p->battle_grp->id, p->battle_grp->fd_idx);
}

int online_proto_transmit_only_callback(DEFAULT_ARG)
{
    online_proto_transmit_only_out *p_in = P_IN;

	cli_proto_t* proto = reinterpret_cast<cli_proto_t*>(p_in->trans_data);
	uint16_t cmd = proto->cmd;
	cmd = taomee::bswap(cmd);//解出转输的命令号
	if (cmd != cli_proto_chat_public_msg_cmd)
		return send_to_player(p, (char*)p_in->trans_data, p_in->_trans_data_len, DONT_CLEAR_WAITCMD);

	uint32_t sender_id;
	uint32_t sender_role_tm;
	int idx = 0;
	//如果是传递聊天消息
	unpack(p_in->trans_data + sizeof(cli_proto_t), sender_id, idx);//解出发送者ID
	unpack(p_in->trans_data + sizeof(cli_proto_t), sender_role_tm, idx);
	uint64_t key = gen_key_by_uid_role(sender_id, sender_role_tm);
    player_t *p_src = get_player(sender_id);
    if (p_src == p) {//发送者是自己
        return send_to_player(p, (char*)p_in->trans_data, p_in->_trans_data_len, DO_CLEAR_WAITCMD);
    }
	if (p->blacklist->find(key) != p->blacklist->end()) {
		//如果发送者在我的黑名单中，则我不接收
		return 0;
	}
	return send_to_player(p, (char*)p_in->trans_data, p_in->_trans_data_len, DONT_CLEAR_WAITCMD);
}

/* 注意: 这个函数里的函数不能用等ack模式的接口, 否则会打断 end_battle 的过程 
 * 另外此函数只是做战斗结束后相关结算的处理，只是战斗服务器实例并未销毁，
 * 等待玩家后续操作 如翻牌 结束后 战斗服会发battle_destroy 命令，那时再销毁*/
int online_proto_battle_end_callback(DEFAULT_ARG)
{
    online_proto_battle_end_out *p_in = P_IN;

	uint32_t cur_tm = get_now_tv()->tv_sec;
    std::vector<parse_item> items; //记录rewards
    items.clear();
    if(!p->battle_grp || p->battle_grp->id != p_in->battle_id) {
        //NOTI(SINGKU->viclan)不需要send_error_to_player????
		ERROR_TLOG("user %u has not been in battle(id=%u)", p->id, p_in->battle_id);
        return 0;
    }

    for (uint32_t i = 0; i < p_in->statistic_infos.size(); ++i) {
        if (p_in->statistic_infos[i].uid != p->id) {
            continue;
        }

        btl_player_statistical_info_t *info = &(p_in->statistic_infos[i]);
        p->update_buff(cur_tm);
        if (p->check_buff(ITEM_BUFF_EXP)) {
            change_player_and_pets_exp_level(p,2*(info->exp + info->extern_exp), false); // no_ack
        } else {
            change_player_and_pets_exp_level(p, info->exp + info->extern_exp, false); // no_ack
        }
        
        for (uint32_t j = 0; j < info->rewards.size(); ++j) {
            /* 把rewards信息填入items */
            parse_item add_item;
            add_item.item_id = info->rewards[j].item_id;
            add_item.item_count = info->rewards[j].item_count;
            if (fill_item_period(add_item) == false) continue;
            items.push_back(add_item);
        }
    }

    /* 对战结束时任务相关的逻辑 (eg: 修改某相关任务的步骤...) */
    end_battle_with_task_relate_stuff(p, p_in);

    /* 结束战斗时同步信息 */
    end_battle_for_room_stuff(p, p_in);

    add_player_btl_result_times(p, p_in->player_win_flag);

    send_to_player(p, p_in, cli_proto_battle_end_cmd, DONT_CLEAR_WAITCMD);

    /* 在最后处理rewards,no_ack */
    if (items.size() > 0) {
        int ret = battle_end_add_player_rewards(p, items);
        if (ret != 0) {
            ERROR_TLOG("user %u add_rewards failed", p->id);
        }
    }
    return 0;
}	

/* 销毁战斗 */
int online_proto_battle_destroy_callback(DEFAULT_ARG)
{
    online_proto_battle_destroy_out *p_in = P_IN;
    if(p->battle_grp && p->battle_grp->id == p_in->btl_id) {
		/* 到房间销毁对战相关数据 */
		destory_battle_for_room_stuff(p);
        free_battle_grp(p->battle_grp);
        p->battle_grp = NULL;
        return send_to_player(p, p_in, cli_proto_battle_destroy_cmd, DONT_CLEAR_WAITCMD);
    }
    return 0;
}	

/*NOTI(viclan) : 翻盘的时候，除了自己知道翻出的是什么，其他玩家也要知道
*				   所以在btl那边会根据card_id找到对应的item_id，numbers对
*				   所有战斗玩家进行广播，走btlsvr_transmit_only_callback;
*
*				   然后对应翻牌玩家user_id，单发一条btlsvr_player_turn_card
*				   这里用callback进行处理，对该玩家翻出的奖励进行添加*/
int online_proto_player_turn_card_callback(DEFAULT_ARG)
{
    online_proto_player_turn_card_out *p_in = P_IN;
	uint32_t cur_tm = get_now_tv()->tv_sec;
	/* 添加翻牌奖励，如果是金币,item_id=10040 */
	if (p_in->item_id == GOLD){
		p->update_buff(cur_tm);
		if (p->check_buff(ITEM_BUFF_GOLD)) {
			return db_change_gold(p, 2*p_in->item_num, false);
		} else {
			return db_change_gold(p, p_in->item_num, false);
		}
	} else {/* 如果非金币 */
		std::vector<db_add_item_request_t> item;
		if (item_data_mgr::get_instance()->is_item_data_exist(p_in->item_id) == false) {
			ERROR_TLOG("btlsvr return user %u turn card info: item_id invalid[%u]", 
							p->id, p_in->item_id);
			return 0;
		}
		int ret = prepare_item_for_db(p, p_in->item_id, p_in->item_num, item);
		if (ret != 0) {
			ERROR_TLOG("user %u turn card-> prepare_add_item failed", p->id);
			return 0;
		}
		return db_add_item(p, item, true);
	}
}


//================================
/*online to battle server functions*/
//==================================
int btlsvr_syn_player_info(player_t* p,
		uint32_t btl_id, uint32_t fd_idx, uint32_t btl_team_id)
{
	/* 有没有 fight_pet 在 btlsw 处理 room_start 的时候检查 */
	assert(p->fight_pet);

    p->battle_grp = alloc_battle_grp();
    p->battle_grp->id = btl_id;
    p->battle_grp->fd_idx = fd_idx;

    int idx = sizeof(btl_proto_t);
    pack_h(btlpkgbuf, get_server_id(), idx);
    pack_h(btlpkgbuf, btl_id, idx);
    pack_h(btlpkgbuf, p->id, idx);
    pack(btlpkgbuf, p->nick, sizeof(p->nick), idx);
	pack_h(btlpkgbuf, btl_team_id, idx);
    pack_h(btlpkgbuf, p->get_player_attr_value(OBJ_ATTR_EXP), idx);
    pack_h(btlpkgbuf, p->get_player_attr_value(OBJ_ATTR_LEVEL), idx);
    pack_h(btlpkgbuf, p->get_merge_attr_value(OBJ_ATTR_HP), idx);
    pack_h(btlpkgbuf, p->get_merge_attr_value(OBJ_ATTR_ATK), idx);
    pack_h(btlpkgbuf, p->get_merge_attr_value(OBJ_ATTR_CRIT), idx);
    pack_h(btlpkgbuf, p->eye_model, idx);
    pack_h(btlpkgbuf, p->resource_id, idx);
	
	btl_pet_info_t pet_info;
	p->fight_pet->export_info(&pet_info);
    byte_array_t ba;
    pet_info.write_to_buf_ex(ba);
    pack(btlpkgbuf, ba.get_buf(), ba.get_postion(), idx);

	uint32_t skill_count = 5;

	pack_h(btlpkgbuf, skill_count, idx);

	pack_h(btlpkgbuf, p->fight_pet->m_skill.m_skill_1, idx);
	pack_h(btlpkgbuf, (uint32_t)1, idx);

	pack_h(btlpkgbuf, p->fight_pet->m_skill.m_skill_2, idx);
	pack_h(btlpkgbuf, (uint32_t)1, idx);

	pack_h(btlpkgbuf, p->fight_pet->m_skill.m_skill_3, idx);
	pack_h(btlpkgbuf, (uint32_t)1, idx);
	
    pack_h(btlpkgbuf, p->fight_pet->m_skill.m_skill_4, idx);
	pack_h(btlpkgbuf, (uint32_t)1, idx);

	pack_h(btlpkgbuf, p->fight_pet->m_skill.m_uni_skill, idx);
	pack_h(btlpkgbuf, (uint32_t)1, idx);

	DEBUG_TLOG("sys play 2 btl: %u %u %u %u %u", p->id, p->fight_pet->m_skill.m_skill_1, 
		p->fight_pet->m_skill.m_skill_2, p->fight_pet->m_skill.m_skill_3,
		p->fight_pet->m_skill.m_uni_skill);
	idx += p->pack_player_equip_h(btlpkgbuf + idx);

    init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_syn_player_info_cmd);
    return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}

int btlsvr_load_resource(player_t* p)
{
    int idx = sizeof(btl_proto_t);
    pack_h(btlpkgbuf, p->battle_grp->id, idx);
    init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_load_resource_cmd);
    return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}

int btlsvr_get_btl_user_list(player_t* p)
{
    int idx = sizeof(btl_proto_t);	
    pack_h(btlpkgbuf, p->battle_grp->id, idx);
    init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_get_btl_user_list_cmd);
    return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}

int btlsvr_player_move(player_t* p, uint32_t x, uint32_t y, uint32_t dir)
{
    int idx = sizeof(btl_proto_t);
    pack_h(btlpkgbuf, x, idx);
    pack_h(btlpkgbuf, y, idx);
    pack_h(btlpkgbuf, dir, idx);

    init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_player_move_cmd);
    return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}

int btlsvr_player_stop(player_t* p, uint32_t x, uint32_t y, uint32_t dir)
{
    int idx = sizeof(btl_proto_t);
    pack_h(btlpkgbuf, x, idx);
    pack_h(btlpkgbuf, y, idx);
    pack_h(btlpkgbuf, dir, idx);

    init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_player_stop_cmd);
    return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}


int btlsvr_player_attack(player_t* p, uint32_t gun_angle, uint32_t muzzle_velocity)
{
    int idx = sizeof(btl_proto_t);	

    pack_h(btlpkgbuf, gun_angle, idx);
    pack_h(btlpkgbuf, muzzle_velocity, idx);

    init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_player_attack_cmd);
    return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}

int btlsvr_player_ready_attack(player_t* p)
{
    int idx = sizeof(btl_proto_t);
    init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_player_ready_attack_cmd);
    return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}


int btlsvr_player_cancel_battle(player_t* p)
{
    int idx = sizeof(btl_proto_t);

    init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_player_cancel_battle_cmd);
    return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}

int btlsvr_player_progress_bar(player_t* p,  uint32_t progress)
{
    int idx = sizeof(btl_proto_t);

    pack_h(btlpkgbuf, p->id, idx);
    pack_h(btlpkgbuf, progress, idx);

    init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_progress_bar_cmd);
    return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}

int btlsvr_player_cancel_turn(player_t* p)
{
	int idx = sizeof(btl_proto_t);
	
	init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_player_cancel_turn_cmd);
	return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}

int btlsvr_player_finish_turn(player_t* p, uint32_t seqno)
{
	int idx = sizeof(btl_proto_t);

    pack_h(btlpkgbuf, seqno, idx);
	init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_player_finish_turn_cmd);
	return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}

int btlsvr_select_skill(player_t* p, uint32_t skill_id, uint32_t skill_lv)
{
	int idx = sizeof(btl_proto_t);

	pack_h(btlpkgbuf, skill_id, idx);
	pack_h(btlpkgbuf, skill_lv, idx);

	init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_select_skill_cmd);
	return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);	
}

int btlsvr_get_player_skill_list(player_t* p)
{
	int idx = sizeof(btl_proto_t);	
	
	init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_get_btl_user_list_cmd);
	return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}


int btlsvr_player_turn_card(player_t* p, uint32_t user_id, uint32_t card_loc)
{
	int idx = sizeof(btl_proto_t);

	pack_h(btlpkgbuf, user_id, idx);
	pack_h(btlpkgbuf, card_loc, idx);


	init_btl_proto_head(p, p->id, btlpkgbuf, idx, online_proto_player_turn_card_cmd);
	return send_to_battle_svr(p, btlpkgbuf, idx, p->battle_grp->fd_idx);
}
