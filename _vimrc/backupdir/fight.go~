package gameserver

import (
	"encoding/json"
	//"sanguo/base/log"
	//"github.com/garyburd/redigo/redis"
	//"sanguo/base/packet"
	. "sanguo/base/util"
	"sanguo/config"
	"sanguo/db"
	. "sanguo/systemdata"
	//"strconv"
)

const (
	StrongIsReward = 1
	WeakIsReward   = 2
)

type HeroRecv struct {
	Id          int
	Damage      int
	DamageRatio int
}

type ArmRecv struct {
	Id          int
	Damage      int
	Hp          int
	DamageRatio int
}

type DanboEnemy struct {
	Seq []int
	Id  int
}

type FightDataVerify struct {
	Heros             []int
	Arms              []int
	Point             int
	Enemy_num         int
	Random_heros      []HeroRecv
	Random_arms       []ArmRecv
	Score             int
	Random_enemy_arms []ArmRecv
	Danbo             []DanboEnemy
	Login_arm         int
	CoinsGot          int
	FinishedQuest     int
	Wizards           []int
}

func UserStartFight(sess *Session, reader []byte) bool {
	start_flag := sess.user.VerifyWealth(RewardType_Power, Power_Fight)
	if !start_flag {
		sess.Debug("Failed VerifyPower", sess.user.power)
		return false
	}

	left_time, err := sess.user.GetLeftTimeToAddPower()
	if err != nil {
		sess.Error("In start fight", err, sess.user.uid)
		return false
	}

	back := make(map[string]interface{})
	if start_flag {
		// can fight
		back["ret"] = true
	} else {
		// can't fight
		back["ret"] = false
	}
	back["power"] = sess.user.power
	back["left_time"] = left_time

	return sess.SendReplyBack(back, 5)
}

//opcode6
func UserEndFight(sess *Session, reader []byte) bool {
	sess.user.Debug("Daxiang   Start")
	defer sess.user.Debug("Daxiang   End")
	
	type Data struct {
		Ret       bool
		Guanqiaid int
		Fight     FightDataVerify
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}
	//sess.Debug("A data from client", msg, sess.user.uid)

	back := make(map[string]interface{})
	back["ret"] = msg.Ret

	/************************** PowerReduce ******************************/

	if msg.Ret || (sess.user.chapter != 1) {
		//sess.user.Trace("HZZZ", "WillCostWealth", sess.user.power)
		if err = sess.user.CostWealth(RewardType_Power, Power_Fight); err != nil {
			sess.user.Error("Failed CostWealth", err)
			return false
		}
		//sess.user.Trace("HZZZ", "After CostWealth The power is", sess.user.power)
	}
	left_time, err := sess.user.GetLeftTimeToAddPower()
	if err != nil {
		sess.Error("In start fight", err)
		return false
	}
	//sess.user.Trace("HZZZ", "After GetLeftTimeToAddPower the power is", sess.user.power)
	if msg.Ret {

		err = sess.user.quest.InspectQuest(QuestType_WinFight, 1, 0)
		sess.user.Trace("Will InspectQuest QuestType_WinFight")
		if err != nil {
			sess.user.Error("Failed QuestType_GetSpecGold", err)
			return false
		}

		////////////////  Win the fight  ////////////////////
		if len(msg.Fight.Wizards) == 0 {
			//veri_flag := VerifyFightData(sess, msg.Guanqiaid, &msg.Fight, NormalGuanqia)
			veri_flag := sess.user.VerifyFightData(msg.Guanqiaid, &msg.Fight, NormalGuanqia)
			if !veri_flag {
				sess.Error("Failed VerifyFightData", sess.user.uid)
				back["ret"] = false
				return sess.SendReplyBack(back, 6)
			}
		}
		//guanqia := msg.Guanqiaid
		score_reward, err := GetScoreReward(sess, msg.Guanqiaid, msg.Fight.Score)
		if err != nil {
			sess.Error("Failed get score reward", err)
			return false
		}
		if score_reward != nil {
			back["score_reward"] = score_reward
		}

		if msg.Fight.FinishedQuest != 0 {
			//quest_reward, err := GetFightQuestReward(sess, msg.Fight.FinishedQuest)
			if sess.user.GetSimpleGuanScore(msg.Guanqiaid) > GuanqiaQuestScore {
				sess.user.Error("The guanqia quest is done before")
				return false
			}

			quest_reward, err := sess.user.quest.GetFightQuestReward(msg.Fight.FinishedQuest)
			if err != nil {
				sess.Error("Failed get quest reward", err)
				return false
			}

			/*err = sess.user.quest.DelFightQuest(msg.Fight.FinishedQuest)
			if err != nil {
				sess.Error("Failed DelFightQuest", err)
				return false
			}*/
			err = sess.user.quest.FinishGuanqiaQuest(msg.Fight.FinishedQuest)
			if err != nil {
				sess.Error("Failed FinishGuanqiaQuest", err)
				return false
			}

			back["quest_reward"] = quest_reward
			back["FQuest"] = msg.Fight.FinishedQuest

			err = sess.user.SetSimpleGuanScore(msg.Guanqiaid, msg.Fight.Score+GuanqiaQuestScore)
			if err != nil {
				sess.user.Error("Failed SetSimpleGuanScore", err)
				return false
			}
		}

		err = ProcessWizards(sess, &msg.Fight)
		if err != nil {
			sess.Error("Failed ProcessWizards", err, sess.user.uid)
			return false
		}

		if msg.Guanqiaid == sess.user.s_guanqia {
			sess.Debug("Win the latest s_guanqia", sess.user.uid)

			GM.GMTongguan(sess.user.uid, sess.user.s_guanqia)

			// win the latest s_guanqia
			tg_reward, err := UnlockNextGuanqia(sess)
			if err != nil {
				sess.Error("Failed UnlockNextGuanqia", err, sess.user.uid)
				return false
			}
			if tg_reward != nil {
				back["tg_reward"] = tg_reward
			}
		}

		if IsTrueHeroGuanqia(msg.Guanqiaid) {
			back["rank"], err = sess.user.GetTrueHeroRank(msg.Guanqiaid)
			if err != nil {
				sess.user.Error("Failed GetTrueHeroRank", err)
				return false
			}
			back["top10"], err = sess.GetTopTenOfTrueHero(msg.Guanqiaid)
			if err != nil {
				sess.user.Error("Failed GetTopTenOfTrueHero", err)
				return false
			}
		}
	}

	back["power"] = sess.user.power
	back["left_time"] = left_time
	back["wizards"] = sess.user.wizards

	/****************************** Login_arm Info ********************************************************/
	err = DelLoginArm(sess)
	if err != nil {
		sess.Error("Failed DelLoginArm", err, sess.user.uid)
		return false
	}
	back["login_arm"] = msg.Fight.Login_arm

	////////////////////////  CoinsGot in fight //////////////////////////
	if msg.Fight.CoinsGot > 0 {
		_, err = sess.user.ProcessReward(RewardType_Gold, msg.Fight.CoinsGot)
		if err != nil {
			sess.Error("Failed AddGold", err, sess.user.uid)
			return false
		}
	}
	/****************************** Finsh Process and send msg ****************************************/

	back["gold"] = sess.user.gold

	sess.user.Debug("Daxiang   WillSendBack")

	if !sess.SendReplyBack(back, 6) {
		sess.Error("Send opcode6 error")
		return false
	}
sess.user.Debug("Daxiang   Strange")
	/****************************** Random Stranger **********************************************/
	if sess.user.wizards[4] == 1 {
		if sess.user.Friends.FriendNum() < 15 {
			if sess.user.stranger_time < 3 {
				sess.user.Trace("The stranger_time is", sess.user.stranger_time)
				if IsProbabilityHappen(500) {
					type Stranger struct {
						Name  string
						Photo string
					}
					var s Stranger
					s.Name, s.Photo, err = GetRandomStrangerAfterFight(sess)
					if err != nil {
						sess.Error("Failed GetRandomStrangerAfterFight", err)
						return false
					}

					sess.user.Trace("The stranger is", s.Name, s.Photo)

					if s.Name != "" {
						if s.Photo != "" {
							if !sess.user.Friends.IsFriendByName(s.Name) {
								err = sess.AddStrangerTime()
								if err != nil {
									sess.Error("Failed AddStrangerTime", err)
									return false
								}
								sess.user.Trace("The stranger_time after is", sess.user.stranger_time)

								sess.SendReplyBack(s, 7)
							}
						}
					}

				}
			}
		}
	}

	/****************************** Quest type 1,2,3,5,12 ****************************************/
sess.user.Debug("Daxiang   QuestStart")
	err = sess.user.quest.InspectQuest(QuestType_FinishSimpleGuanqia, 0, 0)
	if err != nil {
		sess.Error("Failed QuestType_FinishSimpleGuanqia ", err)
		return false
	}

	err = sess.user.quest.InspectQuest(QuestType_FinishChapterGuanqia, 0, 0)
	if err != nil {
		sess.Error("Failed QuestType_FinishChapterGuanqia", err)
		return false
	}

	err = sess.user.quest.InspectQuest(QuestType_FinishChapter, 0, 0)
	if err != nil {
		sess.Error("Failed QuestType_FinishChapter", err)
		return false
	}

	err = sess.user.quest.InspectQuest(QuestType_FinishSimpleGuanqiaMoreTime, msg.Guanqiaid, 0)
	if err != nil {
		sess.Error("Failed QuestType_FinishSimpleGuanqiaMoreTime", err)
		return false
	}

	err = sess.user.quest.InspectQuest(QuestType_GetSpecScore, msg.Guanqiaid, msg.Fight.Score)
	if err != nil {
		sess.Error("Failed QuestType_GetSpecScore", err)
		return false
	}

	/*err = sess.user.quest.InspectQuest(QuestType_WinFight, 0, 0)
	if err != nil {
		sess.Error("Failed QuestType_WinFight", err)
		return false
	}*/
sess.user.Debug("Daxiang   QuestEnd")
	return true
}

func UnlockNextGuanqia(sess *Session) (tg_reward []TG_Reward, err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	simple_guanqia := sess.user.s_guanqia

	if simple_guanqia == 9 {
		if !UserOpenBossFight(sess, nil) {
			sess.Error("Failed open BossGuanQiaInfo", sess.user.GetUidUsedInDB())
			return
		}
	}

	// win the latest s_guanqia
	for index, simple_guan := range ChapterGuanQiaInfo[sess.user.c_guanqia].Allsimpleguanqias {
		if simple_guan != simple_guanqia {
			continue
		}
		if index < (len(ChapterGuanQiaInfo[sess.user.c_guanqia].Allsimpleguanqias) - 1) {
			//Unlock next s_guanqia
			sess.user.s_guanqia = ChapterGuanQiaInfo[sess.user.c_guanqia].Allsimpleguanqias[index+1]
			break
		}
		if index == (len(ChapterGuanQiaInfo[sess.user.c_guanqia].Allsimpleguanqias) - 1) {
			// Judge unlock next chapter
			//GM
			if config.Config.GMState {
				//	WinSimpleGuanqia(sess, sess.user.c_guanqia)
			}

			for i, chapter_guan := range ChapterInfo[sess.user.chapter].AllCGuanQias {
				if sess.user.c_guanqia != chapter_guan {
					continue
				}
				if i < (len(ChapterInfo[sess.user.chapter].AllCGuanQias) - 1) {
					//Unlock next c_guanqia and s_guanqia
					_, err = dbconn.Do("ZADD", sess.user.GetUidUsedInDB()+":completed_c_guanqia", sess.user.chapter, sess.user.chapter<<8+sess.user.c_guanqia)
					if err != nil {
						sess.Error("Cant add new unlock c_guaniqa into completed_c_guanqia", err, sess.user.uid)
						return
					}
					sess.user.c_guanqia = ChapterInfo[sess.user.chapter].AllCGuanQias[i+1]
					sess.user.s_guanqia = ChapterGuanQiaInfo[sess.user.c_guanqia].Allsimpleguanqias[0]
					//sess.user.completed_c_guanqia = append(sess.user.completed_c_guanqia, sess.user.c_guanqia<<8+sess.user.c_guanqia)

					break
				}
				if i == (len(ChapterInfo[sess.user.chapter].AllCGuanQias) - 1) {
					//GM
					if config.Config.GMState {
						//	WinChapter(sess, sess.user.chapter)
					}

					err = ProcessFinishedChapter(sess)
					if err != nil {
						sess.Error("Failed ProcessFinishedChapter", err)
						return
					}
					//Unlock next chapter and c_guanqia and s_guanqia
					if sess.user.chapter < config.Config.FinalChapter {
						sess.Debug("Now is time unlock next chapter, and new chapter is", sess.user.chapter, sess.user.GetUidUsedInDB())

						sess.user.quest.ChangeChapter()

						//TODO   fix a bug of final chapter reward
						/*****************************************tongguanReward****************************************/
						tg_reward, err = GetTongguanReward(sess)
						if err != nil {
							sess.Error("Failed get tongguan reward", err)
							return
						}
						/*****************************************finish tonggguan reward ******************************/
						//for i, _ := range sess.user.completed_c_guanqia {
						//	sess.user.completed_c_guanqia[i] = 0
						//}
						if sess.user.chapter < config.Config.FinalChapter {
							sess.user.chapter++
							/************************** Unlock chapter 2 will open BossGuanQiaInfo *********************/
							sess.Debug("After win, the new chapter is ", sess.user.chapter, sess.user.GetUidUsedInDB())

							sess.user.c_guanqia = ChapterInfo[sess.user.chapter].AllCGuanQias[0]
							sess.user.s_guanqia = ChapterGuanQiaInfo[sess.user.c_guanqia].Allsimpleguanqias[0]
							break
						}
					} else {
						//sess.user.c_guanqia = 0
						//sess.user.s_guanqia = 0
						break
					}
				}
				// Cant find infomation about c_guanqia
				sess.Error("Cant find infomation about c_guanqia", sess.user.GetUidUsedInDB())
				return
			}
			break
		}
		sess.Error("Cant find infomation about s_guanqia", sess.user.GetUidUsedInDB())
		return
	}

	_, err = dbconn.Do("HMSET", sess.user.GetUidUsedInDB(), "chapter", sess.user.chapter, "c_guanqia", sess.user.c_guanqia, "s_guanqia", sess.user.s_guanqia)
	if err != nil {
		sess.Error("Cant update chapter and c_guanqia and s_guanqia in redis", err, sess.user.GetUidUsedInDB())
		return
	}
	return
}

func UserGetScoreOfSimpleGuanqia(sess *Session, reader []byte) bool {
	type Data struct {
		S int
	}

	var msg Data

	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message, err = %v", err, sess.user.uid)
		return false
	}

	score := sess.user.GetSimpleGuanScore(msg.S)

	back := make(map[string]interface{})

	back["score"] = score

	back_json, err := json.Marshal(back)
	if err != nil {
		sess.Error("Can't decode json message in UserStartFight, err = %v", err, sess.user.uid)
		return false
	}
	sess.Debug("The back json message is", string(back_json), sess.user.uid)
	return sess.SendReplyBack(back, 20)
}

func (this *User) VerifyFightData(gid int, msg *FightDataVerify, t int) bool {
	if !config.Config.FightVerify {
		return true
	}

	if msg.Login_arm != 0 {
		if msg.Login_arm != this.login_arm {
			this.Error("The login_arm is not match", msg.Login_arm, this.last_login_arm)
			//return false    TODO need fix
		}
	}

	for _, hero_id_level := range msg.Heros {
		if !this.Hero.Verify(hero_id_level) {
			this.Error("Failed verify hero info")
			return false
		}
	}

	for _, arm_id_level := range msg.Arms {
		if !this.Arm.Verify(arm_id_level) {
			this.Error("Failed verify arm info")
			return false
		}
	}

	for _, hero := range msg.Random_heros {
		if hero.Damage != HeroInfo[hero.Id].Damage {
			this.Debug("the damage of hero is not match with database of user:")
			return false
		}
		if hero.DamageRatio != int(HeroInfo[hero.Id].DamageRatio*100) {
			this.Debug("the damageRatio of hero is not match with database of user:")
			return false
		}
	}

	for _, arm := range msg.Random_arms {
		if arm.Damage != ArmInfo[arm.Id].Damage {
			this.Info("the damage of arm is not match with database of user:", arm.Id, arm.Damage, ArmInfo[arm.Id].Damage)
			return false

		}
		if arm.Hp != ArmInfo[arm.Id].Hp {
			this.Info("the hp of arm is not match with database", arm.Id)
			return false

		}
		if arm.DamageRatio != int(ArmInfo[arm.Id].DamageRatio*100) {
			this.Info("the damageRatio of arm is not match with database of user:recv and server", arm.Id, arm.DamageRatio, ArmInfo[arm.Id].DamageRatio)
			return false

		}
	}

	var enemynum int
	enemyseq := make(map[int][]int)
	for _, danboId := range GetAllDanboIds(gid, t) {
		enemynum += DanboInfo[danboId].AllUnitCount
		enemyseq[danboId] = DanboInfo[danboId].AllUnitSeq
	}
	enemynum_recv := msg.Enemy_num

	if enemynum != enemynum_recv {
		this.Info("The enemy num is not match")
		return false
	}

	for _, danbo := range msg.Danbo {
		danbo_seq := enemyseq[danbo.Id]
		if len(danbo_seq) != len(danbo.Seq) {
			this.Error("The sequence num is not match.", "recieved:", len(danbo.Seq), "server:", len(danbo_seq))
			return false
		}
		for i := 0; i < len(danbo_seq); i++ {
			if danbo.Seq[i] != danbo_seq[i] {
				this.Error("The sequence content is not match")
				return false
			}
		}
	}

	for _, enemy := range msg.Random_enemy_arms {
		if enemy.Damage != EnemyUnit[enemy.Id].Damage {
			this.Error("the damage of enemy is not match with database of user:", enemy.Id, enemy.Damage, EnemyUnit[enemy.Id].Damage)
			return false
		}

		if enemy.Hp != EnemyUnit[enemy.Id].Hp {
			this.Error("the hp of enemy is not match with database of user:", enemy.Id, enemy.Hp, EnemyUnit[enemy.Id].Hp)
			return false
		}
	}
	return true
}

func VerifyFightData(sess *Session, gid int, msg *FightDataVerify, t int) bool {
	/*************************Verify login_arm id***********************/
	if msg.Login_arm != 0 {
		if msg.Login_arm != sess.user.login_arm {
			sess.Error("The login_arm is not match", msg.Login_arm, sess.user.last_login_arm, sess.user.uid)
			//return false    TODO need fix
		}
	}
	/*************************Verify hero id*************************************************/
	heros_msg := msg.Heros
	for _, hero_id_level := range heros_msg {
		if !sess.user.Hero.Verify(hero_id_level) {
			sess.user.Error("Failed verify hero info")
			return false
		}
	}

	sess.Debug("The recieved hero is ok", sess.user.uid)
	arms_msg := msg.Arms

	for _, arm_id_level := range arms_msg {
		if !sess.user.Arm.Verify(arm_id_level) {
			sess.user.Error("Failed verify arm info")
		}
	}

	sess.Debug("The recieved arm is ok", sess.user.uid)

	heros_random := msg.Random_heros

	for _, hero := range heros_random {
		if hero.Damage != HeroInfo[hero.Id].Damage {
			sess.Debug("the damage of hero is not match with database of user:", sess.user.uid)
			return false

		}
		if hero.DamageRatio != int(HeroInfo[hero.Id].DamageRatio*100) {
			sess.Debug("the damageRatio of hero is not match with database of user:", sess.user.uid)
			return false

		}
	}

	sess.Debug("The recieved rand heros is ok", sess.user.uid)

	arms_random := msg.Random_arms
	sess.Debug("The recieved random_arms is", arms_random, sess.user.uid)

	for _, arm := range arms_random {
		if arm.Damage != ArmInfo[arm.Id].Damage {
			sess.Info("the damage of arm is not match with database of user:", arm.Id, arm.Damage, ArmInfo[arm.Id].Damage)
			return false

		}
		if arm.Hp != ArmInfo[arm.Id].Hp {
			sess.Info("the hp of arm is not match with database", arm.Id)
			return false

		}
		if arm.DamageRatio != int(ArmInfo[arm.Id].DamageRatio*100) {
			sess.Info("the damageRatio of arm is not match with database of user:recv and server", arm.Id, arm.DamageRatio, ArmInfo[arm.Id].DamageRatio)
			return false

		}
	}

	sess.Debug("The recieved random arm is ok", sess.user.uid)

	// verify the enemy number and sequence

	var enemynum int
	enemyseq := make(map[int][]int)
	for _, danboId := range GetAllDanboIds(gid, t) {
		enemynum += DanboInfo[danboId].AllUnitCount

		enemyseq[danboId] = DanboInfo[danboId].AllUnitSeq
	}
	enemynum_recv := msg.Enemy_num

	if enemynum != enemynum_recv {
		sess.Info("The enemy num is not match", sess.user.uid)
		return false
	}

	danbos := msg.Danbo
	sess.Debug("The recieved danbo is", danbos, sess.user.uid)

	for _, danbo := range danbos {
		danbo_seq := enemyseq[danbo.Id]
		if len(danbo_seq) != len(danbo.Seq) {
			sess.Info("The sequence num is not match.", "recieved:", len(danbo.Seq), "server:", len(danbo_seq), sess.user.uid)
			return false
		}
		for i := 0; i < len(danbo_seq); i++ {
			if danbo.Seq[i] != danbo_seq[i] {
				sess.Info("The sequence content is not match", sess.user.uid)
				return false
			}
		}

	}

	sess.Debug("The enemy number and sequence is ok", sess.user.uid)

	type enemy_rand struct {
		id     int
		damage int
		hp     int
	}

	enemys_random := msg.Random_enemy_arms
	sess.Debug("The recieve random_enemy_arms is", enemys_random, sess.user.uid)

	for _, enemy := range enemys_random {

		if enemy.Damage != EnemyUnit[enemy.Id].Damage {
			sess.Info("the damage of enemy is not match with database of user:", enemy.Id, enemy.Damage, EnemyUnit[enemy.Id].Damage)
			return false

		}

		if enemy.Hp != EnemyUnit[enemy.Id].Hp {
			sess.Info("the hp of enemy is not match with database of user:", enemy.Id, enemy.Hp, EnemyUnit[enemy.Id].Hp)
			return false

		}
	}

	return true
}

func GetAllDanboIds(id int, t int) []int {
	return GuanqiaInfo[id].AllDanboIds
}

func ProcessFinishedChapter(sess *Session) error {
	for _, c_guanqia := range ChapterInfo[sess.user.chapter].AllCGuanQias {
		for _, s_guanqia := range ChapterGuanQiaInfo[c_guanqia].Allsimpleguanqias {
			for _, reward := range GuanqiaInfo[s_guanqia].ScoreReward {
				if reward.RewardType == RewardType_Arm {
					if reward.Prob != 0 {
						//TODO
						err := sess.user.Arm.AddArmOidToUnseen(ArmInfo[reward.Value].OriginalId)
						if err != nil {
							return err
						}
					}
				}

			}
		}
	}
	return nil
}

//TODO very important
//opcode7
func GetRandomStrangerAfterFight(sess *Session) (name string, photo string, err error) {
	user := PlayerManager.GetRandPlayer()
	if user != nil && user != sess.user {
		sess.Debug("GetRandOnlinePlayer ", user.name)
		return user.name, user.photo, nil
	}
	return "", "", nil
}

func UserGetTrueHeroRank(sess *Session, reader []byte) bool {

	type Data struct {
		Sid int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}

	if !IsTrueHeroGuanqia(msg.Sid) {
		sess.user.Error("The sid is not true hero")
		return false
	}

	type DataBack struct {
		Sid   int
		Score int
		Rank  int
		Top10 []RankPlayer
	}

	var back DataBack

	back.Sid = msg.Sid
	back.Rank, err = sess.user.GetTrueHeroRank(msg.Sid)
	if err != nil {
		sess.user.Error("Failed GetTrueHeroRank", err)
		return false
	}

	back.Score = sess.user.GetSimpleGuanScore(msg.Sid)
	back.Top10, err = sess.GetTopTenOfTrueHero(msg.Sid)
	if err != nil {
		sess.user.Error("Failed GetTopTenOfTrueHero", err)
		return false
	}

	return sess.SendReplyBack(back, 54)
}
