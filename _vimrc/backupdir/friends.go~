package gameserver

import (
	"encoding/json"
	"github.com/garyburd/redigo/redis"
	"sanguo/base/log"
	//"sanguo/base/packet"
	//. "sanguo/base/util"
	"sanguo/db"
	. "sanguo/systemdata"
	"strconv"
	"time"
)

const (
	NonExistId    = 1
	NotEnoughRoom = 2
	AlreadyFriend = 3
	IPCSendError  = 4

	ApplyFriendMsg = 1
)

type ApplyMsg struct {
	Name  string
	Photo string
	Sid   int
	Time  int64
	Uid   int
}

type AcceptMsg struct {
	Name  string
	Photo string
	Time  int64
	Uid   int
}

type FriendInfo struct {
	uid           int
	name          string
	photo         string
	borrow_flag   int
	send_flag     int
	friend_degree int
}

type FriendManger struct {
	Friends  map[int]FriendInfo //uid is the key
	MaxCount int
	user     *User
	//uid                string
	friend_reward_time int
	un_recv_reward     int
}

func NewFriendManger() *FriendManger {
	var f FriendManger
	f.Friends = make(map[int]FriendInfo)
	f.MaxCount = 15
	//f.uid = uid

	return &f
}

func (this *FriendManger) SetUser(u *User) {
	this.user = u
}

func (this *FriendManger) InitFriend() (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	_, err = dbconn.Do("SET", this.user.GetUidUsedInDB()+":friend_reward_time", 0)
	if err != nil {
		return err
	}

	_, err = dbconn.Do("SET", this.user.GetUidUsedInDB()+":friend_un_recv_rd", 0)
	if err != nil {
		return err
	}

	return nil
}

func (this *FriendManger) InitFriendFirstLogin() (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	for _, v := range this.Friends {
		if v.borrow_flag != 0 {
			v.borrow_flag = 0
			_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":friend:"+strconv.Itoa(v.uid), "borrow", 0)
			if err != nil {
				return err
			}
		}

		if v.send_flag != 0 {
			v.send_flag = 0
			_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":friend:"+strconv.Itoa(v.uid), "send", 0)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (this *FriendManger) LoadFriends() (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	reply, err := redis.Strings(dbconn.Do("SMEMBERS", this.user.GetUidUsedInDB()+":friends"))
	if err != nil {
		return err
	}

	var tmp FriendInfo
	for i := 0; i < len(reply); i++ {
		uid, _ := strconv.Atoi(reply[i])

		r, err := redis.Values(dbconn.Do("HMGET", this.user.GetUidUsedInDB()+":friend:"+GetUidUseInDB(uid), "name", "send", "borrow", "friend_degree", "photo"))
		if err != nil {
			return err
		}

		tmp.uid = uid

		tmp.name, err = redis.String(r[0], nil)
		if err != nil {
			return err
		}

		tmp.send_flag, err = redis.Int(r[1], nil)
		if err != nil {
			return err
		}

		tmp.borrow_flag, err = redis.Int(r[2], nil)
		if err != nil {
			return err
		}

		tmp.friend_degree, err = redis.Int(r[3], nil)
		if err != nil {
			return err
		}

		tmp.photo, err = redis.String(r[4], nil)
		if err != nil {
			return err
		}

		this.Friends[uid] = tmp
	}

	this.friend_reward_time, err = redis.Int(dbconn.Do("GET", this.user.GetUidUsedInDB()+":friend_reward_time"))
	if err != nil {
		this.user.Error("Failed GET friend_reward_time", err)
		//return err
	}

	this.un_recv_reward, err = redis.Int(dbconn.Do("GET", this.user.GetUidUsedInDB()+":friend_un_recv_rd"))
	if err != nil {
		this.user.Error("Failed GET friend_un_recv_rd", err)
		//return err
	}

	return nil
}

func (this *FriendManger) FriendNum() int {
	return len(this.Friends)
}

type BackFriendInfo struct {
	Name  string
	Photo string
	//Sid    int
	Uid    int
	Borrow int
	Send   int
	Degree int
}

func (this *FriendManger) GetFriendList() []BackFriendInfo {
	this.user.Trace("The friendlist is", this.Friends)

	length := len(this.Friends)
	if length == 0 {
		return nil
	}

	back := make([]BackFriendInfo, len(this.Friends))
	index := 0
	for _, v := range this.Friends {
		back[index].Uid = v.uid
		back[index].Name = v.name
		back[index].Photo = v.photo
		back[index].Borrow = v.borrow_flag
		back[index].Send = v.send_flag
		back[index].Degree = v.friend_degree
		index++
	}
	return back
}
func (this *FriendManger) SendMsgToFriend(uid int, msg string) (err error) {
	IPCSendByUid(this.user.uid, uid, 0, 66, msg)
	return nil
}

func (this *FriendManger) CanBorrowArmFromFriend(uid int) (flag bool) {
	var max int
	if this.Friends[uid].friend_degree < 0 {
		max = 0
	} else if this.Friends[uid].friend_degree < 2 {
		max = 1
	} else if this.Friends[uid].friend_degree < 4 {
		max = 2
	} else {
		max = 3
	}
	if this.Friends[uid].borrow_flag < max {
		return true
	} else {
		return false
	}
}

func (this *FriendManger) CanSendArmToFriend(uid int) (flag bool) {
	if this.Friends[uid].send_flag == 0 {
		return true
	} else {
		return false
	}
}

func (this *FriendManger) BorrowHeroFromFriend(sess *Session, uid int) (err error) {
	//tmp := this.Friends[uid]
	//tmp.borrow_flag++
	//this.Friends[uid] = tmp

	v := GetRandomHeroByUID(this.user.uid, uid)

	type DataBack struct {
		Heroid int
		Level  int
		Flag   int
		FUID   int
	}

	var back DataBack
	back.Heroid = v.ID
	back.Level = v.Level
	back.Flag = v.Flag

	back.FUID = uid

	sess.SendReplyBack(back, 110)

	err = this.addBorrowCount(uid)
	if err != nil {
		log.Error("Failed addBorrowCount", err)
		return err
	}
	return nil
}

func (this *FriendManger) addBorrowCount(uid int) (err error) {
	tmp := this.Friends[uid]
	tmp.borrow_flag++
	this.Friends[uid] = tmp

	dbconn := db.Pool.Get()
	defer dbconn.Close()
	_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":friend:"+GetUidUseInDB(uid), "borrow", tmp.borrow_flag)
	if err != nil {
		log.Error("Failed HSET", this.user.GetUidUsedInDB()+":friend:"+GetUidUseInDB(uid), err)
		return err
	}
	return nil
}

/*func (this *FriendManger) BorrowArmFromFriend(sess *Session, uid int) (err error) {
	tmp := this.Friends[uid]
	tmp.borrow_flag++
	this.Friends[uid] = tmp

	dbconn := db.Pool.Get()
	defer dbconn.Close()
	_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":friend:"+GetUidUseInDB(uid), "borrow", tmp.borrow_flag)
	if err != nil {
		log.Error("Failed HSET", this.user.GetUidUsedInDB()+":friend:"+GetUidUseInDB(uid), err)
		return err
	}

	reply, err := redis.Values(dbconn.Do("LRANGE", GetUidUseInDB(uid)+":formation", 0, -1))
	if err != nil {
		log.Error("Failed LRANGE", GetUidUseInDB(uid)+":formation", err)
		return err
	}

	type RandomArms struct {
		Arms  [20]int
		Count int
	}
	var r1 RandomArms
	var r2 RandomArms
	var r3 RandomArms

	for i := 0; i < len(reply); i++ {
		aid, err := redis.Int(reply[i], nil)
		if err != nil {
			return err
		}
		if aid == 0 {
			continue
		}

		if ArmInfo[aid].StarsNeed == 1 {
			r1.Arms[r1.Count] = aid
			r1.Count++
			continue
		}

		if ArmInfo[aid].StarsNeed == 2 {
			r2.Arms[r2.Count] = aid
			r2.Count++
			continue
		}

		if ArmInfo[aid].StarsNeed == 3 {
			r3.Arms[r3.Count] = aid
			r3.Count++
			continue
		}
	}

	var id int
	for {
		if r3.Count != 0 {
			index := GetRandomNum(r3.Count)
			id = r3.Arms[index]
			break
		}

		if r2.Count != 0 {
			index := GetRandomNum(r2.Count)
			id = r2.Arms[index]
			break
		}

		if r1.Count != 0 {
			index := GetRandomNum(r1.Count)
			id = r1.Arms[index]
			break
		}
	}

	if id == 0 {
		return nil
	}

	//TODO
	level, err := redis.Int(dbconn.Do("HGET", GetUidUseInDB(uid)+":arm:"+strconv.Itoa(id), "level"))
	if err != nil {
		log.Error("Failed HGETf", GetUidUseInDB(uid)+":arm:"+strconv.Itoa(id), err)
		return err
	}

	name, err := redis.String(dbconn.Do("HGET", GetUidUseInDB(uid), "name"))
	if err != nil {
		log.Error("Failed HGETff", uid, err)
		return err
	}

	type DataBack struct {
		Armid int
		Level int
		Fname string
		//Degree int
	}

	var back DataBack
	back.Armid = id
	back.Level = level
	back.Fname = name
	//back.Degree = this.Friends[uid].friend_degree

	sess.SendReplyBack(back, 110)

	return nil
	//return this.SendMsgToFriend(uid, msg)
}*/

func (this *FriendManger) SendArmToFriend(fid int, msg string, armid int, level int) (err error) {
	tmp := this.Friends[fid]
	tmp.send_flag = 1
	tmp.friend_degree += 2
	this.Friends[fid] = tmp

	dbconn := db.Pool.Get()
	defer dbconn.Close()
	_, err = dbconn.Do("HMSET", this.user.GetUidUsedInDB()+":friend:"+GetUidUseInDB(fid), "send", 1, "friend_degree", tmp.friend_degree)
	if err != nil {
		return err
	}

	//_, err = dbconn.Do("HSET", uid + ":friend:"+ this.user.uid, "friend_degree", tmp.friend_degree)
	//if err != nil {
	//	return err
	//}

	type ipc struct {
		Armid  int
		Level  int
		Degree int
		Fuid   int
	}
	var ipcmsg ipc
	ipcmsg.Armid = armid
	ipcmsg.Level = level
	// Fuid mean friend of other hand, which is this.user.uid
	ipcmsg.Fuid = this.user.uid
	ipcmsg.Degree = tmp.friend_degree

	if !IPCSendByUid(this.user.uid, fid, 0, 112, ipcmsg) {

	}

	return nil

	//return this.SendMsgToFriend(name, msg)
}

func (this *FriendManger) IsFriendByUid(uid int) (flag bool) {
	_, flag = this.Friends[uid]
	return
}

func (this *FriendManger) IsFriendByName(name string) (flag bool) {
	flag = false
	for _, v := range this.Friends {
		if v.name == name {
			flag = true
			break
		}
	}
	return
}

func (this *FriendManger) MassSend(msg string) (err error) {
	for name, _ := range this.Friends {
		err = this.SendMsgToFriend(name, msg)
		if err != nil {
			log.Error("Failed SendMsgToFriend", err)
		}
	}
	return nil
}

func (this *FriendManger) AddFriend(uid int, name string, photo string) (err error) {
	if uid == 0 {
		log.Critical("Uid is 0", name, photo)
	}

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	var tmp FriendInfo
	tmp.uid = uid
	tmp.name = name
	tmp.photo = photo

	this.Friends[uid] = tmp
	_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":friends", uid)
	if err != nil {
		this.user.Error("Failed SADD", err)
		return err
	}

	_, err = dbconn.Do("HMSET", this.user.GetUidUsedInDB()+":friend:"+GetUidUseInDB(uid), "name", name, "uid", uid, "borrow", 0, "send", 0, "friend_degree", 0, "photo", photo)
	if err != nil {
		this.user.Error("Failed HMSET", err)
		return err
	}

	err = this.user.quest.InspectQuest(QuestType_FriendNum, 1, 0)
	if err != nil {
		this.user.Error("Failed QuestType_FriendNum", err)
		return err
	}

	return nil
}

func (this *FriendManger) DelFriend(uid int) (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	_, err = dbconn.Do("SREM", this.user.GetUidUsedInDB()+":friends", uid)
	if err != nil {
		return err
	}

	_, err = dbconn.Do("DEL", this.user.GetUidUsedInDB()+":friend:"+GetUidUseInDB(uid))
	if err != nil {
		return err
	}

	delete(this.Friends, uid)
	return nil
}

func (this *FriendManger) IsFriendsFull() (flag bool) {
	return len(this.Friends) >= this.MaxCount
}

/*func (this *FriendManger) CanReward() bool {
	return this.gold_reward_time <= 10
}*/

//Add to unrecv reward
func (this *FriendManger) GetAddFriendReward(sess *Session) (err error) {
	if this.friend_reward_time >= 10 {
		return nil
	}

	this.un_recv_reward++
	this.friend_reward_time++
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	_, err = dbconn.Do("INCR", this.user.GetUidUsedInDB()+":friend_reward_time")
	if err != nil {
		return err
	}

	_, err = dbconn.Do("INCR", this.user.GetUidUsedInDB()+":friend_un_recv_rd")
	if err != nil {
		return err
	}

	type DataBack struct {
		RewardType  int
		RewardValue int
	}
	var back DataBack
	back.RewardType = RewardType_Gold
	back.RewardValue = 500

	if !sess.SendReplyBack(back, 68) {
		return SendError
	}
	return nil
}

/*func (this *FriendManger)CanGetUnRecvReward() (flag bool) {
	return this.un_recv_reward > 0
}*/

func (this *FriendManger) GetUnRecvRewardCount() int {
	return this.un_recv_reward
}

func (this *FriendManger) GetUnRecvReward(sess *Session) (err error) {
	if this.un_recv_reward <= 0 {
		return nil
	}

	_, err = sess.user.ProcessReward(RewardType_Gold, 500)
	if err != nil {
		sess.Error("Failed AddGold", err)
		return err
	}

	this.un_recv_reward--
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	_, err = dbconn.Do("DECR", sess.user.GetUidUsedInDB()+":friend_un_recv_rd")
	if err != nil {
		sess.Error("Failed DECR friend_un_recv_rd", err)
		return err
	}

	return nil
}

//opcode60
func UserApplyFriend(sess *Session, reader []byte) bool {
	type Data struct {
		Name string
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err)
		return false
	}

	back := make(map[string]interface{})
	back["Name"] = msg.Name

	flag := sess.user.Friends.IsFriendByName(msg.Name)
	if flag {
		back["Ret"] = AlreadyFriend
		return sess.SendReplyBack(back, 60)
	}

	if msg.Name == sess.user.name {
		sess.Error("You cant add yourself as friend", err)
		return false
	}

	flag = sess.user.Friends.IsFriendsFull()
	if flag {
		sess.Error("Not enough room for more friend")
		return false
	}

	flag, err = IsNameExist(msg.Name)
	if err != nil {
		sess.Error("Failed IsNameExist", err)
		return false
	}

	if !flag {
		back["Ret"] = NonExistId
		return sess.SendReplyBack(back, 60)
	}

	var data ApplyMsg
	data.Sid = sess.user.s_guanqia
	data.Name = sess.user.name
	data.Photo = sess.user.photo
	data.Time = time.Now().Unix()
	data.Uid = sess.user.uid

	dest_id, err := GetUidByName(msg.Name)
	if err != nil {
		log.Error("Failed get id through name", err)
		return false
	}

	if IPCSendByUid(sess.user.uid, dest_id, 0, 62, data) {
		back["Ret"] = 0
	} else {
		back["Ret"] = IPCSendError
	}

	return sess.SendReplyBack(back, 60)
}

//opcode62
func UserAcceptOtherAsYourFriend(sess *Session, reader []byte) bool {
	//sess.Debug("The data recv is ", string(reader.Data[:]))

	type Data struct {
		Ret   bool
		Uid   int
		Name  string
		Photo string
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err)
		return false
	}

	if !msg.Ret {
		return true
	}

	if msg.Uid == 0 || msg.Name == "" || msg.Photo == "" {
		sess.user.Error("Failed accept", msg)
		return false
	}

	err = sess.user.Friends.AddFriend(msg.Uid, msg.Name, msg.Photo)
	if err != nil {
		sess.Error("Failed AddFriend", err)
		return false
	}

	var data AcceptMsg
	data.Name = sess.user.name
	data.Photo = sess.user.photo
	data.Time = time.Now().Unix()
	data.Uid = sess.user.uid

	return IPCSendByUid(sess.user.uid, msg.Uid, 0, 61, data)
}

//opcode 63
func UserDelFriend(sess *Session, reader []byte) bool {

	type Data struct {
		Uid int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}

	if !sess.user.Friends.IsFriendByUid(msg.Uid) {
		return true
	}

	err = sess.user.Friends.DelFriend(msg.Uid)
	if err != nil {
		sess.Error("Failed DelFriend", err)
		return false
	}

	type DataBack struct {
		Name string
		Time int64
		Uid  int
	}

	var msgback DataBack
	msgback.Name = sess.user.name
	msgback.Uid = sess.user.uid
	msgback.Time = time.Now().Unix()

	sess.user.Error("Will IPCSendByUid")

	return IPCSendByUid(sess.user.uid, msg.Uid, 0, 64, msgback)
}

//opcode65
func UserSendMsgToFriend(sess *Session, reader []byte) bool {

	type Data struct {
		Content string
		Uid     int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}

	flag := sess.user.Friends.IsFriendByUid(msg.Uid)
	if !flag {
		sess.Error(msg.Uid, "is not your friend, you cant msg him")
		return false
	}

	type DataBack struct {
		Content string
		Photo   string
		Name    string
		Time    int64
		Uid     int
	}

	var msgback DataBack
	msgback.Content = msg.Content
	msgback.Name = sess.user.name
	msgback.Photo = sess.user.photo
	msgback.Time = time.Now().Unix()
	msgback.Uid = sess.user.uid

	return IPCSendByUid(sess.user.uid, msg.Uid, 1, 66, msgback)
}

//opcode67
func UserGetFriendList(sess *Session, reader []byte) bool {
	back := make(map[string]interface{})

	var err error
	err = sess.user.Friends.LoadFriends()
	if err != nil {
		sess.Error("Failed LoadFriends", err)
	}

	/*length := sess.user.Friends.FriendNum()
	Names := make([]friendInfo, length)

	i := 0
	for _, v := range sess.user.Friends.Friends {
		Names[i].Name = v.name
		Names[i].Send = v.send_flag
		Names[i].Borrow = v.borrow_flag
		Names[i].Uid = v.uid
		Names[i].Degree = v.friend_degree
		Names[i].Photo = v.photo
		if err != nil {
			sess.Error("Failed GetUserPhotoByName", err)
			return false
		}
		//Names[i].Sid, err = GetUserSidByName(v.name)
		//if err != nil {
		//	sess.Error("Failed GetUserSidByName", err)
		//	return false
		//}
		i++
	}*/
	back["Name"] = sess.user.Friends.GetFriendList()

	return sess.SendReplyBack(back, 67)
}

//opcode75  show off
func UserShowOff(sess *Session, reader []byte) bool {
	//sess.Debug("The data recv of UserShowOff is ", string(reader.Data[:]))

	type Data struct {
		Content string
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message, err = %v", err)
		return false
	}

	type DataBack struct {
		Content string
		Photo   string
		Name    string
		Time    int64
		Uid     int
	}

	var msgback DataBack
	msgback.Content = msg.Content
	msgback.Name = sess.user.name
	msgback.Photo = sess.user.photo
	msgback.Time = time.Now().Unix()
	msgback.Uid = sess.user.uid

	for _, v := range sess.user.Friends.Friends {
		IPCSendByUid(sess.user.uid, v.uid, 1, 66, msgback)
	}
	return true
}

//opcode110    PlayerBorrowArm
func UserBorrowArm(sess *Session, reader []byte) bool {
	//sess.Debug("The data recv of UserBorrowArm is ", string(reader.Data[:]))

	type Data struct {
		Uid int
		Msg string
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message, err = %v", err)
		return false
	}

	if !sess.user.Friends.CanBorrowArmFromFriend(msg.Uid) {
		sess.Error("Borrowed Up to limit")
		return false
	}

	err = sess.user.Friends.BorrowHeroFromFriend(sess, msg.Uid)
	if err != nil {
		sess.Error("Failed BorrowArmFromFriend", err)
		return false
	}

	type DataBack struct {
		Content string
		Photo   string
		Name    string
		Uid     int
		Time    int64
	}

	var msgback DataBack
	msgback.Content = msg.Msg
	msgback.Name = sess.user.name
	msgback.Uid = sess.user.uid
	msgback.Photo = sess.user.photo
	msgback.Time = time.Now().Unix()

	return IPCSendByUid(sess.user.uid, msg.Uid, 1, 66, msgback)
}

//op111
func UserSendArm(sess *Session, reader []byte) bool {
	//sess.Debug("The data recv of UserSendArm is ", string(reader.Data[:]))

	type Data struct {
		Uid   int
		Msg   string
		Armid int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message, err = %v", err)
		return false
	}

	if !sess.user.Friends.CanSendArmToFriend(msg.Uid) {
		sess.Error("Already send")
		return false
	}

	level := sess.user.Arm.GetArmLevel(msg.Armid)
	sess.user.Friends.SendArmToFriend(msg.Uid, msg.Msg, msg.Armid, level)

	type DataBack struct {
		Content string
		Photo   string
		Name    string
		Uid     int
		Time    int64
	}
	var msgback DataBack
	msgback.Content = msg.Msg
	msgback.Name = sess.user.name
	msgback.Uid = sess.user.uid
	msgback.Photo = sess.user.photo
	msgback.Time = time.Now().Unix()

	IPCSendByUid(sess.user.uid, msg.Uid, 1, 66, msgback)

	type D struct {
		Ret    int
		Uid    int
		Degree int
	}
	var d D
	d.Ret = 0
	d.Degree = sess.user.Friends.Friends[msg.Uid].friend_degree
	d.Uid = msg.Uid

	sess.SendReplyBack(d, 111)

	err = sess.user.quest.InspectQuest(QuestType_SendFriendNum, 0, 0)
	if err != nil {
		sess.Error("Failed QuestType_SendFriendNum", err)
		return false
	}
	return true
}

//opcode34
func UserGetExtraArm(sess *Session, reader []byte) bool {

	err := sess.user.E_Arm.DelExtraArm()
	if err != nil {
		sess.Error("Failed DelExtraArm", err)
		return false
	}
	return true
}

//opcode69
func UserGetAddFriendReward(sess *Session, reader []byte) bool {
	err := sess.user.Friends.GetUnRecvReward(sess)
	if err != nil {
		sess.Error("Failed GetUnRecvReward", err)
		return false
	}

	type DataBack struct {
		Ret  int
		Gold int
	}
	var back DataBack
	back.Gold = sess.user.gold
	back.Ret = 0
	return sess.SendReplyBack(back, 69)
}

/******************************************IPC Handler*******************************************************/
//opcode61  The one agree to be your friend
func IPCAgreeFriendApply(sess *Session, p *IPCMsg) bool {
	sess.Debug("IPCAgreeFriendApply", p.Content)

	var msg AcceptMsg
	err := json.Unmarshal(p.Content, &msg)
	if err != nil {
		log.Error("Failed Decode", err)
		return false
	}

	err = sess.user.Friends.AddFriend(msg.Uid, msg.Name, msg.Photo)
	if err != nil {
		sess.Error("Failed add friend", err)
	}
	sess.SendReply(p.Content, 61)

	err = sess.user.Friends.GetAddFriendReward(sess)
	if err != nil {
		sess.Error("Failed GetAddFriendReward", err)
		return false
	}
	return true
}

//opcode62  Someone want be your friend
func IPCFriendApply(sess *Session, p *IPCMsg) bool {
	sess.Debug("IPCFriendApply")

	return sess.SendReply(p.Content, 62)
}

//opcode64  Someone want to delete you from his friends
func IPCDeleteFriend(sess *Session, p *IPCMsg) bool {
	sess.Debug("IPCDeleteFriend")

	err := sess.user.Friends.DelFriend(p.SrcID)
	if err != nil {
		sess.Error("Failed DelFriend", err)
		return false
	}

	return sess.SendReply(p.Content, 64)
}

//opcode66
func IPCRecvMsg(sess *Session, p *IPCMsg) bool {
	sess.Debug("IPCRecvMsg")
	return sess.SendReply(p.Content, 66)
}

//opcode112
func IPCRecvArm(sess *Session, p *IPCMsg) bool {
	sess.Debug("IPCRecvArm")

	type ipc struct {
		Armid int
		Level int
		//FromUid  string
		Fuid   int
		Degree int
	}

	var msg ipc
	err := json.Unmarshal(p.Content, &msg)
	if err != nil {
		sess.Error("Failed decode", err)
		return true
	}

	tmp := sess.user.Friends.Friends[msg.Fuid]
	tmp.friend_degree = msg.Degree
	sess.user.Friends.Friends[msg.Fuid] = tmp

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	_, err = dbconn.Do("HSET", sess.user.GetUidUsedInDB()+":friend:"+GetUidUseInDB(msg.Fuid), "friend_degree", msg.Degree)
	if err != nil {
		sess.Error("Failed Add friend_degree", err)
		return false
	}

	if sess.user.E_Arm.IsFull() {
		return true
	}

	err = sess.user.E_Arm.AddExtraArm(msg.Armid, msg.Level, msg.Fuid)
	if err != nil {
		sess.Error("Failed AddExtraArm", err)
		return false
	}

	return sess.SendReply(p.Content, 112)
}

//opcode113
func UserCheckUserInfo(sess *Session, reader []byte) bool {
	type Data struct {
		Fuid int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message, err = %v", err)
		return false
	}

	type DataBack struct {
		Fuid int
		Sid  int
	}

	var back DataBack

	back.Fuid = msg.Fuid
	back.Sid = GetPlayerSimpleGuanqiaByUid(sess.user.uid, msg.Fuid)

	return sess.SendReplyBack(back, 113)
}
