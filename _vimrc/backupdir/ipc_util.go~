package gameserver

import (
	"encoding/json"
	"github.com/garyburd/redigo/redis"
	"sanguo/base/log"
	"sanguo/db"
	. "sanguo/systemdata"
	"time"
)

type IPCMsg struct {
	SrcID    string
	DestID   string
	Op       int
	CastType int
	Content  []byte
	Time     int64
}

const (
	UNICAST = 1
)

func IPCSendByUid(src_id, dest_id string, casttype int, op int, content interface{}) (ret bool) {
	val, err := json.Marshal(content)
	if err != nil {
		log.Error("cannot marshal content to json", err)
		return false
	}

	req := &IPCMsg{
		SrcID:    src_id,
		DestID:   dest_id,
		CastType: casttype,
		Op:       op,
		Content:  val,
		Time:     time.Now().Unix(),
	}
	peer := PlayerManager.QueryOnlineString(dest_id)
	if peer != nil {
		defer func() {
			if x := recover(); x != nil {
				ret = false
				SaveOfflineMsgImprove(req)
			}
		}()

		select {
		case peer.MQ <- *req:
		case <-time.After(time.Second):
			panic("deadlock") // 防止对方goroutine没有close channel
		}
		return true
	} else {
		SaveOfflineMsgImprove(req)
		return true
	}

	return false
}

func IPCSendByName(src_id string, dest_name string, casttype int, op int, content interface{}) (ret bool) {
	dest_id, err := GetUidByName(dest_name)
	if err != nil {
		log.Error("Failed get id through name", err)
		return false
	}

	return IPCSendByUid(src_id, dest_id, casttype, op, content)
}

func SaveOfflineMsgImprove(req *IPCMsg) (err error) {
	log.Critical("Wried")
	data, err := json.Marshal(*req)
	if err != nil {
		log.Error("Failed decode IPCMsg in SaveOfflineMsg", *req)
		return err
	}

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	log.Critical("jj", req.DestID, data)
	_, err = dbconn.Do("RPUSH", req.DestID+":offline", data)
	if err != nil {
		log.Error("Failed rpush offline msg", err)
		return err
	}
	return nil
}

/*func IPCSendByName(sess *Session, dest_name string, casttype int, op int, content interface{}) (ret bool) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	dest_id, err := redis.String(dbconn.Do("GET", dest_name))
	if err != nil {
		log.Error("Failed get id through name", err)
		return false
	}

	val, err := json.Marshal(content)
	if err != nil {
		log.Error("cannot marshal content to json", err)
		return false
	}

	req := &IPCMsg{
		SrcID:    sess.user.uid,
		DestID:   dest_id,
		CastType: casttype,
		Op:       op,
		Content:  val,
		Time:     time.Now().Unix(),
	}

	switch casttype {
	/*case MULTICAST:
		return hub_client.Forward(req)
	case GLOBAL_BROADCAST:
		hub_client.Forward(req)
		fallthrough
	case LOCAL_BROADCAST:
		users := gsdb.ListAll()
		defer func() {
			recover()
		}()

		for _, v := range users {
			if v != src_id {
				peer := gsdb.PlayerManager.QueryOnline(v)
				if peer != nil {
					peer.MQ <- *req
				}
			}
		}
		return true*

	case UNICAST:
		//
		peer := PlayerManager.QueryOnline(dest_id)
		if peer != nil {
			defer func() {
				if x := recover(); x != nil {
					ret = false
					SaveOfflineMsg(sess, req)
				}
			}()

			select {
			case peer.MQ <- *req:
			case <-time.After(time.Second):
				panic("deadlock") // 防止对方goroutine没有close channel
			}
			return true
		} else {
			SaveOfflineMsg(sess, req)
			return true
		}
	}

	return false
}*/

func IPCSendById(sess *Session, dest_id string, casttype int, content interface{}) (ret bool) {
	// convert the OBJECT to json, LEVEL-1 encapsulation
	val, err := json.Marshal(content)
	if err != nil {
		log.Error("cannot marshal content to json", err)
		return false
	}

	req := &IPCMsg{
		SrcID:    sess.user.uid,
		DestID:   dest_id,
		CastType: casttype,
		Content:  val,
		Time:     time.Now().Unix(),
	}

	switch casttype {
	/*case MULTICAST:
		return hub_client.Forward(req)
	case GLOBAL_BROADCAST:
		hub_client.Forward(req)
		fallthrough
	case LOCAL_BROADCAST:
		users := gsdb.ListAll()
		defer func() {
			recover()
		}()

		for _, v := range users {
			if v != src_id {
				peer := gsdb.PlayerManager.QueryOnline(v)
				if peer != nil {
					peer.MQ <- *req
				}
			}
		}
		return true*/

	case UNICAST:
		//
		peer := PlayerManager.QueryOnlineString(dest_id)
		if peer != nil {
			return SendByChannel(peer, req)
		} else {
			SaveOfflineMsg(sess, req)
		}
	}

	return false
}

func SendByChannel(sess *Session, req *IPCMsg) (ret bool) {
	defer func() {
		if x := recover(); x != nil {
			log.Error("Failed send msg")
			ret = false
			SaveOfflineMsg(sess, req)
		}
	}()

	select {
	case sess.MQ <- *req:
	case <-time.After(time.Second):
		panic("deadlock") // 防止对方goroutine没有close channel
	}
	return true
}

func SaveOfflineMsg(sess *Session, req *IPCMsg) error {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	data, err := json.Marshal(*req)
	if err != nil {
		log.Error("Failed decode IPCMsg in SaveOfflineMsg", sess.user.uid)
		return err
	}
	_, err = dbconn.Do("RPUSH", req.DestID+":offline", data)
	if err != nil {
		return err
	}
	return nil
}

/*func LoadOfflineMsg(sess *Session) ([]string, error) {
	reply, err := dbconn.Do("SMEMBERS", sess.user.uid+":offline")
	if err != nil {
		return nil, err
	}
	msg, err := redis.Strings(reply, nil)
	if err != nil {
		log.Debug("Failed convert reply to string", err)
		return nil, err
	}
	return msg, nil
}*/

func UserByGoldWithCash(id string) bool {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	flag, err := redis.Bool(dbconn.Do("EXISTS", id))
	if err != nil {
		log.Error(err)
		return false
	}
	if !flag {
		log.Error("Wrong id")
		return false
	}

	uid, err := redis.String(dbconn.Do("GET", id))
	if err != nil {
		log.Error(err)
		return false
	}

	req := &IPCMsg{
		SrcID:    "pp",
		DestID:   uid,
		CastType: 0,
		Op:       100, //110 mean money
		Content:  nil,
		Time:     time.Now().Unix(),
	}

	peer := PlayerManager.QueryOnlineString(uid)
	if peer != nil {
		return SendByChannel(peer, req)
	} else {
		gold, err := redis.Int(dbconn.Do("HGET", uid, "gold"))
		if err != nil {
			log.Error(err)
			return false
		}

		gold += 3000
		_, err = dbconn.Do("HSET", uid, "gold", gold)
		if err != nil {
			log.Error(err)
			return false
		}
	}

	return true
}

func IPCBuyGold(sess *Session, req *IPCMsg) bool {
	log.Debug("User", sess.user.uid, "will buy gold")
	_, err := sess.user.ProcessReward(RewardType_Gold, 3000)
	if err != nil {
		log.Error(err)
		return false
	}
	return true
}

func GetUnreadMsg(sess *Session) ([]byte, error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	msg_raw, err := dbconn.Do("LPOP", sess.user.uid+":offline")
	if err != nil {
		return nil, err
	}

	if msg_raw == nil {
		return nil, nil
	}

	msg, err := redis.Bytes(msg_raw, nil)
	if err != nil {
		return nil, err
	}

	return msg, nil
}

func HandlerOfflineMsg(sess *Session) error {
	var data IPCMsg
	for {
		msg, err := GetUnreadMsg(sess)
		if err != nil {
			sess.Error("Failed get offline msg", err, sess.user.uid)
			return err
		}
		if msg == nil {
			return nil
		}

		err = json.Unmarshal(msg, &data)
		if err != nil {
			sess.Error("Failed decode msg in HandlerOfflineMsg", err, sess.user.uid)
			continue
		}

		if !IPCRequestProxy(sess, &data) {
			sess.Error("Failed IPCRequestProxy")
			break
		}

	}
	return nil
}
