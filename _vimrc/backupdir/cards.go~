package gameserver

import (
	"sanguo/base/log"
	. "sanguo/systemdata"
	//"sanguo/base/packet"
)

const (
	CardExpense      = 300
	HeroCardNeedTime = 5
)

const (
	Unseen        = 0
	Uncharge_Seen = 1
	Charge_Seen   = 2
	UnGet         = 3
)

//opcode 25
func UserGetRandomCard(sess *Session, reader []byte) bool {
	if !sess.user.VerifyWealth(RewardType_Stone, CardExpense) {
		log.Error("The user stone is not enough", sess.user.stone, sess.user.uid)
		return false
	}

	err := sess.user.addCardCount()
	if err != nil {
		log.Error("Failed add user card count", err, sess.user.uid)
		return false
	}

	var cards []int

	cards = sess.user.UnchargePlayerGetRandomCard()

	if cards == nil {
		log.Error("Not get a card", sess.user.uid)
		return false
	}

	type CardInfo struct {
		Id    int
		Type  int
		Value int
	}
	type DataBack struct {
		Cards      []CardInfo
		EventId    int
		EventCount int
		EventTime  int64
	}

	var back DataBack
	if len(cards) == MaxRandomCardNum {
		back.Cards = make([]CardInfo, MaxRandomCardNum)
	} else if len(cards) == (MaxRandomCardNum - 1) {
		back.Cards = make([]CardInfo, MaxRandomCardNum-1)
	} else {
		return false
	}

	var tmp_card CardInfo
	for i := 0; i < MaxRandomCardNum-1; i++ {
		Type, Value, err := sess.user.Arm.ProcessNewGetArm(cards[i])
		if err != nil {
			log.Error("Failed process new get arm", err)
			return false
		}
		tmp_card.Id = cards[i]
		tmp_card.Type = Type
		tmp_card.Value = Value
		back.Cards[i] = tmp_card
	}

	if len(cards) == MaxRandomCardNum {
		Type, Value, err := sess.user.Hero.ProcessNewGetHero(cards[MaxRandomCardNum-1])
		if err != nil {
			log.Error("Failed process new get arm", err)
			return false
		}
		tmp_card.Id = cards[MaxRandomCardNum-1]
		tmp_card.Type = Type
		tmp_card.Value = Value
		back.Cards[MaxRandomCardNum-1] = tmp_card
	}

	err = sess.user.CostWealth(RewardType_Stone, CardExpense)
	if err != nil {
		log.Error("Failed CostStone", err, sess.user.uid)
		return false
	}
	GM.GMDayLog(sess.user.uid, StatIDDrawCard, CardExpense)

	back.EventCount = sess.user.GetEventLeftCount()
	back.EventId = sess.user.event_id
	back.EventTime = sess.user.GetEventLeftTime()

	return sess.SendReplyBack(back, 25)
}
