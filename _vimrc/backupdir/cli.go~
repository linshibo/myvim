package main

import (
    "encoding/binary"
    "encoding/json"
    "fmt"
    //"net"
    "os"
    "runtime"
    "sanguo/base/packet"
    "strconv"
    "test/asynserver"
    "time"
)

const (
    HeadLen = 4
)

//收到包回调
func MessageCallback(sess *asynserver.Session, data []byte) bool {
    fmt.Println("MessageCallback:")
    fmt.Println(data)
    return true
}

//连接关闭回调
func CloseCallback(sess *asynserver.Session) {
    fmt.Println("CloseCallback:")
}

//调用者根据头部信息返回包体长度
func GetSizeCallback(header []byte) int {
    fmt.Println("GetSizeCallback:")
    size := binary.LittleEndian.Uint16(header) + HeadLen
    return int(size)
}

func register(fd *asynserver.Session) {
    writer := packet.Writer()
    // length in the head is only the length of data
    back := make(map[string]interface{})
    back["id"], _ = strconv.Atoi(os.Args[2])
    back_json, err := json.Marshal(back)
    if err != nil {
        fmt.Println(err)
        return
    }
    writer.WriteU16(uint16(len(back_json)))
    writer.WriteU16(uint16(1000))
    writer.WriteU16(0)
    writer.WriteRawBytes(back_json)
    fd.Conn.Write(writer.Data)
    fmt.Println(writer.Data)
}
func chat(fd *asynserver.Session) {
    writer := packet.Writer()
    // length in the head is only the length of data
    back := make(map[string]interface{})
    back["sender"] = 1
    back["recver"] = 2
    back["msg"] = "nihao"
    back_json, err := json.Marshal(back)
    if err != nil {
        return
    }
    writer.WriteU16(uint16(len(back_json)))
    writer.WriteU16(uint16(1001))
    writer.WriteU16(0)
    writer.WriteRawBytes(back_json)
    fd.Conn.Write(writer.Data)
    fmt.Println(writer.Data)
}
func main() {
    ok, client := asynserver.ConnectToServer(os.Args[1], 10)
    if !ok {
        fmt.Println("connect fail ", os.Args[1])
        return
    }
    fmt.Println("connect succ", os.Args[1])
    register(client)
    if os.Args[2] == "1" {
        fmt.Println("chat")
        chat(client)
    }
    for {
        select {
        case msg, ok := <-client.RecvChan:
            if !ok {
                // the cmd channel is closed by the other side
                fmt.Println("The channel is closed by the other side")
                return
            }
            if !MessageCallback(client, msg) {
                //if process error player need load again
                fmt.Println("dispatch error ")
                return
            }
        case <-time.After(20 * time.Second):
            fmt.Println("Timeout and will close")
            runtime.Goexit()
        }
    }
}
