package gameserver

import (
	"encoding/json"
	//"sanguo/base/packet"
	. "sanguo/systemdata"
)

func GetAllActivity(sess *Session) []ActivityData {
	return nil
}

func LoadActivityEveryDay() {
	//if !UpdateSystemActivityEveryDay() {
	//	log.Error("Failed UpdateSystemActivityEveryDay")
	//	return
	//}
	/*
		for {
			t := 86400 - time.Now().Unix()%86400
			select {
				case <-time.After(time.Duration(t) * time.Second):
				if !UpdateSystemActivityEveryDay() {
					sess.Error("Failed UpdateSystemActivityEveryDay")
				}
			}
		}*/
}

//opcode70
func UserRefreshActivity(sess *Session, reader []byte) bool {
	//TODO

	type DataBack struct {
		Ret   int
		Act   []int
		Count int
		Power int
		Left  int
	}
	var back DataBack

	flag := false
	var err error
	count := sess.user.Activity.GetRefreshCount() + 1
	sess.Debug("In UserRefreshActivity, count is", count)
	if count == 0 {
		flag = true
	} else if count > 3 {
		sess.Error("Refresh more than 3")
		return false
	} else if count == 1 {
		flag = sess.user.VerifyWealth(RewardType_Power, 5)
		if !flag {
			sess.Error("Power is less than 5", sess.user.power)
			return false
		}
		if flag {
			sess.user.CostWealth(RewardType_Power, 5)
		}
	} else {
		flag = sess.user.VerifyWealth(RewardType_Power, 10)
		if !flag {
			sess.Error("Power is less than 10", sess.user.power)
			return false
		}
		if flag {
			sess.user.CostWealth(RewardType_Power, 10)
		}
	}

	if !flag {
		back.Ret = 1
		return sess.SendReplyBack(back, 70)
	} else {
		back.Ret = 0
	}

	back.Left, err = sess.user.GetLeftTimeToAddPower()
	back.Power = sess.user.power

	err = sess.user.Activity.Refresh()
	if err != nil {
		sess.Error("Failed Activity Refresh")
		return false
	}

	back.Act = sess.user.Activity.GetOwnActivity()
	back.Count = sess.user.Activity.GetRefreshCount()

	return sess.SendReplyBack(back, 70)
}

func UserLoginActivity(sess *Session, reader []byte) bool {
	type DataBack struct {
		Ret   int
		Act   []int
		Count int
		Power int
		Left  int
	}
	var back DataBack

	back.Ret = 0
	back.Left, _ = sess.user.GetLeftTimeToAddPower()
	back.Power = sess.user.power

	back.Act = sess.user.Activity.GetOwnActivity()
	back.Count = sess.user.Activity.GetRefreshCount()

	return sess.SendReplyBack(back, 70)
}

//opcode71
func UserStartActivityFight(sess *Session, reader []byte) bool {
	type Data struct {
		Aid int
	}
	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}
	sess.Debug("A data from client", msg, sess.user.uid)

	type DataBack struct {
		Ret int
	}
	var back DataBack

	if sess.user.Activity.CanStart(msg.Aid) {
		back.Ret = 0
	} else {
		back.Ret = 1
	}

	return sess.SendReplyBack(back, 71)
}

//opcode72
func UserEndActivityFight(sess *Session, reader []byte) bool {
	sess.Debug("The data recv is ", string(reader), sess.user.uid)

	type Data struct {
		Ret   bool
		Aid   int
		Fight FightDataVerify
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}
	sess.Debug("A data from client", msg, sess.user.uid)

	type DataBack struct {
		Ret       bool
		Reward    []ActivityReward
		Level     int
		Login_arm int
		FQReward  Reward_tmp
	}
	var back DataBack
	back.Ret = msg.Ret

	if msg.Ret {
		veri_flag := sess.user.Activity.ActivityFightVerify(msg.Aid, &msg.Fight)
		if !veri_flag {
			back.Ret = false
			return sess.SendReplyBack(back, 72)
		}

		back.Reward, err = sess.user.Activity.GetActivityReward(msg.Aid, msg.Fight.Score)
		if err != nil {
			sess.Error("Failed get score reward", err)
			return false
		}

		if msg.Fight.FinishedQuest != 0 {
			//quest_reward, err := GetFightQuestReward(sess, msg.Fight.FinishedQuest)
			back.FQReward, err = sess.user.quest.GetFightQuestReward(msg.Fight.FinishedQuest)
			if err != nil {
				sess.Error("Failed get quest reward", err)
				return false
			}

			err = sess.user.quest.DelFightQuest(msg.Fight.FinishedQuest)
			if err != nil {
				sess.Error("Failed DelFightQuest", err)
				return false
			}

			//back.FQReward = quest_reward
		}
	}

	err = sess.user.Activity.DelActivity(msg.Aid)
	if err != nil {
		sess.Error("Failed DelActivity", err)
		return false
	}

	err = DelLoginArm(sess)
	if err != nil {
		sess.Error("Failed DelLoginArm", err, sess.user.uid)
		return false
	}
	back.Login_arm = msg.Fight.Login_arm

	if msg.Fight.CoinsGot > 0 {
		_, err = sess.user.ProcessReward(RewardType_Gold, msg.Fight.CoinsGot)
		if err != nil {
			sess.Error("Failed AddGold", err, sess.user.uid)
			return false
		}
	}

	back.Level = sess.user.level

	sess.SendReplyBack(back, 72)

	err = sess.user.quest.InspectQuest(QuestType_FinishActivity, 0, 0)
	if err != nil {
		sess.Error("Failed QuestType_FinishActivity", err)
		return false
	}
	return true
}
