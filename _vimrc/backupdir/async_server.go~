package asynserver

import (
    //"encoding/binary"
    "fmt"
    "io"
    "net"
    "os"
    "runtime"
    "time"
)

type Callback struct {
    //收到包回调
    messageCallback func(conn net.Conn, data []byte) bool
    //连接关闭回调
    closeCallback func(conn net.Conn)
    //调用者根据头部信息返回包体长度
    getBodySizeCallback func(header []byte) int
    //自定义头部长度
    headlen int
    //目标地址host example: 192.168.1.1:8888
    host string
}

func startConnection(recvChan chan []byte, conn net.Conn, handler Callback) {
    defer func() {
        conn.Close()
    }()
    for {
        select {
        case msg, ok := <-recvChan:
            if !ok {
                // the cmd channel is closed by the other side
                //client.Debug("The cmd channel is closed by the other side")
                return
            }
            if !handler.messageCallback(conn, msg) {
                //client.Error("Something wrong in process user msg, the connection will close")
                //if process error player need load again
                return
            }
        case <-time.After(20 * time.Second):
            //client.Debug("Timeout and will close")
            runtime.Goexit()
        }
    }
}

func handleConn(conn net.Conn, handler Callback) {
    defer conn.Close()
    defer handler.closeCallback(conn)

    recvChan := make(chan []byte, 1024)
    header := make([]byte, handler.headlen)
    data := make([]byte, 1024)

    go startConnection(recvChan, conn, handler)
    for {
        n, err := io.ReadFull(conn, header)
        if n == 0 && err == io.EOF {
            //Opposite socket is closed
            break
        } else if err != nil {
            //Sth wrong with this socket
            break
        }
        //size := binary.LittleEndian.Uint16(header) + 4
        size := handler.getBodySizeCallback(header)
        n, err = io.ReadFull(conn, data[0:size])
        if n == 0 && err == io.EOF {
            break
        } else if err != nil {
            break
        }
        recvChan <- data //send data to Client to process
    }
}

func ConnectToServer(Host string, headlen int, h Callback) (bool, net.Conn) {
    conn, err := net.Dial("tcp", Host)
    if err != nil {
        fmt.Println("error connect", Host, err.Error())
        return false, nil
    }
    go handleConn(conn, h)
    return true, conn
}

func StartServer(h Callback) {
    listener, err := net.Listen("tcp", h.host)
    if err != nil {
        fmt.Println("fatal error listening:", err)
        os.Exit(1)
    }
    defer listener.Close()
    fmt.Println("asynServer start listening:", h.host)
    for {
        conn, err := listener.Accept()
        if err != nil {
            continue
        }
        go handleConn(conn, h)
    }
}
