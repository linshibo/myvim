package gameserver

import (
	"encoding/json"
	"errors"
	"sanguo/base/log"
	//"sanguo/base/packet"
	. "sanguo/base/util"
	"sanguo/db"
	. "sanguo/systemdata"
	"strconv"
	"time"
)

const (
	RewardCount = 2
)

var (
	WizardSimpleGuanqia = []int{103, 105, 107, 4, 5, 114, 6, 7}
)

//opcode 30
func UserLoginReward(sess *Session) bool {
	reward, err := GetLoginReward(sess)
	if err != nil {
		sess.Error("Failed GetLoginReward", err, sess.user.uid)
		return false
	}
	if reward == nil {
		sess.Debug("There is no reward given", sess.user.uid)
		return true
	}

	back := make(map[string]interface{})
	back["Reward"] = reward
	return sess.SendReplyBack(back, 30)
}

//opcode 31
func UserGetLoginReward(sess *Session, reader []byte) bool {

	type Data struct {
		Type  int
		Value int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}
	sess.Debug("A data from client", msg, sess.user.uid)

	if msg.Type == RewardType_Gold {
		return ProcessLoginGoldReward(sess, msg.Value)
	} else if msg.Type == RewardType_Power {
		return ProcessLoginPowerReward(sess, msg.Value)
	}
	return false
}

func ProcessLoginGoldReward(sess *Session, num int) bool {
	flag := false
	for index, v := range sess.user.last_login_reward {
		if v.Type != RewardType_Gold {
			continue
		}
		if v.Value == num {
			flag = true
			err := DelLastLoginReward(sess, index)
			if err != nil {
				sess.Error("Failed DelLastLoginReward", err, sess.user.uid)
				return false
			}
			break
		}
	}

	if !flag {
		sess.Error("The reward is not found", sess.user.uid)
		return false
	}

	_, err := sess.user.ProcessReward(RewardType_Gold, num)
	if err != nil {
		sess.Error("Failed Add Gold", err, sess.user.uid)
		return false
	}
	return true
}

func ProcessLoginPowerReward(sess *Session, num int) bool {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	if sess.user.last_login_reward[LoginRewardNum-1].Value < num {
		sess.Error("The last_login_power is less than recv", sess.user.uid)
		return false
	}

	sess.user.last_login_reward[LoginRewardNum-1].Value -= num
	_, err := dbconn.Do("HMSET", sess.user.GetUidUsedInDB()+":last_login_reward:"+strconv.Itoa(LoginRewardNum-1), "Value", sess.user.last_login_reward[LoginRewardNum-1].Value)
	if err != nil {
		sess.Error("Failed update last_login_reward")
		return false
	}

	err = sess.user.AddPower(num)
	if err != nil {
		sess.Error("Failed AddPower", err)
		return false
	}

	return true
}

//opcode 32
func UserLoginArm(sess *Session) bool {
	id, err := GetLoginArm(sess)
	if err != nil {
		sess.Error("Failed GetLoginArm", err, sess.user.uid)
		return false
	}

	if id == 0 {
		sess.Debug("There is no arm given", sess.user.uid)
		return true
	}

	back := make(map[string]interface{})
	back["Value"] = id
	return sess.SendReplyBack(back, 32)
}

//opcode 33
func UserGetLoginArm(sess *Session, reader []byte) bool {

	type Data struct {
		Value int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}
	sess.Debug("A data from client", msg, sess.user.uid)

	if sess.user.last_login_arm != msg.Value {
		sess.Error("The arm is not found", sess.user.uid)
		return false
	}

	err = DelLastLoginArm(sess)
	if err != nil {
		sess.Error("Failed DelLastLoginArm", err, sess.user.uid)
		return false
	}

	err = AddLoginArm(sess, msg.Value)
	if err != nil {
		sess.Error("Failed AddLoginArm", err, sess.user.uid)
		return false
	}
	return true
}

func GetLoginReward(sess *Session) ([]Reward, error) {
	var reward []Reward
	if IsFirstLoginOfToday(sess.user.last_login) {
		if sess.user.Friends.FriendNum() > 0 {
			tmp, err := GetLoginPowerReward(sess)
			if err != nil {
				sess.Error("Failed ProcessLoginPowerReward", err, sess.user.uid)
				return nil, err
			}
			reward = append(reward, tmp)
		}
	} else {
		if sess.user.last_login_reward[2].Value != 0 {
			var tmp Reward
			tmp.Type = sess.user.last_login_reward[2].Type
			tmp.Value = sess.user.last_login_reward[2].Value
			reward = append(reward, tmp)
		}
	}

	reward_left_count := 0
	for i := 0; i < 2; i++ {
		if sess.user.last_login_reward[i].Type == 0 {
			reward_left_count++
		} else {
			reward = append(reward, sess.user.last_login_reward[i])
		}
	}

	if reward_left_count == 0 {
		return reward, nil
	}

	interval := time.Now().Unix() - sess.user.last_login_reward_time
	if interval < 60*60*2 {
		return reward, nil
	}

	reward_count := 0
	if interval > 60*60*10 {
		reward_count = 2
	} else {
		num := int(interval / (60 * 60 * 2))
		for i := 0; i < num; i++ {
			if IsProbabilityHappen(40) {
				reward_count++
			}
		}

		if reward_count > 2 {
			reward_count = 2
		}
	}

	if reward_count == 0 {
		return reward, nil
	}

	if reward_count > reward_left_count {
		reward_count = reward_left_count
	}

	for i := 0; i < reward_count; i++ {
		tmp, err := GetLoginGoldReward(sess)
		if err != nil {
			sess.Error("Failed ProcessLoginReward", err, sess.user.uid)
			return nil, err
		}
		reward = append(reward, tmp)
	}

	return reward, nil
}

func GetLoginArm(sess *Session) (int, error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	t := time.Now().Hour()
	sess.Debug("The time of GetLoginArm is", t, sess.user.uid)
	if !((t >= 13 && t < 15) || (t >= 18 && t < 20)) {
		return 0, nil
	}

	flag := true
	for _, sid := range WizardSimpleGuanqia {
		if sid == sess.user.s_guanqia {
			flag = false
		}
	}

	if !flag {
		return 0, nil
	}

	sess.Debug("The user last_login_arm is", sess.user.last_login_arm, sess.user.uid)

	if sess.user.login_arm_given {
		return sess.user.last_login_arm, nil
	}

	sess.user.login_arm_given = true
	_, err := dbconn.Do("HSET", sess.user.uid, "login_arm_given", sess.user.login_arm_given)
	if err != nil {
		sess.Error("Failed set login_arm_given", sess.user.uid)
		return 0, err
	}

	id, err := ProcessLoginArm(sess)
	if err != nil {
		sess.Error("Failed ProcessLoginArm", err, sess.user.uid)
		return 0, err
	}

	return id, nil
}

func ProcessLoginArm(sess *Session) (int, error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	var id int
	for i := 0; i < 10; i++ {
		id = GetRandomArm()
		if ArmInfo[id].StarsNeed == 4 {
			continue
		}
		break
	}

	sess.user.last_login_arm = id
	_, err := dbconn.Do("HSET", sess.user.uid, "last_login_arm", id)
	return id, err
}

func GetRandomArm() int {
	armnum := ArmStarAndQualityBegin[4][5] + ArmStarAndQualityCount[4][5]
	index := GetRandomNum(armnum)
	id := ArmIndex[index]
	log.Debug("UUU", armnum, index, id)
	log.Debug("ZZZ", ArmIndex)
	return id
}

func GetLoginGoldReward(sess *Session) (Reward, error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	var back Reward
	back.Type = RewardType_Stone
	back.Value = 2 + GetRandomNum(3)

	empty_pos := -1
	if sess.user.last_login_reward[0].Type == 0 {
		empty_pos = 0
	} else if sess.user.last_login_reward[1].Type == 0 {
		empty_pos = 1
	} else {
		return back, errors.New("There is no empty position")
	}

	sess.user.last_login_reward[empty_pos].Type = back.Type
	sess.user.last_login_reward[empty_pos].Value = back.Value
	_, err := dbconn.Do("HMSET", sess.user.GetUidUsedInDB()+":last_login_reward:"+strconv.Itoa(empty_pos), "Type", back.Type, "Value", back.Value)
	if err != nil {
		sess.Error("Failed set last_login_reward", err, sess.user.uid)
		return back, err
	}

	sess.user.last_login_reward_time = time.Now().Unix()
	_, err = dbconn.Do("HSET", sess.user.uid, "last_login_reward_time", sess.user.last_login_reward_time)
	return back, nil
}

func GetLoginPowerReward(sess *Session) (Reward, error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	var back Reward
	back.Type = RewardType_Power
	back.Value = sess.user.Friends.FriendNum()

	sess.user.last_login_reward[LoginRewardNum-1].Type = back.Type
	sess.user.last_login_reward[LoginRewardNum-1].Value = back.Value
	_, err := dbconn.Do("HMSET", sess.user.GetUidUsedInDB()+":last_login_reward:"+strconv.Itoa(LoginRewardNum-1), "Type", back.Type, "Value", back.Value)
	if err != nil {
		sess.Error("Failed set last_login_reward", err, sess.user.uid)
		return back, err
	}
	return back, nil
}

func DelLastLoginReward(sess *Session, index int) error {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	sess.user.last_login_reward[index].Type = 0
	sess.user.last_login_reward[index].Value = 0
	_, err := dbconn.Do("HMSET", sess.user.GetUidUsedInDB()+":last_login_reward:"+strconv.Itoa(index), "Value", 0, "Type", 0)
	return err
}

func DelLastLoginArm(sess *Session) error {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	sess.user.last_login_arm = 0
	_, err := dbconn.Do("HSET", sess.user.GetUidUsedInDB(), "last_login_arm", 0)
	return err
}

func AddLoginArm(sess *Session, aid int) error {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	sess.user.login_arm = aid
	_, err := dbconn.Do("HSET", sess.user.GetUidUsedInDB(), "login_arm", aid)
	return err
}

func (sess *Session)UpdateLoginArmInTheFirstLoginOfDay() error {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	sess.user.login_arm_given = false
	sess.user.last_login_arm = 0

	_, err := dbconn.Do("HMSET", sess.user.GetUidUsedInDB(), "login_arm_given", false, "last_login_arm", 0)
	return err
}
