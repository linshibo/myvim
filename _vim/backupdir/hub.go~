package hub

import (
    "encoding/json"
    "sanguo/base/log"
    "GameHub/asynserver"
    "GameHub/db"
    "sanguo/base/packet"
	"net/http"
	"io/ioutil"
	"strings"
	//"strconv"
	"time"
)
type IPCMsg struct {
	SrcID    int
	DestID   int
	Op       int
	CastType int
	Content  []byte
	Time     int64
}

func ChargeNotifyOfI4(w http.ResponseWriter, r *http.Request) {                                                                                                         
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {                                                                                                                                                          
		log.Error("Failed read body", err)
		w.Write([]byte("1"))
		return
	}
	type Data struct {
		Order_id string
		Billno string
		Account string
		Amount string
		Status string
		App_id string
		Role string
		Zone string
		Sign string
	}
	var msg Data
	log.Debug("ChargeNotifyOfI4", string(body))
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte("1"))
		return
	}
	uid := db.GetUidByAccount(msg.Account)
	if uid == 0 {
		log.Error("not find user ", err)
		w.Write([]byte("1"))
		return 
	}
	sid := db.GetServerid(uid)
    gmSess := CM.GetConn(sid)
	if gmSess == nil {
		log.Error("not find user", msg)
		w.Write([]byte("1"))
		return 
	}
	back := make(map[string]interface{})
	back["UID"]=uid;
	back["UniqueID"]=msg.Billno;
	back["ProductID"]=msg.Role;
	back_json, err := json.Marshal(back)
	if err != nil {
		log.Error("Can't decode json message", err)
		w.Write([]byte("1"))
		return 
	}
	SendToIPC(gmSess, ChargeNotifyCmd, back_json)

	w.Write([]byte("0"))
}

func ChargeNotifyOfItools(w http.ResponseWriter, r *http.Request) {                                                                                                         
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {                                                                                                                                                          
		log.Error("Failed read body", err)
		w.Write([]byte("1"))
		return
	}
	type Data struct {
		//{"order_id_com":"2013050900000712","user_id":"10010","amount":"0.10","account":"test001","order_id":"2013050900000713","result":"success"}
		Order_id_com string
		User_id string
		Amount string
		Account string
		Result  string
	}
	var msg Data
	log.Debug("ChargeNotifyOfItools", string(body))
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte("1"))
		return
	}
	uid := db.GetUidByAccount(msg.Account)
	if uid == 0 {
		log.Error("not find user", msg)
		w.Write([]byte("1"))
		return 
	}
	sid := db.GetServerid(uid)
    gmSess := CM.GetConn(sid)
	if gmSess == nil {
		log.Error("not find user", msg)
		w.Write([]byte("1"))
		return 
	}
	str := strings.Split(msg.Order_id_com, ",")
	if len(str) < 2 {
		log.Error("order error", msg)
		w.Write([]byte("1"))
		return 
	}
	back := make(map[string]interface{})
	back["UID"]=uid;
	back["UniqueID"]=msg.Order_id_com
	back["ProductID"]=str[1]
	back_json, err := json.Marshal(back)
	if err != nil {
		log.Error("Can't decode json message", err)
		w.Write([]byte("1"))
		return 
	}
	SendToIPC(gmSess, ChargeNotifyCmd, back_json)
	w.Write([]byte("0"))
}

func ChargeNotify(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
	log.Debug("ChargeNotify")
    type data struct {
		UID int
		UniqueID string
		ProductID string
    }
    var msg data
    err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
    if err != nil {
        log.Error("Can't decode json message, err = ", err)
        return true
    }

	var back IPCMsg
	back.DestID=msg.UID
	back.Op=ChargeNotifyCmd
	back.Content=reader.Data[reader.Pos:]
	back.Time=time.Now().Unix()

	data_json, err := json.Marshal(back)
	if err != nil {
		log.Error("Can't decode json message", err)
		return true
	}

	SendToSession(sess, ChargeNotifyCmd,data_json)
	return true
}

func UserGetServerId(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
	gmSess := CM.GetConn(GMServerID)
	if gmSess != nil {
		if gmSess == sess {
			type data struct {
				Name string
			}
			var msg data
			err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
			if err != nil {
				log.Error("Can't decode json message, err = ", err)
				return true
			}
			uid := db.GetUid(msg.Name)
			in := make(map[string]interface{})
			if uid == 0 {
				log.Error("uid not exist", uid, msg.Name)
				in["sid"] = 0
				in["uid"] = 0
			} else {
				in["sid"] = db.GetServerid(uid)
				in["uid"] = uid

			}
			back_json, err := json.Marshal(in)
			if err != nil {
				log.Error("Can't decode json message", err)
				return true
			}
			SendToSession(sess, 0, back_json)
		}
	}
	return true
}

func UserTransmit(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
	log.Debug("UserChat")
	type IPCMsg struct {
		SrcID    int
		DestID   int
		Op       int
		CastType int
		Content  []byte
		Time     int64
	}
	var msg IPCMsg
	err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
	if err != nil {
		log.Error("Can't decode json message, err = ", err)
		return true
	}
	other := CM.GetConn(db.GetServerid(msg.DestID))
	if other != nil {
		SendToSession(other, cmd+1, reader.Data[reader.Pos:])
	}
	return true
}

const (
	Success               = 0
	PlayerNotOnline       = 1
	ErrorNameNotExist     = 5
	ErrorOperationTrouble = 6
)

func AllUserAdd(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
	gmSess := CM.GetConn(GMServerID)
	if gmSess != nil {
		if gmSess == sess {
			for i := range CM.connSlice {
				if CM.connSlice[i].sess != nil && CM.connSlice[i].ID != GMServerID {
					SendToSession(CM.connSlice[i].sess, AllUserAddCmd, reader.Data[reader.Pos:])
				}
			}
			back := make(map[string]interface{})
			back["ret"] = 0
			back_json, err := json.Marshal(back)
			if err != nil {
				log.Error("Can't decode json message", err)
				return false
			}
			SendToSession(sess, AllUserAddCmd, back_json)
		}
	}
	return true

}

func AddSoldier(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
	gmSess := CM.GetConn(GMServerID)
	if gmSess != nil {
		if gmSess == sess {
			type data struct {
				Name  string
				Level int
				Id    int
				Type  int
			}
			var msg data
			err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
			if err != nil {
				log.Error("Can't decode json message, err = ", err)
				return true
			}
			uid := db.GetUid(msg.Name)
			if uid == 0 {
				log.Error("uid not exist", uid, msg.Name)
				return true
			} else {
				other := CM.GetConn(db.GetServerid(uid))
				if other == nil {
					log.Error("not find server by uid ", uid)
					return true
				} else {
					in := make(map[string]interface{})
					in["uid"] = uid
					in["level"] = msg.Level
					in["Id"] = msg.Id
					in["Type"] = msg.Type
					back_json, err := json.Marshal(in)
					if err != nil {
						log.Error("Can't decode json message", err)
						return true
					}
					SendToSession(other, AddSoldierCmd, back_json)
					//back["ret"] = 0
				}
			}
		} else {
			SendToSession(gmSess, AddSoldierCmd, reader.Data[reader.Pos:])
		}
	}
	return true
}

func SkipGuanqia(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
	gmSess := CM.GetConn(GMServerID)
	if gmSess != nil {
		if gmSess == sess {
			type data struct {
				Name    string
				Chapter int
				C_guan  int
				S_guan  int
			}
			var msg data
			err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
			if err != nil {
				log.Error("Can't decode json message, err = ", err)
				return true
			}
			//back := make(map[string]interface{})
			uid := db.GetUid(msg.Name)
			if uid == 0 {
				log.Error("name not exist ", msg.Name)
				//back["ret"] = ErrorNameNotExist
				return true
			} else {
				other := CM.GetConn(db.GetServerid(uid))
				if other == nil {
					log.Error("not find server by uid ", uid, db.GetServerid(uid))
					//back["ret"] = ErrorOperationTrouble
					return true
				} else {
					in := make(map[string]interface{})
					in["uid"] = uid
					in["chapter"] = msg.Chapter
					in["c_guan"] = msg.C_guan
					in["s_guan"] = msg.S_guan
					back_json, err := json.Marshal(in)
					if err != nil {
						log.Error("Can't decode json message", err)
						return true
					}
					SendToSession(other, SkipGuanqiaCmd, back_json)
					//back["ret"] = 0
				}
			}
		} else {
			SendToSession(gmSess, SkipGuanqiaCmd, reader.Data[reader.Pos:])
		}
	}
	return true
}

func UserAdd(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
	gmSess := CM.GetConn(GMServerID)
	if gmSess != nil {
		if gmSess == sess {
			type data struct {
				Name  string
				Type  int
				Value int
			}
			var msg data
			err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
			if err != nil {
				log.Error("Can't decode json message ", string(reader.Data[reader.Pos:]), err)
				return true
			}
			//back := make(map[string]interface{})
			uid := db.GetUid(msg.Name)
			if uid == 0 {
				log.Error("name not exist ", msg.Name)
				//back["ret"] = ErrorNameNotExist
				return true
			} else {
				other := CM.GetConn(db.GetServerid(uid))
				if other == nil {
					log.Error("not find server by uid ", uid)
					//back["ret"] = ErrorOperationTrouble
					return true
				} else {
					in := make(map[string]interface{})
					in["uid"] = uid
					in["type"] = msg.Type
					in["value"] = msg.Value
					back_json, err := json.Marshal(in)
					if err != nil {
						log.Error("Can't decode json message", err)
						return true
					}
					SendToSession(other, UserAddCmd, back_json)
					//back["ret"] = 0
				}
			}
		} else {
			SendToSession(gmSess, UserAddCmd, reader.Data[reader.Pos:])
		}
	}
	return true
}
func CheckUserOnline(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
	log.Debug("CheckUserOnline")
	gmSess := CM.GetConn(GMServerID)
	if gmSess != nil {
		if gmSess == sess {
			//from gm
			type data struct {
				Name string
			}
			var msg data
			err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
			if err != nil {
				log.Error("Can't decode json message, err = ", err)
				return true
			}
			uid := db.GetUid(msg.Name)
			if uid == 0 {
				log.Error("name not exist ", msg.Name)
			} else {
				other := CM.GetConn(db.GetServerid(uid))
				if other == nil {
					log.Error("not find server by uid ", uid, db.GetServerid(uid))
				} else {
					in := make(map[string]interface{})
					in["uid"] = uid
					log.Debug(in)
					back_json, err := json.Marshal(in)
					if err != nil {
						log.Error("Can't decode json message", err)
						return true
					}
					log.Debug(string(back_json))
					SendToSession(other, CheckUserOnlineCmd, back_json)
				}
			}
		} else {
			//from server
			log.Debug(string(reader.Data[reader.Pos:]))
			SendToSession(gmSess, CheckUserOnlineCmd, reader.Data[reader.Pos:])
		}
	}
	return true
}

func QueryUserInfo(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
	log.Debug("QueryUserInfo")
	gmSess := CM.GetConn(GMServerID)
	if gmSess != nil {
		if gmSess == sess {
			//from gm
			type data struct {
				Name string
			}
			var msg data
			err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
			if err != nil {
				log.Error("Can't decode json message, err = ", err)
				return true
			}
			uid := db.GetUid(msg.Name)
			if uid == 0 {
				log.Error("name not exist ", msg.Name)
			} else {
				other := CM.GetConn(db.GetServerid(uid))
				if other == nil {
					log.Error("not find server by uid ", uid)
				} else {
					in := make(map[string]interface{})
					in["uid"] = uid
					in["sid"] = db.GetServerid(uid)
					back_json, err := json.Marshal(in)
					if err != nil {
						log.Error("Can't decode json message", err)
						return true
					}
					SendToSession(other, QueryUserInfoCmd, back_json)
				}
			}
		} else {
			//from server
			//log.Debug(string(reader.Data[reader.Pos:]))
			SendToSession(gmSess, QueryUserInfoCmd, reader.Data[reader.Pos:])
		}
	}
	return true
}

func GetPlayerBattleInfo(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
	type IPCMsg struct {
		UID int
	}
	var msg IPCMsg
	err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
	if err != nil {
		log.Error("Can't decode json message, err = ", err)
		return true
	}
	other := CM.GetConn(db.GetServerid(msg.UID))
	if other != nil {
		SendToSession(other, uint16(ReplyGetPlayerBattleInfoCmd), reader.Data[reader.Pos:])
	}
	return true
}

func ReplyGetPlayerBattleInfo(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
	type IPCMsg struct {
		UID   int
		Level int
	}
	var msg IPCMsg
	err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
	if err != nil {
		log.Error("Can't decode json message, err = ", err)
		return true
	}
	other := CM.GetConn(db.GetServerid(msg.UID))
	if other != nil {
		SendToSession(other, uint16(GetPlayerBattleInfoCmd), reader.Data[reader.Pos:])
	}
	return true

}

func ServerRegister(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
	type data struct {
		Id int
	}
	var msg data
	log.Debug("ServerReigster", reader.Data[reader.Pos:], sess.Conn.RemoteAddr())
	err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
	if err != nil {
		log.Error("Can't decode json message, err = ", err)
		return true
	}
	CM.RegisterConn(int(msg.Id), sess)
	SendToSession(sess, ServerRegisterCmd+1, reader.Data[reader.Pos:])
	return true
}

func DoPProf(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
	gmSess := CM.GetConn(GMServerID)
	if gmSess != nil {
		if gmSess == sess {
			for i := range CM.connSlice {
				if CM.connSlice[i].sess != nil && CM.connSlice[i].ID != GMServerID {
					SendToSession(CM.connSlice[i].sess, DoPProfCmd, reader.Data[reader.Pos:])
				}
			}
			back := make(map[string]interface{})
			back["ret"] = 0
			back_json, err := json.Marshal(back)
			if err != nil {
				log.Error("Can't decode json message", err)
				return false
			}
			SendToSession(sess, AllUserAddCmd, back_json)

		}
	}
	return true

}
