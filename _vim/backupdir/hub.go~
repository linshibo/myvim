package hub

import (
    "encoding/json"
    //"net"
    "sanguo/base/log"
    //"github.com/golang/log"
    "GameHub/asynserver"
    "GameHub/db"
    //"fmt"
    "sanguo/base/packet"
    //"strconv"
    //"strings"
    //"sync"
)

func UserGetServerId(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
    gmSess := CM.GetConn(GMServerID)
    if gmSess != nil {
        if gmSess == sess {
            type data struct {
                Name string
            }
            var msg data
            err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
            if err != nil {
                log.Error("Can't decode json message, err = ", err)
                return true
            }
            uid := db.GetUid(msg.Name)
            in := make(map[string]interface{})
            if uid == 0 {
                log.Error("uid not exist", uid, msg.Name)
                in["sid"] = 0
                in["uid"] = 0
            } else {
                in["sid"] = db.GetServerid(uid)
                in["uid"] = uid

            }
            back_json, err := json.Marshal(in)
            if err != nil {
                log.Error("Can't decode json message", err)
                return true
            }
            SendToSession(sess, 0, back_json)
        }
    }
    return true
}

func UserTransmit(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
    log.Debug("UserChat")
    type IPCMsg struct {
        SrcID    int
        DestID   int
        Op       int
        CastType int
        Content  []byte
        Time     int64
    }
    var msg IPCMsg
    err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
    if err != nil {
        log.Error("Can't decode json message, err = ", err)
        return true
    }
    other := CM.GetConn(db.GetServerid(msg.DestID))
    if other != nil {
        SendToSession(other, cmd+1, reader.Data[reader.Pos:])
    }
    return true
}

const (
    Success               = 0
    PlayerNotOnline       = 1
    ErrorNameNotExist     = 5
    ErrorOperationTrouble = 6
)

func AllUserAdd(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
    gmSess := CM.GetConn(GMServerID)
    if gmSess != nil {
        if gmSess == sess {
            for i := range CM.connSlice {
                if CM.connSlice[i].sess != nil && CM.connSlice[i].ID != GMServerID {
                    SendToSession(CM.connSlice[i].sess, AllUserAddCmd, reader.Data[reader.Pos:])
                }
            }
            back := make(map[string]interface{})
            back["ret"] = 0
            back_json, err := json.Marshal(back)
            if err != nil {
                log.Error("Can't decode json message", err)
                return false
            }
            SendToSession(sess, AllUserAddCmd, back_json)
        }
    }
    return true

}

func AddSoldier(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
    gmSess := CM.GetConn(GMServerID)
    if gmSess != nil {
        if gmSess == sess {
            type data struct {
                Name  string
                Level int
                Id    int
                Type  int
            }
            var msg data
            err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
            if err != nil {
                log.Error("Can't decode json message, err = ", err)
                return true
            }
            uid := db.GetUid(msg.Name)
            if uid == 0 {
                log.Error("uid not exist", uid, msg.Name)
                return true
            } else {
                other := CM.GetConn(db.GetServerid(uid))
                if other == nil {
                    log.Error("not find server by uid ", uid)
                    return true
                } else {
                    in := make(map[string]interface{})
                    in["uid"] = uid
                    in["level"] = msg.Level
                    in["Id"] = msg.Id
                    in["Type"] = msg.Type
                    back_json, err := json.Marshal(in)
                    if err != nil {
                        log.Error("Can't decode json message", err)
                        return true
                    }
                    SendToSession(other, AddSoldierCmd, back_json)
                    //back["ret"] = 0
                }
            }
        } else {
            SendToSession(gmSess, AddSoldierCmd, reader.Data[reader.Pos:])
        }
    }
    return true
}

func SkipGuanqia(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
    gmSess := CM.GetConn(GMServerID)
    if gmSess != nil {
        if gmSess == sess {
            type data struct {
                Name    string
                Chapter int
                C_guan  int
                S_guan  int
            }
            var msg data
            err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
            if err != nil {
                log.Error("Can't decode json message, err = ", err)
                return true
            }
            //back := make(map[string]interface{})
            uid := db.GetUid(msg.Name)
            if uid == 0 {
                log.Error("name not exist ", msg.Name)
                //back["ret"] = ErrorNameNotExist
                return true
            } else {
                other := CM.GetConn(db.GetServerid(uid))
                if other == nil {
                    log.Error("not find server by uid ", uid, db.GetServerid(uid))
                    //back["ret"] = ErrorOperationTrouble
                    return true
                } else {
                    in := make(map[string]interface{})
                    in["uid"] = uid
                    in["chapter"] = msg.Chapter
                    in["c_guan"] = msg.C_guan
                    in["s_guan"] = msg.S_guan
                    back_json, err := json.Marshal(in)
                    if err != nil {
                        log.Error("Can't decode json message", err)
                        return true
                    }
                    SendToSession(other, SkipGuanqiaCmd, back_json)
                    //back["ret"] = 0
                }
            }
        } else {
            SendToSession(gmSess, SkipGuanqiaCmd, reader.Data[reader.Pos:])
        }
    }
    return true
}

func UserAdd(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
    gmSess := CM.GetConn(GMServerID)
    if gmSess != nil {
        if gmSess == sess {
            type data struct {
                Name  string
                Type  int
                Value int
            }
            var msg data
            err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
            if err != nil {
                log.Error("Can't decode json message ", string(reader.Data[reader.Pos:]), err)
                return true
            }
            //back := make(map[string]interface{})
            uid := db.GetUid(msg.Name)
            if uid == 0 {
                log.Error("name not exist ", msg.Name)
                //back["ret"] = ErrorNameNotExist
                return true
            } else {
                other := CM.GetConn(db.GetServerid(uid))
                if other == nil {
                    log.Error("not find server by uid ", uid)
                    //back["ret"] = ErrorOperationTrouble
                    return true
                } else {
                    in := make(map[string]interface{})
                    in["uid"] = uid
                    in["type"] = msg.Type
                    in["value"] = msg.Value
                    back_json, err := json.Marshal(in)
                    if err != nil {
                        log.Error("Can't decode json message", err)
                        return true
                    }
                    SendToSession(other, UserAddCmd, back_json)
                    //back["ret"] = 0
                }
            }
        } else {
            SendToSession(gmSess, UserAddCmd, reader.Data[reader.Pos:])
        }
    }
    return true
}
func CheckUserOnline(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
    log.Debug("CheckUserOnline")
    gmSess := CM.GetConn(GMServerID)
    if gmSess != nil {
        if gmSess == sess {
            //from gm
            type data struct {
                Name string
            }
            var msg data
            err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
            if err != nil {
                log.Error("Can't decode json message, err = ", err)
                return true
            }
            uid := db.GetUid(msg.Name)
            if uid == 0 {
                log.Error("name not exist ", msg.Name)
            } else {
                other := CM.GetConn(db.GetServerid(uid))
                if other == nil {
                    log.Error("not find server by uid ", uid, db.GetServerid(uid))
                } else {
                    in := make(map[string]interface{})
                    in["uid"] = uid
                    log.Debug(in)
                    back_json, err := json.Marshal(in)
                    if err != nil {
                        log.Error("Can't decode json message", err)
                        return true
                    }
                    log.Debug(string(back_json))
                    SendToSession(other, CheckUserOnlineCmd, back_json)
                }
            }
        } else {
            //from server
            log.Debug(string(reader.Data[reader.Pos:]))
            SendToSession(gmSess, CheckUserOnlineCmd, reader.Data[reader.Pos:])
        }
    }
    return true
}

func QueryUserInfo(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
    log.Debug("QueryUserInfo")
    gmSess := CM.GetConn(GMServerID)
    if gmSess != nil {
        if gmSess == sess {
            //from gm
            type data struct {
                Name string
            }
            var msg data
            err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
            if err != nil {
                log.Error("Can't decode json message, err = ", err)
                return true
            }
            uid := db.GetUid(msg.Name)
            if uid == 0 {
                log.Error("name not exist ", msg.Name)
            } else {
                other := CM.GetConn(db.GetServerid(uid))
                if other == nil {
                    log.Error("not find server by uid ", uid)
                } else {
                    in := make(map[string]interface{})
                    in["uid"] = uid
                    back_json, err := json.Marshal(in)
                    if err != nil {
                        log.Error("Can't decode json message", err)
                        return true
                    }
                    SendToSession(other, QueryUserInfoCmd, back_json)
                }
            }
        } else {
            //from server
            //log.Debug(string(reader.Data[reader.Pos:]))
            SendToSession(gmSess, QueryUserInfoCmd, reader.Data[reader.Pos:])
        }
    }
    return true
}

func GetPlayerBattleInfo(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
    type IPCMsg struct {
        UID int
    }
    var msg IPCMsg
    err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
    if err != nil {
        log.Error("Can't decode json message, err = ", err)
        return true
    }
    other := CM.GetConn(db.GetServerid(msg.UID))
    if other != nil {
        SendToSession(other, uint16(ReplyGetPlayerBattleInfoCmd), reader.Data[reader.Pos:])
    }
    return true
}

func ReplyGetPlayerBattleInfo(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
    type IPCMsg struct {
        UID   int
        Level int
    }
    var msg IPCMsg
    err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
    if err != nil {
        log.Error("Can't decode json message, err = ", err)
        return true
    }
    other := CM.GetConn(db.GetServerid(msg.UID))
    if other != nil {
        SendToSession(other, uint16(GetPlayerBattleInfoCmd), reader.Data[reader.Pos:])
    }
    return true

}

func ServerRegister(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
    type data struct {
        Id int
    }
    var msg data
    log.Debug("ServerReigster", reader.Data[reader.Pos:], sess.Conn.RemoteAddr())
    err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
    if err != nil {
        log.Error("Can't decode json message, err = ", err)
        return true
    }
    CM.RegisterConn(int(msg.Id), sess)
    SendToSession(sess, ServerRegisterCmd+1, reader.Data[reader.Pos:])
    return true
}

func DoPProf(sess *asynserver.Session, reader *packet.Packet, cmd uint16) bool {
    gmSess := CM.GetConn(GMServerID)
    if gmSess != nil {
        if gmSess == sess {
            for i := range CM.connSlice {
                if CM.connSlice[i].sess != nil && CM.connSlice[i].ID != GMServerID {
                    SendToSession(CM.connSlice[i].sess, DoPProfCmd, reader.Data[reader.Pos:])
                }
            }
        }
    }
    return true

}
