package gameserver

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/garyburd/redigo/redis"
	"sanguo/base/util"
	"sanguo/config"
	"sanguo/db"
	. "sanguo/systemdata"
	"strconv"
	"strings"
)

type _Arm struct {
	level int
	prob  int
}

const (
	FormationLength = 16
)

type _ArmManager struct {
	arms      map[int]_Arm
	n_arms    map[int]bool
	allarmoid [ArmOidNum]int
	formation [FormationLength]int
	armEquip  map[int][3]int //小兵装备的格子  id->equipIDs
	user      *User
}

type RandomArms struct {
	Arms  [100]int
	Count int
}

func NewArmManager() *_ArmManager {
	var h _ArmManager
	h.arms = make(map[int]_Arm)
	h.n_arms = make(map[int]bool)
	h.armEquip = make(map[int][3]int)
	return &h
}
func (this *_ArmManager) LoadArmEquip() error {
	this.user.Debug("LoadArmEquip")
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	reply, err := redis.Strings(dbconn.Do("HGETALL", this.user.GetUidUsedInDB()+":armEquip"))
	if err != nil {
		return err
	}
	for i := 0; i < len(reply)/2; i++ {
		armid, err := strconv.Atoi(reply[i*2])
		equips := strings.Split(reply[i*2+1], ":")
		if err != nil || len(equips) != 3 {
			this.user.Error("LoadArmEquip Cant convert to int ", err, len(equips))
			continue
		}
		var equip [3]int
		for j := range equips {
			equip[j], err = strconv.Atoi(equips[j])
			if err != nil {
				this.user.Error(err)
			}
		}
		this.armEquip[armid] = equip
	}
	return nil
}


func (this *_ArmManager)GetFormation()[]ArmFormationBack{
	v := make([]ArmFormationBack, 0)
	for k, _ := range this.arms{
		var tmp ArmFormationBack
		tmp.Armid = k
		tmp.Hp, tmp.Damage = this.GetArmHpDamage(k)
		v = append(v, tmp)
	}
	return v
}

//GetArmHpDamage 获取小兵当前血量和伤害值
func (this *_ArmManager) GetArmHpDamage(id int) (hp, damage int) {
	conf, ok := ArmInfo[id]
	if ok {
		//原始值
		hp += conf.Hp
		damage += conf.Damage
	}
	equip, ok := this.armEquip[id]
	if ok {
		//装备加成
		if add, ok := ArmInfo[equip[0]]; ok {
			hp += int(float32(add.Hp) * ArmEquipHpAdd)
		}
		if add, ok := ArmInfo[equip[1]]; ok {
			damage += int(float32(add.Damage) * ArmEquipDamageAdd)
		}
	}
	return
}

func (this *_ArmManager) SetUser(u *User) {
	this.user = u
}

func (this *_ArmManager) InitArm() (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	for _, id := range config.Config.InitArm {

		prob := this.GetInitProbOfLevel(ArmInfo[id].QualityLevel, 1)
		this.arms[id] = _Arm{level: 1, prob: prob}

		_, err = redis.Bool(dbconn.Do("SADD", this.user.GetUidUsedInDB()+":arms", id))
		if err != nil {
			return err
		}

		_, err = dbconn.Do("HMSET", this.user.GetUidUsedInDB()+":arm:"+strconv.Itoa(id), "level", 1, "prob", prob)
		if err != nil {
			return err
		}
	}

	_, err = dbconn.Do("RPUSH", this.user.GetUidUsedInDB()+":formation", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
	if err != nil {
		this.user.Error("Can't insert user:formation into redis", err)
		return err
	}

	for i := 0; i < ArmOidNum; i++ {
		this.allarmoid[i] = InitAllArmOid[i]
		_, err := dbconn.Do("RPUSH", this.user.GetUidUsedInDB()+":allarm", this.allarmoid[i])
		if err != nil {
			this.user.Error("Failed init allarm in register", err)
			return err
		}
	}

	return nil
}

func (this *_ArmManager) Load() (err error) {
	if this.user == nil {
		err = errors.New("Error: The user is nil")
		return err
	}

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	reply, err := redis.Values(dbconn.Do("SMEMBERS", this.user.GetUidUsedInDB()+":arms"))
	if err != nil {
		this.user.Error("Can't get user:arms from redis")
		return err
	}

	num := len(reply)
	for i := 0; i < num; i++ {
		id, err := redis.Int(reply[i], nil)
		if err != nil {
			this.user.Error("Can't convert arm to int")
			return err
		}

		r, err := redis.Values(dbconn.Do("HMGET", this.user.GetUidUsedInDB()+":arm:"+strconv.Itoa(id), "level", "prob"))
		if err != nil {
			return err
		}

		level, err := redis.Int(r[0], nil)
		if err != nil {
			return err
		}

		prob, err := redis.Int(r[1], nil)
		if err != nil {
			return err
		}

		this.arms[id] = _Arm{level: level, prob: prob}
	}

	reply, err = redis.Values(dbconn.Do("SMEMBERS", this.user.GetUidUsedInDB()+":new_arm"))
	if err != nil {
		this.user.Error("Can't get user:new_arms from redis", err)
		return err
	}

	for i := 0; i < len(reply); i++ {
		aid, err := redis.Int(reply[i], nil)
		if err != nil {
			this.user.Error("Can't convert new_arm to int")
			return err
		}
		this.n_arms[aid] = true
	}

	reply, err = redis.Values(dbconn.Do("LRANGE", this.user.GetUidUsedInDB()+":allarm", 0, -1))
	if err != nil {
		this.user.Error("Can't get allarmoid from redis", err)
		return err
	}

	num = len(reply)
	if num > ArmOidNum {
		num = ArmOidNum
	}

	for i := 0; i < num; i++ {
		this.allarmoid[i], err = redis.Int(reply[i], nil)
		if err != nil {
			this.user.Error("Can't convert arms to int", err)
			return err
		}
	}

	reply, err = redis.Values(dbconn.Do("LRANGE", this.user.GetUidUsedInDB()+":formation", 0, FormationLength-1))
	if err != nil {
		this.user.Error("Can't get user:formation from redis")
		return err
	}

	for i := 0; i < len(reply); i++ {
		this.formation[i], err = redis.Int(reply[i], nil)
		if err != nil {
			this.user.Error("Can't convert formation to int")
			return err
		}
	}

	return nil
}

/*func (this *_ArmManager) GetArmLevel(id int) (level int) {
	return this.arms[id].level
}*/

func (this *_ArmManager) GetInitProbOfLevel(quality int, level int) (prob int) {
	if level < 0 {
		return 0
	}
	if level > MaxCardLevel {
		return 0
	}

	if level == MaxCardLevel {
		return CardEvolvePro[quality]
	}

	return CardUpdatePro[level]
}

func (this *_ArmManager) AddNewArm(id int, level int) error {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	prob := this.GetInitProbOfLevel(ArmInfo[id].QualityLevel, level)
	this.arms[id] = _Arm{level: level, prob: prob}
	this.user.Debug("New id and level and prob is", id, level, prob)

	_, err := redis.Bool(dbconn.Do("SADD", this.user.GetUidUsedInDB()+":arms", id))
	if err != nil {
		this.user.Error("Failed SADD", err)
		return err
	}
	//if !flag {
	//return errors.New("Failed add the same arm id and level")
	//}

	_, err = dbconn.Do("HMSET", this.user.GetUidUsedInDB()+":arm:"+strconv.Itoa(id), "level", level, "prob", prob)
	if err != nil {
		this.user.Error("Failed HMSET", err)
		return err
	}

	err = this.addToNewArm(id)
	if err != nil {
		this.user.Error("Failed addToNewArm", err)
		return err
	}

	err = this.addArmToSeen(id)
	if err != nil {
		this.user.Error("Faild addArmToSeen", err)
		return err
	}

	err = this.user.RefreshCombatScore()
	if err != nil {
		this.user.Error("Failed RefreshCombatScore In AddNewArm", err)
		return err
	}

	err = this.user.quest.InspectQuest(QuestType_CollectSpecArm, HeroInfo[id].OriginalId, 0)
	if err != nil {
		this.user.Error("Failed QuestType_CollectSpecArm", err)
		return err
	}

	err = this.user.quest.InspectQuest(QuestType_CollectArmWithSoul, HeroInfo[id].OriginalId, 0)
	if err != nil {
		this.user.Error("QuestType_CollectArmWithSoul", err)
		return err
	}

	err = this.user.quest.InspectQuest(QuestType_CollectArmCount, HeroInfo[id].OriginalId, 0)
	if err != nil {
		this.user.Error("Failed QuestType_CollectArmCount", err)
		return err
	}
	return nil
}

func (this *_ArmManager) addToNewArm(id int) error {
	this.n_arms[id] = true
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	_, err := dbconn.Do("SADD", this.user.GetUidUsedInDB()+":new_arm", id)
	if err != nil {
		return err
	}
	return nil
}

//TODO
func (this *_ArmManager) AddArmOidToUnseen(oid int) error {
	return nil
}

func (this *_ArmManager) addArmToSeen(id int) error {
	oid := ArmInfo[id].OriginalId

	if this.allarmoid[oid] == ArmUnchargeSeen {
		return nil
	}

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	this.allarmoid[oid] = ArmUnchargeSeen
	_, err := dbconn.Do("LSET", this.user.GetUidUsedInDB()+":allarm", oid, ArmUnchargeSeen)
	if err != nil {
		return err
	}

	return nil
}

func (this *_ArmManager) DelFromNewArm(star int) error {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	for id, _ := range this.n_arms {
		if ArmInfo[id].StarsNeed != star {
			continue
		}
		delete(this.n_arms, id)
		dbconn.Do("SREM", this.user.GetUidUsedInDB()+":new_arm", id)
	}

	return nil
}

func (this *_ArmManager) DelOldArm(id int) (err error) {
	delete(this.arms, id)

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	//dbconn.Send("MULTI")
	_, err = dbconn.Do("SREM", this.user.GetUidUsedInDB()+":arms", id)
	_, err = dbconn.Do("DEL", this.user.GetUidUsedInDB()+":arm:"+strconv.Itoa(id))
	//_, err = dbconn.Do("EXEC")
	if err != nil {
		return err
	}

	return nil
}

func (this *_ArmManager) UpdateArmLevel(id int) (flag bool, err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	flag = util.IsProbabilityHappen(this.arms[id].prob)
	this.user.Debug("The prob and flag is", this.arms[id].prob, flag)
	if !flag {
		tmp := this.arms[id]
		tmp.prob += 5
		this.arms[id] = tmp

		_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":arm:"+strconv.Itoa(id), "prob", tmp.prob)
		if err != nil {
			return false, err
		}
		return false, nil
	}

	tmp := this.arms[id]
	tmp.level += 1
	tmp.prob = this.GetInitProbOfLevel(ArmInfo[id].QualityLevel, tmp.level)
	this.arms[id] = tmp

	_, err = dbconn.Do("HMSET", this.user.GetUidUsedInDB()+":arm:"+strconv.Itoa(id), "level", tmp.level, "prob", tmp.prob)
	if err != nil {
		return false, err
	}

	err = this.user.AddCombatScore(1)
	if err != nil {
		this.user.Error("Failed AddCombatScore In UpdateArmLevel", err)
		return
	}

	return true, nil
}

func (this *_ArmManager) EvolveArm(id int) (new_id int, err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	if !util.IsProbabilityHappen(this.arms[id].prob) {
		tmp := this.arms[id]
		tmp.prob += 10
		this.arms[id] = tmp

		_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":arm:"+strconv.Itoa(id), "prob", tmp.prob)
		if err != nil {
			return -1, err
		}
		return -1, nil
	}

	oid := ArmInfo[id].OriginalId
	quality := ArmInfo[id].QualityLevel
	star := ArmInfo[id].StarsNeed

	level := this.user.GetLevel()
	if quality >= OptEvoQualityOfLevel[level] {
		return 0, nil
	}

	quality++
	new_id = ArmOriginalId[oid][quality]
	if new_id == 0 {
		return 0, nil
	}

	err = this.DelOldArm(id)
	if err != nil {
		return 0, err
	}

	err = this.AddNewArm(new_id, 1)
	if err != nil {
		return 0, err
	}

	err = this.user.quest.InspectQuest(QuestType_ArmEvolveSpecQuality, quality, star)
	if err != nil {
		this.user.Error("Failed QuestType_ArmEvolveSpecQuality", err)
		return
	}

	err = this.user.AddCombatScore(5)
	if err != nil {
		this.user.Error("Failed AddCombatScore In EvolveArm", err)
		return
	}

	return new_id, nil
}

func (this *_ArmManager) ArmCollectCalculate(star int, quality int) int {
	var total int
	var seen int
	var oid int
	for i := int(0); i < ArmOidStarAndQualityCount[star][quality]; i++ {
		oid = ArmOidIndex[ArmOidStarAndQualityBegin[star][quality]+i]

		if this.allarmoid[oid] == ArmUnchargeSeen {
			seen++
		}
		if this.allarmoid[oid] != ArmUnGet {
			total++
		}
	}

	if total != 0 {
		return seen * 100 / total
	} else {
		return 0
	}
}

func (this *_ArmManager) GetAnyArmOfGivenStarAndQuality(star int, quality int) int {
	var arms RandomArms
	for i := 0; i < ArmOidStarAndQualityCount[star][quality]; i++ {
		oid := ArmOidIndex[ArmOidStarAndQualityBegin[star][quality]+i]

		if this.allarmoid[oid] != ArmUnGet {
			arms.Arms[arms.Count] = oid
			arms.Count++
		}
	}
	if arms.Count == 0 {
		return 0
	} else {
		index := util.GetRandomNum(arms.Count)
		oid := arms.Arms[index]

		this.user.Debug("The count and index and oid and id is", arms.Count, arms.Arms, index, oid, ArmMinIdOfOid[oid])
		return ArmMinIdOfOid[oid]
	}
}

func (this *_ArmManager) GetVisibleArmOfGivenStarAndQuality(star int, quality int) int {
	var arms RandomArms
	for i := 0; i < ArmOidStarAndQualityCount[star][quality]; i++ {
		oid := ArmOidIndex[ArmOidStarAndQualityBegin[star][quality]+i]

		if this.allarmoid[oid] == ArmUnchargeSeen {
			arms.Arms[arms.Count] = oid
			arms.Count++
		}

		if this.allarmoid[oid] == ArmChargeSeen {
			if this.user.GetChargeNum() != 0 {
				arms.Arms[arms.Count] = oid
				arms.Count++
			}
		}
	}
	if arms.Count == 0 {
		return 0
	} else {
		index := util.GetRandomNum(arms.Count)
		oid := arms.Arms[index]
		return ArmMinIdOfOid[oid]
	}
}

func (this *_ArmManager) GetInvisibleArmOfGivenStarAndQuality(star int, quality int) int {
	var arms RandomArms
	for i := int(0); i < ArmOidStarAndQualityCount[star][quality]; i++ {
		oid := ArmOidIndex[ArmOidStarAndQualityBegin[star][quality]+i]

		if this.allarmoid[oid] == ArmUnseen {
			arms.Arms[arms.Count] = oid
			arms.Count++
		}

		if this.allarmoid[oid] == ArmChargeSeen {
			if this.user.GetChargeNum() == 0 {
				arms.Arms[arms.Count] = oid
				arms.Count++
			}
		}
	}
	if arms.Count == 0 {
		return 0
	} else {
		index := util.GetRandomNum(arms.Count)
		oid := arms.Arms[index]
		return ArmMinIdOfOid[oid]
	}
}

func (this *_ArmManager) IsOwned(id int) bool {
	_, ok := this.arms[id]
	return ok
}

func (this *_ArmManager) Verify(id_level int) bool {
	id := id_level >> 8
	level := id_level & 0x0f

	v, ok := this.arms[id]

	if !ok {
		return false
	}

	if v.level != level {
		return false
	}

	return true
}

func (this *_ArmManager) IsKindOwned(id int) bool {
	oid := ArmInfo[id].OriginalId
	for _, id_tmp := range ArmOriginalId[oid] {
		if id_tmp == 0 {
			continue
		}
		if this.IsOwned(id_tmp) {
			return true
		}
	}
	return false
}

func (this *_ArmManager) ProcessNewGetArm(id int) (Type int, Value int, Extra int, err error) {
	if id == 0 {
		return 0, 0, 0, nil
	}

	flag := this.IsKindOwned(id)
	if !flag {
		//not exist
		Type = NewCard
		Value = 0
		err = this.AddNewArm(id, 1)
		return
	} else {
		//exist
		Type, Value, Extra, err = this.smashArmCard(id)
		return
	}

	return
}

func (this *_ArmManager) getSmashType() int {
	count := this.user.GetCardCount()
	if count == 3 {
		return SmashCardToGold
	}

	if count == 4 {
		return SmashCardToWeaponChip
	}

	if count == 5 {
		return SmashCardToArmCurr
	}
	//var SmashTypeProb = []int{7, 79, 100}

	num := util.GetRandomNumOf100()

	var vec []int
	if this.user.Hero.IsAnyWeaponChipLackOf() {
		vec = SmashTypeProbWithWeaponChip
	} else {
		vec = SmashTypeProb
	}

	this.user.Debug("arm getSmashType weaponChip", this.user.Hero.IsAnyWeaponChipLackOf())
	for index, v := range vec {
		if num > v {
			continue
		}
		switch index {
		case 0:
			return SmashCardToStone
		case 1:
			return SmashCardToGold
		case 2:
			return SmashCardToArmCurr
		case 3:
			return SmashCardToWeaponChip
		}
	}
	return SmashCardToGold
}

func (this *_ArmManager) smashArmCard(id int) (smash_type, num, Extra int, err error) {
	smash_type = this.getSmashType()
	var reward_type int

	switch smash_type {
	case SmashCardToStone:
		reward_type = RewardType_Stone
		num = ArmInfo[id].QualityLevel*50 + 400

	case SmashCardToGold:
		reward_type = RewardType_Gold
		num = ArmInfo[id].QualityLevel * 500

	case SmashCardToArmCurr:
		reward_type = RewardType_ArmCurr
		num = ArmInfo[id].QualityLevel * 25

	case SmashCardToWeaponChip:
		reward_type = RewardType_WeaponChip
		num = 1
	}

	var event_flag bool
	if this.user.IsSmashStoneDouble() {
		num = num * 2
		event_flag = true
	} else if this.user.IsSmashStoneTriple() {
		num = num * 3
		event_flag = true
	}

	this.user.Debug("smashArmCard", reward_type, num)
	_, Extra, err = this.user.ProcessReward(reward_type, num)
	if err != nil {
		return
	}

	if event_flag {
		err = this.user.AddEventCount()
		if err != nil {
			return
		}
	}
	return
}

func (this *_ArmManager) GetAllArms() []CardBack {
	arm := make([]CardBack, len(this.arms))
	index := 0
	for id, v := range this.arms {
		arm[index].Id = id
		arm[index].Level = v.level
		arm[index].Prob = v.prob
		index++
	}
	return arm
}

func (this *_ArmManager) GetNewArm() []int {
	arm := make([]int, len(this.n_arms))
	index := 0
	for id, _ := range this.n_arms {
		arm[index] = id
		index++
	}
	return arm
}

func (this *_ArmManager) GetAllArmId() []int {
	arm := make([]int, len(this.arms))
	index := 0
	for id, _ := range this.arms {
		arm[index] = id
		index++
	}
	return arm
}

func (this *_ArmManager) GetArmCountOfStar(star int) int {
	count := 0
	for id, _ := range this.arms {
		if ArmInfo[id].StarsNeed == star {
			count++
		}
	}
	return count
}

func (this *_ArmManager) GetArmLevelUpProb(id int) int {
	return this.arms[id].prob
}

func (this *_ArmManager) CanArmEvolve(id int) bool {
	if this.arms[id].level >= MaxCardLevel {
		return true
	}
	return false
}

func (this *_ArmManager) GetCombatScore() (s int) {
	for id, v := range this.arms {
		s += ((ArmInfo[id].QualityLevel-1)*5 + v.level)
	}
	return s
}

func (this *_ArmManager) GetArmCount() int {
	return len(this.arms)
}

func (this *_ArmManager) GetFormationArms() []int {
	length := 0
	for _, v := range this.formation {
		if v != 0 {
			length++
		}
	}

	if length == 0 {
		return nil
	}

	ids := make([]int, length)

	index := 0
	for _, v := range this.formation {
		if v != 0 {
			ids[index] = v
			index++
		}
	}
	return ids
}

func (this *_ArmManager) GetArmLevel(id int) int {
	_, ok := this.arms[id]
	if ok {
		return this.arms[id].level
	}
	return 1
}

var (
	FixedArmStarCoef = []int{0, 1, 2, 4, 6}
	ArmLevelBaseCoef = []int{0, 100, 125, 150, 200, 250, 300, 375, 450, 0}
)

func (this *_ArmManager) GetArmUpdatePrice(id int) (Type, Value int) {
	if this.CanArmEvolve(id) {
		Type = RewardType_ArmCurr
		Value = QualityCoef[ArmInfo[id].QualityLevel] * FixedArmStarCoef[ArmInfo[id].StarsNeed] * 100
	} else {
		Type = RewardType_Gold
		//base := 100 + ((this.GetArmLevel(id)-1)/3+1)*25
		base := ArmLevelBaseCoef[this.GetArmLevel(id)]
		Value = QualityCoef[ArmInfo[id].QualityLevel] * FixedArmStarCoef[ArmInfo[id].StarsNeed] * base
	}
	return
}

//UserSetArmEquip 设置小兵装备 op 131
func UserSetArmEquip(sess *Session, reader []byte) bool {
	type Data struct {
		Lists []struct {
			DstID int
			Equip []int
		}
	}
	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}
	sess.Debug("UserSetArmEquip", msg)
	fails := make(map[int]bool)
	for i := range msg.Lists {
		_, ok := sess.user.Arm.arms[msg.Lists[i].DstID]
		if !ok {
			sess.Error("not find arm id", msg.Lists[i].DstID)
			fails[msg.Lists[i].DstID] = true
			continue
		}
		if len(msg.Lists[i].Equip) != 3 {
			fails[msg.Lists[i].DstID] = true
			continue
		}
		for j := 0; j < 3; j++ {
			if msg.Lists[i].Equip[j] > 0 {
				_, ok := sess.user.Arm.arms[msg.Lists[i].Equip[j]]
				if !ok {
					sess.Error("not find arm id in systemdata", msg.Lists[i].Equip[j])
					fails[msg.Lists[i].DstID] = true
					continue
				}
			}
		}
		conf, ok := ArmInfo[msg.Lists[i].DstID]
		if conf.QualityLevel < 2{
			//绿色品质才可以装备 need >= 2
			sess.Error("arm qualify not valid", conf.QualityLevel, msg.Lists[i].DstID)
			fails[msg.Lists[i].DstID]=true
			continue
		}
		if msg.Lists[i].Equip[0] > 0 {
			for j := range conf.EGrid1UnlockQuests {
				if !sess.user.quest.IsQuestFinished(msg.Lists[i].Equip[0], conf.EGrid1UnlockQuests[j]) {
					sess.Error("arm equip quest not finish", msg.Lists[i].Equip[0], conf.EGrid1UnlockQuests[j])
					fails[msg.Lists[i].DstID] = true
					continue
				}
			}
		}
		if msg.Lists[i].Equip[1] > 0 {
			for j := range conf.EGrid2UnlockQuests {
				if !sess.user.quest.IsQuestFinished(msg.Lists[i].Equip[1], conf.EGrid2UnlockQuests[j]) {
					sess.Error("arm equip quest not finish", msg.Lists[i].Equip[1], conf.EGrid2UnlockQuests[j])
					fails[msg.Lists[i].DstID] = true
					continue
				}
			}
		}
		if msg.Lists[i].Equip[2] > 0 {
			for j := range conf.EGrid3UnlockQuests {
				if !sess.user.quest.IsQuestFinished(msg.Lists[i].Equip[2], conf.EGrid3UnlockQuests[j]) {
					sess.Error("arm equip quest not finish", msg.Lists[i].Equip[2], conf.EGrid3UnlockQuests[j])
					fails[msg.Lists[i].DstID] = true
					continue
				}
			}
		}
	}
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	back := make(map[string]interface{})
	table := sess.user.GetUidUsedInDB() + ":armEquip"
	_, err = dbconn.Do("DEL", table)
	if err != nil {
		sess.Error("del user:armEquip error ", err)
		return false
	}
	sess.user.Arm.armEquip = make(map[int][3]int)
	for i := range msg.Lists {
		if _, fail := fails[msg.Lists[i].DstID]; !fail {
			var tmp [3]int = [3]int{
				msg.Lists[i].Equip[0], msg.Lists[i].Equip[1], msg.Lists[i].Equip[2],
			}
			sess.user.Arm.armEquip[msg.Lists[i].DstID] = tmp
			_, err = dbconn.Do("HSET", table, msg.Lists[i].DstID, fmt.Sprintf("%v:%v:%v", msg.Lists[i].Equip[0], msg.Lists[i].Equip[1], msg.Lists[i].Equip[2]))
			if err != nil {
				fails[msg.Lists[i].DstID] = true
				sess.Error("db error ", err)
			}
			sess.Debug("set arm equip", sess.user.Arm.armEquip)
		}
	}
	v := make([]int, 0)
	for k, _ := range fails {
		v = append(v, k)
	}
	back["Lists"] = v
	return sess.SendReplyBack(back, 131)
}
