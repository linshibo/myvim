package asynserver

import (
    //"encoding/binary"
    "fmt"
    "io"
    "net"
    "os"
    "runtime"
    "sanguo/base/log"
    "strings"
    //"sync"
    //"time"
)

const (
    keepAliveTime = 10
    maxPackageLen = 1024 * 10
)

type Callback struct {
    //收到包回调
    IPCMessageCallback func(sess *Session, data []byte) bool
    //收到包回调
    MessageCallback func(sess *Session, data []byte) bool
    //连接关闭回调
    CloseCallback func(sess *Session)
    //调用者根据头部信息返回包体长度
    GetSizeCallback func(header []byte) int
    //目标地址host example: 192.168.1.1:8888
    Host string
}

func init() {
    runtime.GOMAXPROCS(runtime.NumCPU())
}

type Session struct {
    IP       net.IP
    Conn     net.Conn    //the tcp connection from client
    RecvChan chan []byte //data from client
    IPCChan  chan []byte //internet process connection message
    SendChan chan []byte //data to client
    ErrChan  chan bool
}

func (sess *Session) Close(handler Callback) {
    defer func() {
        if x := recover(); x != nil {
            log.Warn("close Panic, the panic is", x)
        }
    }()
    //log.Debug("sess Close start ", sess.ok)
    if sess.Conn.Close() != nil {
        close(sess.RecvChan)
        close(sess.IPCChan)
        close(sess.SendChan)
        close(sess.ErrChan)
    }
    handler.CloseCallback(sess)

    //log.Debug("sess Close end ", sess.ok)
}

func handleSend(client *Session, handler Callback) {
    defer func() {
        if x := recover(); x != nil {
            log.Warn("send Panic, the panic is", x)
        }
        client.Close(handler)
    }()
    //发送协程
    for {
        select {
        case msg, ok := <-client.SendChan:
            if !ok {
                return
            }
            _, err := client.Conn.Write(msg)
            if err != nil {
                log.Error(err)
                break
            }
        }
    }
}

func handleRecv(client *Session, handler Callback) {
    defer func() {
        //client.Conn.Close()
        if x := recover(); x != nil {
            log.Warn("recv Panic, the panic is", x)
        }
        client.Close(handler)
    }()
    for {
        //接受数据 调用回调
        select {
        case msg, ok := <-client.RecvChan:
            if !ok {
                // the cmd channel is closed by the other side
                log.Error("The channel is closed by the other side")
                return
            }
            //log.Debug(string(msg))
            if !handler.MessageCallback(client, msg) {
                //if process error player need load again
                log.Error("dispatch error ")
                return
            }
        case msg, ok := <-client.IPCChan:
            if !ok {
                // the cmd channel is closed by the other side
                log.Error("The channel is closed by the other side")
                return
            }
            if !handler.IPCMessageCallback(client, msg) {
                //if process error player need load again
                log.Error("ipc dispatch error ")
                //fmt.Println("ipc dispatch error ")
            }
            //case <-time.After(20 * time.Second):
            //fmt.Println("Timeout and will close")
            //runtime.Goexit()
        }
    }
}

func createSession(conn net.Conn) *Session {
    log.Debug("new connection", conn.RemoteAddr().String())
    var client Session
    client.IP = net.ParseIP(strings.Split(conn.RemoteAddr().String(), ":")[0])
    client.Conn = conn
    client.RecvChan = make(chan []byte, 1024)
    client.IPCChan = make(chan []byte, 1024)
    client.SendChan = make(chan []byte, 1024)
    return &client
}

func handleConn(sess *Session, handler Callback) {
    header := make([]byte, 2)
    defer func() {
        if x := recover(); x != nil {
            log.Warn("handleConn Panic, the panic is", x)
        }
        sess.Close(handler)
    }()
    go handleRecv(sess, handler)
    go handleSend(sess, handler)
    for {
        //poll
        n, err := io.ReadFull(sess.Conn, header)
        if n == 0 && err == io.EOF {
            //Opposite socket is closed
            log.Debug("peer socket is closed")
            break
        } else if err != nil {
            //Sth wrong with this socket
            log.Debug(err)
            break
        }
        //size := binary.LittleEndian.Uint16(header) + 4
        size := handler.GetSizeCallback(header)
        data := make([]byte, size)
		//log.Debug("size ", size, sess.Conn.RemoteAddr())
        n, err = io.ReadFull(sess.Conn, data[0:size])
        if n == 0 && err == io.EOF {
            fmt.Println("peer socket is closed ", err)
            break
        } else if err != nil {
            fmt.Println(err)
            break
        }
        //log.Debug(string(data[0:size]))
        sess.RecvChan <- data[0:size] //send data to Client to process
    }
}

//func cliHandleConn(sess *Session) {
//header := make([]byte, 2)
//defer sess.Conn.Close()
//defer func() {
//if x := recover(); x != nil {
//log.Warn("cliHandleConn Panic, the panic is", x)
//}
//sess.ErrChan <- true
//}()
//for {
//n, err := io.ReadFull(sess.Conn, header)
//if n == 0 && err == io.EOF {
////Opposite socket is closed
////fmt.Println("peer socket is closed")
//log.Debug("peer socket is closed")
//break
//} else if err != nil {
////Sth wrong with this socket
//log.Debug(err)
////fmt.Println(err)
//break
//}
//size := binary.LittleEndian.Uint16(header) + 4
////size := handler.GetSizeCallback(header)
//data := make([]byte, size)
//n, err = io.ReadFull(sess.Conn, data[0:size])
//if n == 0 && err == io.EOF {
////fmt.Println("peer socket is closed")
//log.Debug("peer socket is closed")
//break
//} else if err != nil {
////fmt.Println(err)
//log.Debug(err)
//break
//}
//sess.RecvChan <- data //send data to Client to process
//}
//}

//func connectKeepAlive(conn net.Conn, t int) {
//var interval int
//if t > 0 {
//interval = t
//} else {
//interval = keepAliveTime
//}
//ticker := time.NewTicker(time.Second * time.Duration(interval))
//data := make([]byte, 6)
//for t := range ticker.C {
//_, err := conn.Write(data)
//if err != nil {
//fmt.Println(t, err)
//break
//}
//}
//}

//func ConnectToServer(host string, keepalive int) (bool, *Session) {
//conn, err := net.Dial("tcp", host)
//if err != nil {
////fmt.Println("error connect", host, err.Error())
//log.Debug("error connect", host, err.Error())
//return false, nil
//}
//sess := createSession(conn)
//go cliHandleConn(sess)
//go connectKeepAlive(conn, keepalive)
//return true, sess
//}

func StartServer(h Callback) {
    defer func() {
        if x := recover(); x != nil {
            log.Warn("cliHandleConn Panic, the panic is", x)
        }
    }()
    listener, err := net.Listen("tcp", h.Host)
    if err != nil {
        fmt.Println("fatal error listening:", err)
        log.Error("fatal error listening:", err)
        os.Exit(1)
    }
    defer listener.Close()
    fmt.Println("asynServer start listening:", h.Host)
    for {
        conn, err := listener.Accept()
        if err != nil {
            fmt.Println("fail accept", err)
            log.Error("fail accept", err)
            continue
        }
        sess := createSession(conn)
        go handleConn(sess, h)
    }
}
