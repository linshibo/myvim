package gameserver

import (
	"encoding/json"
	"github.com/garyburd/redigo/redis"
	"math/rand"
	"sanguo/base/log"
	"sanguo/db"
	. "sanguo/systemdata"
	"strconv"
	"strings"
	"sync"
	"time"
)

type _PlayerManager struct {
	online       map[int]*Session
	online_count int
	online_lock  sync.RWMutex

	//TODO   Not Sure about Mutex
	all map[int]*User

	// id mean mid and gid, one uid may have two id
	ids map[string]int

	//
	name map[string]int
}

var PlayerManager *_PlayerManager

func NewPlayerManager() *_PlayerManager {
	var p _PlayerManager
	p.all = make(map[int]*User)
	p.online = make(map[int]*Session)
	p.ids = make(map[string]int)
	p.name = make(map[string]int)

	return &p
}

func init() {
	PlayerManager = NewPlayerManager()
}

func (this *_PlayerManager) GetUidById(id string) int {
	return this.ids[id]
}

//func ()

func (this *_PlayerManager) GetUserByUid(uid int) *User {
	/*if this.all[uid] == nil {
		userid := "user:" + strconv.Itoa(uid)
		err := this.LoadPlayer(userid)
		if err != nil {
			log.Error("Failed __LoadPlayer", err)
			return nil
		}
	}*/

	return this.all[uid]
}

func (this *_PlayerManager) ChangeName(o, n string) {
	uid := this.name[o]

	delete(this.name, o)

	this.name[n] = uid

	return
}

func (this *_PlayerManager) GetUidByName(n string) int {
	log.Debug("name and n is", this.name, n)
	log.Debug("return is", this.name[n])
	return this.name[n]
}

func (this *_PlayerManager) IsIdExist(id string) bool {
	_, ok := this.ids[id]
	return ok
}

func (this *_PlayerManager) QueryOnline(uid int) *Session {
	defer this.online_lock.RUnlock()
	this.online_lock.RLock()

	return this.online[uid]
}

func (this *_PlayerManager) GetRandPlayer() *User {
	defer this.online_lock.RUnlock()
	this.online_lock.RLock()
	//在线
	r := rand.New(rand.NewSource(time.Now().UnixNano())).Intn(len(this.online))
	i := 0
	for _, v := range this.online {
		if i == r {
			return v.user
		} else {
			i++
		}
	}
	//不在线
	r = rand.Intn(len(this.all))
	i = 0
	for _, v := range this.all {
		if i == r {
			return v
		} else {
			i++
		}
	}
	return nil
}

func (this *_PlayerManager) QueryOnlineString(userid string) *Session {
	uid, err := strconv.Atoi(strings.Split(userid, ":")[1])
	if err != nil {
		log.Error("Failed Atoi", err)
	}
	return this.QueryOnline(uid)
}

func (this *_PlayerManager) RegisterOnline(sess *Session, uid int) {
	defer this.online_lock.Unlock()
	this.online_lock.Lock()

	if this.online[uid] != nil && this.online[uid] != sess {
		log.Critical("Will be kickout, The old and new is ", this.online[uid], sess)
		tmp := this.online[uid]
		tmp.Kickout()
	}

	this.online[uid] = sess
	this.all[uid].sess = sess
	this.online_count++
}

func (this *_PlayerManager) UnregisterOnline(uid int, sess *Session) {
	defer this.online_lock.Unlock()
	this.online_lock.Lock()

	if this.online[uid] == sess {
		delete(this.online, uid)
		//delete(this.all, uid)
		//this.online[uid] = nil
		//this.all[uid].sess = nil
	}
	this.online_count--
}

func (this *_PlayerManager) IsNameExistLocal(n string) bool {
	_, ok := this.name[n]
	return ok
}

func (this *_PlayerManager) LoadAllPlayerInTheServerStart() (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	TotalPlayers, err := redis.Strings(dbconn.Do("SMEMBERS", "TotalUser"))
	if err != nil {
		log.Error("Failed get user", err)
		return err
	}

	for _, player := range TotalPlayers {
		err = this.LoadPlayer(player)
		if err != nil {
			log.Error("Failed LoadPlayer", err, player)
			return err
		}
	}
	//log.Debug("hags", this.name)
	return nil
}

func (this *_PlayerManager) LoadPlayer(userid string) (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	user := NewUser()

	uid_ := strings.Split(userid, ":")[1]
	uid, _ := strconv.Atoi(uid_)
	user.uid = uid

	reply2, err := redis.Values(dbconn.Do("HMGET", GetUidUseInDB(uid), "mid", "gid", "level", "name", "gold", "power", "chapter",
		"c_guanqia", "s_guanqia", "stone", "last_login", "last_power_time", "card_count",
		"vip", "photo", "last_login_reward_time", "login_arm_given", "login_arm", "last_login_arm", "register_time", "stranger_time",
		"event_count", "event_end_count", "event_end_time", "event_id", "lock_chapter", "lock_start_time", "max_power", "heroVIP", "mid",
		"gid", "sign_last", "sign_count", "box_count", "box_get_time", "arm_curr", "hero_curr", "convenedBossID", "shenshou_curr"))
	if err != nil {
		log.Error("Can't get user from redis")
		return err
	}

	index := 0

	user.mid, _ = redis.String(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert mid to string", err, user.uid)
		//return err
	}
	index++

	user.gid, _ = redis.String(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert gid to string", err, user.uid)
		return err
	}
	index++

	user.level, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert level to int", err, GetUidUseInDB(uid))
		return err
	}
	index++

	user.name, err = redis.String(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert name to string ", err, user.uid)
		return err
	}
	index++

	user.gold, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert gold to int", err, user.uid)
		return err
	}
	index++

	user.power, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert power to int", err, user.uid)
		return err
	}
	index++

	user.chapter, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert chapter to int", err, user.uid)
		return err
	}
	index++

	user.c_guanqia, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert c_guanqia to int", err, user.uid)
		return err
	}
	index++

	user.s_guanqia, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert s_guanqia to int", err, user.uid)
		return err
	}
	index++

	user.stone, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert stone to int", err, user.uid)
		return err
	}
	index++

	user.last_login, err = redis.Int64(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert last_login to int", err, user.uid)
		return err
	}
	index++

	user.last_power_time, err = redis.Int64(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert last_power_time to int", err, user.uid)
		return err
	}
	index++

	user.card_count, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert card_count to int", err, user.uid)
		return err
	}
	index++

	user.vip, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert vip to int", err, user.uid)
		return err
	}
	index++

	user.photo, err = redis.String(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert photo to string", err, user.uid)
		return err
	}
	index++

	user.last_login_reward_time, err = redis.Int64(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert photo to string", err, user.uid)
		return err
	}
	index++

	user.login_arm_given, err = redis.Bool(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert photo to string", err, user.uid)
		return err
	}
	index++

	user.login_arm, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert photo to string", err, user.uid)
		return err
	}
	index++

	user.last_login_arm, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert photo to string", err, user.uid)
		return err
	}
	index++

	user.register_time, err = redis.Int64(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert photo to string", err, user.uid)
		return err
	}
	index++

	user.stranger_time, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert stanget_time to int", err, user.uid)
		return err
	}
	index++

	user.event_count, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert event_count to int", err, user.uid)
		return err
	}
	index++

	user.event_end_count, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert event_end_count to int", err, user.uid)
		return err
	}
	index++

	user.event_end_time, err = redis.Int64(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert event_end_time to int", err, user.uid)
		return err
	}
	index++

	user.event_id, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert event_id to int", err, user.uid)
		return err
	}
	index++

	user.lock_chapter, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert lock_chapter to int", err, user.uid)
		return err
	}
	index++

	user.lock_start_time, err = redis.Int64(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert lock_start_time to int64", err, user.uid)
		return err
	}
	index++

	user.max_power, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert max_power to int", err, user.uid)
		return err
	}
	index++

	user.heroVIP, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert heroVIP to int", err, user.uid)
		return err
	}
	index++

	/*user.mid,err = redis.String(reply2[index], nil)
	  if err != nil {
	  	log.Error("Cant convert mid to int", err, user.uid)
	  	return err
	  }*/
	index++

	/*user.gid,err = redis.String(reply2[index], nil)
	  if err != nil {
	  	log.Error("Cant convert gid to int", err, user.uid)
	  	return err
	  }*/
	index++

	user.sign_last_time, err = redis.Int64(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert sign_last_time to int", err, user.uid)
		return err
	}
	index++

	user.sign_count, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert sign_count to int", err, user.uid)
		return err
	}
	index++

	user.box_count, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert box_count to int", err, user.uid)
		return err
	}
	index++

	user.box_get_time, err = redis.Int64(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert box_get_time to int64", err, user.uid)
		return err
	}
	index++

	user.arm_currency, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert arm_currency to int", err, user.uid)
		return err
	}
	index++

	user.hero_currency, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert arm_currency to int", err, user.uid)
		return err
	}
	index++

    user.convenedBossID, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert convenedBossID to int", err, user.uid)
		return err
	}
	index++

    user.shenshou_curr, err = redis.Int(reply2[index], nil)
	if err != nil {
		log.Error("Cant convert shenshou_curr to int", err, user.uid)
		return err
	}
	index++
	
	// Load LoginReward
	for i := 0; i < 3; i++ {
		reply, err := redis.Values(dbconn.Do("HMGET", user.GetUidUsedInDB()+":last_login_reward:"+strconv.Itoa(i), "Type", "Value"))
		if err != nil {
			log.Error("1", user.GetUidUsedInDB())
			return err
		}
		user.last_login_reward[i].Type, err = redis.Int(reply[0], nil)
		if err != nil {
			log.Error("2", user.GetUidUsedInDB())
			return err
		}
		user.last_login_reward[i].Value, err = redis.Int(reply[1], nil)
		if err != nil {
			log.Error("3", user.GetUidUsedInDB())
			return err
		}
	}

	// Load wizards
	reply, err := redis.Values(dbconn.Do("LRANGE", user.GetUidUsedInDB()+":wizards", 0, WizardsLength-1))
	if err != nil {
		log.Error("Can't get user:wizards from redis")
		return err
	}

	log.Debug("The length of wizards is ", len(reply))
	for i := 0; i < len(reply); i++ {
		user.wizards[i], err = redis.Int(reply[i], nil)
		if err != nil {
			log.Error("Can't convert wizards to int", err)
			return err
		}
	}

	// Load stone_flags
	reply3, err := redis.Values(dbconn.Do("LRANGE", user.GetUidUsedInDB()+":stone_get_flag", 0, 3))
	if err != nil {
		user.Error("Can't get user:formation from reis", user.uid)
		return err
	}

	for i := 0; i < len(reply3); i++ {
		user.stone_get_flag[i], err = redis.Int(reply3[i], nil)
		if err != nil {
			log.Error("Can't convert stone_get_flag to int", err, user.uid)
			return err
		}
	}

	err = user.E_Arm.LoadExtraArm()
	if err != nil {
		log.Error("Failed LoadExtraArm", err)
		return err
	}

	err = user.LoadSimpleGuanScore()
	if err != nil {
		log.Error("Failed LoadSimpleGuanScore()", err)
		return err
	}

	err = user.purchase.Load()
	if err != nil {
		log.Error("Failed purchase load", err)
		return err
	}

	err = user.Friends.LoadFriends()
	if err != nil {
		log.Error("Failed LoadFriend", err)
		return err
	}

	err = user.Activity.Load()
	if err != nil {
		log.Error("Failed LoadActivity", err)
		return err
	}

	err = user.quest.Load()
	if err != nil {
		log.Error("Failed LoadQuest", err)
		return err
	}

	err = user.quest.LoadRandomFightQuest()
	if err != nil {
		log.Error("Failed LoadRandomFightQuest", err)
		return err
	}

	err = user.Arm.Load()
	if err != nil {
		log.Error("Failed LoadPlayerArmInfo", err)
		return err
	}

	err = user.Hero.Load()
	if err != nil {
		log.Error("Failed LoadPlayerHeroInfo", err)
		return err
	}

	err = user.LoadUnreward()
	if err != nil {
		log.Error("Failed LoadUnreward", err)
		return err
	}

	err = user.LoadBossInfo()
	if err != nil {
		log.Error("Failed LoadBossInfo", err)
		return err
	}

	err = user.LoadArmEquip()
	if err != nil {
		log.Error("Failed LoadBossInfo", err)
		return err
	}

	this.all[uid] = user
	this.name[user.name] = uid

	if user.gid != "" {
		this.ids[user.gid] = uid
	}

	if user.mid != "" {
		this.ids[user.mid] = uid
	}

	return nil
}

func (this *_PlayerManager) AssignUid(id string) (uid int, err error) {
	dbconn := db.ZonePool.Get()
	defer dbconn.Close()

	uid, err = redis.Int(dbconn.Do("HGET", "gateway:gid2uid", id))
	if err != nil {
		log.Error("Failed get uid", err)
		return
	}
	return
}

func (this *_PlayerManager) AddPlayer(id string) (uid int, err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	user := NewUser()

	uid, err = this.AssignUid(id)
	if err != nil {
		log.Error("Failed AssignUid", err)
		return
	}

	user.uid = uid

	if strings.HasPrefix(id, "G:") {
		user.gid = id
	} else {
		user.mid = id
	}

	user.name = "player" + strconv.Itoa(uid)
	_, err = dbconn.Do("SET", user.name, user.uid)
	if err != nil {
		log.Error("Failed set name", err)
		return
	}

	err = user.RegisterName(user.name)
	if err != nil {
		log.Error("Failed RegisterName", err)
		return
	}

	user.gold = 100
	user.level = 1

	user.power = FullPower + 8
	user.max_power = FullPower
	user.chapter = 1
	user.stone = 200
	user.c_guanqia = ChapterInfo[1].AllCGuanQias[0]
	user.s_guanqia = ChapterGuanQiaInfo[user.c_guanqia].Allsimpleguanqias[0]

	user.last_login = 0
	user.last_power_time = 0
	user.vip = 0
	user.photo = "gui/role_portrait/k2.png"

	user.card_count = 3
	/******boss info***********/
	//user.boss_count = 0
	//user.boss_id = 0
	//user.boss_max_score = 0
	//user.boss_rank = 0
	//user.boss_tg_count = 0
	//user.boss_today_max_score = 0
	//user.last_boss_end_time = 0

	/****** login info *********/
	user.last_login_reward_time = 0
	user.login_arm_given = false
	user.login_arm = 0
	user.last_login_arm = 0
	user.register_time = time.Now().Unix()

	user.event_count = 0
	user.event_end_count = 0
	user.event_end_time = 0
	user.event_id = 0

	user.heroVIP = 0
	user.topic_count = 0
	user.box_count = 0
	user.box_get_time = 0
	user.arm_currency = 0
	user.hero_currency = 0

	_, err = dbconn.Do("HMSET", user.GetUidUsedInDB(), "mid", user.mid, "gid", user.gid, "name", user.name, "level", user.level, "gold", user.gold,
		"power", user.power, "max_power", user.max_power, "chapter", user.chapter,
		"c_guanqia", user.c_guanqia, "s_guanqia", user.s_guanqia, "stone", user.stone, "last_login", user.last_login,
		"last_power_time", user.last_power_time, "card_count", user.card_count, "lock_chapter", 0, "lock_start_time", 0,
		//"boss_id", user.boss_id, "boss_rank", user.boss_rank, "boss_count", user.boss_count, "last_boss_end_time", user.last_boss_end_time,
		//"boss_today_max_score", user.boss_today_max_score, "boss_tg_count", user.boss_tg_count, "boss_max_score", user.boss_max_score,
		"vip", 0, "photo", user.photo, "last_login_reward_time", user.last_login_reward_time, "stranger_time", 0,
		"login_arm_given", user.login_arm_given, "login_arm", user.login_arm, "last_login_arm", user.last_login_arm, "register_time", user.register_time,
		"event_count", user.event_count, "event_end_count", user.event_end_count, "event_end_time", user.event_end_time, "event_id", user.event_id,
		"lock_chapter", 0, "lock_start_time", 0, "heroVIP", 0, "topic_count", 0, "sign_last", 0, "sign_count", 0, "box_count", 0, "box_get_time", 0,
		"arm_curr", 0, "hero_curr", 0, "convenedBossID",0, "shenshou_curr", 0)
	if err != nil {
		log.Error("Can't insert initial user info into redis of", user.uid)
		return
	}

	err = user.Hero.InitHero()
	if err != nil {
		log.Error("Failed init Hero info", err)
		return
	}

	err = user.Arm.InitArm()
	if err != nil {
		log.Error("Failed init Arm info", err)
		return
	}

	//Init LastLoginReward
	for i := 0; i < 3; i++ {
		user.last_login_reward[i].Type = 0
		user.last_login_reward[i].Value = 0
		_, err = dbconn.Do("HMSET", user.GetUidUsedInDB()+":last_login_reward:"+strconv.Itoa(i), "Type", 0, "Value", 0)
		if err != nil {
			log.Error("Failed InitLastLogin", err)
			return
		}
	}

	//Init StoneGetFlag
	_, err = dbconn.Do("RPUSH", user.GetUidUsedInDB()+":stone_get_flag", 0, 0, 0, 0)
	if err != nil {
		log.Error("Failed InitStoneFlag", err)
		return
	}

	//Init Wizards
	_, err = dbconn.Do("RPUSH", user.GetUidUsedInDB()+":wizards", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
	if err != nil {
		log.Error("Failed InitWizards", err)
		return
	}

	err = user.purchase.Init()
	if err != nil {
		log.Error("Failed purchase", err)
		return
	}

	err = user.Friends.InitFriend()
	if err != nil {
		log.Error("Failed InitFriend", err)
		return
	}

	_, err = dbconn.Do("SADD", "TotalUser", user.GetUidUsedInDB())
	if err != nil {
		log.Error("Failed SADD AllUser", err)
		return
	}

	this.all[uid] = user
	this.ids[id] = uid
	this.name[user.name] = uid

	return
}

func GetNameByUID(uid int) (name string) {
	user := PlayerManager.GetUserByUid(uid)
	if user != nil {
		return user.name
	}
	return ""
}

func GetPhotoByUID(uid int) string {
	user := PlayerManager.GetUserByUid(uid)
	if user != nil {
		return user.photo
	}
	return ""
}

func GetArmCountByUID(uid int) int {
	user := PlayerManager.GetUserByUid(uid)
	if user != nil {
		return user.Arm.GetArmCount()
	}
	return 0
}

func GetHeroCountByUID(uid int) int {
	user := PlayerManager.GetUserByUid(uid)
	if user != nil {
		return user.Hero.GetHeroCount()
	}
	return 0
}

type BackArmInfo struct {
	ID    int
	Level int
}

type BackHeroInfo struct {
	ID    int
	Level int
	Flag  int
}

func GetHerosByUID(uid int) []BackHeroInfo {

	user := PlayerManager.GetUserByUid(uid)
	if user == nil {
		return nil
	}

	/*all_heros := user.Hero.GetAllHeros()

	if len(all_heros) > 4 {
		//		for _, v := range all_heros {
		//
		//		}
	}

	back := make([]BackHeroInfo, len(all_heros))
	index := 0
	for _, v := range all_heros {
		back[index].ID = v.Id
		back[index].Level = v.Level
		back[index].Flag = v.Flag
		index++
	}
	return back*/

	return user.Hero.GetHeroOfTopN(4)

}

func GetFormationArmByUID(uid int) []BackArmInfo {
	user := PlayerManager.GetUserByUid(uid)
	if user == nil {
		return nil
	}
	ids := user.Arm.GetFormationArms()
	length := len(ids)
	if length == 0 {
		return nil
	}
	back := make([]BackArmInfo, length)

	index := 0
	for _, id := range ids {
		back[index].ID = id
		back[index].Level = user.Arm.GetArmLevel(id)
		index++
	}

	return back
}

func (this *_PlayerManager) IsUserLocal(uid int) bool {
	_, ok := this.all[uid]
	return ok
}
func GetFormationArmByUID_Globle(src_uid, dest_uid int) []BackArmInfo {
	if PlayerManager.IsUserLocal(dest_uid) {
		return GetFormationArmByUID(dest_uid)
	}

	var msg IPCMsg
	msg.DestID = dest_uid
	msg.SrcID = src_uid
	msg.Op = 3
	msg.Time = GetCurrentTime()

	response := CallAPIHub(&msg, 3)

	var back []BackArmInfo
	err := json.Unmarshal(response, back)
	if err != nil {
		log.Error("Failed decode json", err)
		return nil
	}
	return back
}

func GetRandomHeroByUIDLocal(dest_uid int) (back BackHeroInfo) {
	user := PlayerManager.GetUserByUid(dest_uid)
	if user != nil {
		return user.Hero.GetRandomHero()
	}

	return
}

func GetRandomHeroByUID(src_uid, dest_uid int) (back BackHeroInfo) {
	if PlayerManager.IsUserLocal(dest_uid) {
		return GetRandomHeroByUIDLocal(dest_uid)
	}

	var msg IPCMsg
	msg.DestID = dest_uid
	msg.SrcID = src_uid
	msg.Op = 111
	msg.Time = GetCurrentTime()

	response := CallAPIHub(&msg, 3)

	err := json.Unmarshal(response, &back)
	if err != nil {
		log.Error("Failed decode json", err)
		return
	}
	return back
}

func GetPlayerSimpleGuanqiaByUid_Local(dest_uid int) int {
	user := PlayerManager.GetUserByUid(dest_uid)
	if user != nil {
		return user.s_guanqia
	}

	return 0
}

func GetPlayerSimpleGuanqiaByUid(src_uid, dest_uid int) int {
	if PlayerManager.IsUserLocal(dest_uid) {
		return GetPlayerSimpleGuanqiaByUid_Local(dest_uid)
	}

	var msg IPCMsg
	msg.DestID = dest_uid
	msg.SrcID = src_uid
	msg.Op = 113
	msg.Time = GetCurrentTime()

	response := CallAPIHub(&msg, 3)
	log.Debug("The response is", string(response))

	var back BackPlayerInfo
	err := json.Unmarshal(response, &back)
	if err != nil {
		log.Error("Failed decode json", err)
		return 0
	}
	return back.Sid
}

func GetPlayerPhotoByUid_Local(uid int) string {
	user := PlayerManager.GetUserByUid(uid)
	if user != nil {
		return user.photo
	}

	return ""
}

func GetPlayerPhotoByUid(src_uid, dest_uid int) string {
	if PlayerManager.IsUserLocal(dest_uid) {
		return GetPlayerPhotoByUid_Local(dest_uid)
	}

	var msg IPCMsg
	msg.DestID = dest_uid
	msg.SrcID = src_uid
	msg.Op = 113
	msg.Time = GetCurrentTime()

	response := CallAPIHub(&msg, 3)
	log.Debug("The response is", string(response))

	var back BackPlayerInfo
	err := json.Unmarshal(response, &back)
	if err != nil {
		log.Error("Failed decode json", err)
		return ""
	}
	return back.Photo
}
