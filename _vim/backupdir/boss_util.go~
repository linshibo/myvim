package gameserver

import (
	//"encoding/json"
	"github.com/garyburd/redigo/redis"
	"sanguo/db"
	//"sanguo/base/log"
	//"sanguo/base/packet"
	//"errors"
	"errors"
	. "sanguo/systemdata"
	"strconv"
	"time"
)

const CD_Time = 30 * 60

type bossData struct {
	Boss_tg_count  int
	Boss_id        int
	Boss_rank      int
	Boss_left_time int
	Boss_pass      int
	Boss_count     int
	Boss_max_score int
}

func (sess *Session) GetAllBossInfo() []bossData {
	bossInfoSlice := make([]bossData, 0)
	sess.Debug("GetAllBossInfo", sess.user.bossInfos)
	for _, v := range sess.user.bossInfos {
		var d bossData
		d.Boss_tg_count = v.boss_tg_count
		d.Boss_id = v.boss_id
		d.Boss_rank = v.boss_rank
		d.Boss_left_time = sess.GetLeftTimeToBossFight(v.boss_id)
		d.Boss_pass = v.boss_pass
		d.Boss_count = v.boss_count
		d.Boss_max_score = v.boss_max_score
		bossInfoSlice = append(bossInfoSlice, d)
	}
	sess.Debug(bossInfoSlice)
	return bossInfoSlice
}

func (sess *Session) SetBossIdOfUser(bid int) error {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	//sess.user.boss_id = bid
	//_, err := dbconn.Do("HSET", sess.user.uid, "boss_id", bid)
	boss := new(bossInfo)
	boss.boss_id = bid
	bossKey := "user:bossinfo:" + strconv.Itoa(sess.user.uid) + ":" + strconv.Itoa(boss.boss_id)
	_, err := dbconn.Do("HMSET", bossKey, "boss_id", boss.boss_id, "boss_max_score", 0, "boss_today_max_score", 0, "boss_count", 0, "boss_rank", 0,
		"boss_tg_count", 0, "boss_pass", 0, "last_boss_end_time", 0)
	if err != nil {
		return err
	}
	sess.user.bossInfos[boss.boss_id] = boss

	return err
}

func (sess *Session) UpdateBossInfoInTheFirstLoginOfDay() error {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	sess.Debug("The UpdateBossInfoInTheFirstLoginOfDay Begin ", sess.user.uid)
	for _, v := range sess.user.bossInfos {
		bossKey := "user:bossinfo:" + strconv.Itoa(sess.user.uid) + ":" + strconv.Itoa(v.boss_id)
		v.boss_count = 0
		v.boss_today_max_score = 0
		_, err := dbconn.Do("HMSET", bossKey, "boss_count", v.boss_count, "boss_today_max_score", v.boss_today_max_score)
		if err != nil {
			return err
		}
	}
	return nil
}

func (sess *Session) GetBossReward(boss *bossInfo, score int) ([]RewardBack, error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	sess.Debug("The today_max_score and score is", boss.boss_today_max_score, score, sess.user.uid)
	if boss.boss_today_max_score >= score {
		return nil, nil
	}

	sid := BossGuanQiaInfo[boss.boss_id].ContentGuanQiaId
	var back []RewardBack
	sess.Debug("sid and reward is", sid, GuanqiaInfo[sid].ScoreReward)

	for _, reward := range GuanqiaInfo[sid].ScoreReward {

		if boss.boss_today_max_score > reward.Score {
			continue
		}
		if score < reward.Score {
			continue
		}

		tmp_reward, err := sess.user.ProcessReward(reward.RewardType, reward.Value)
		if err != nil {
			sess.Error("Failed ProcessReward", err, reward.RewardType, reward.Value)
			return nil, err
		}

		back = append(back, tmp_reward)
	}

	boss.boss_today_max_score = score
	bossKey := "user:bossinfo:" + strconv.Itoa(sess.user.uid) + ":" + strconv.Itoa(boss.boss_id)
	_, err := dbconn.Do("HSET", bossKey, "boss_today_max_score", score)
	if err != nil {
		return nil, err
	}
	//sess.user.bossInfos[boss.boss_id] =boss
	sess.Debug("The reward msg is", back, sess.user.uid)
	return back, nil
}

func (sess *Session) UnlockNextBoss(cur int) (int, error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	cur_boss, ok := sess.user.bossInfos[cur]
	if !ok {
		sess.Error("not find bossid", cur)
		return 0, errors.New("not find bossid")
	}
	bossKey := "user:bossinfo:" + strconv.Itoa(sess.user.uid) + ":" + strconv.Itoa(cur)
	_, err := dbconn.Do("HSET", bossKey, "boss_pass", 1)
	if err != nil {
		return 0, err
	}
	cur_boss.boss_pass = 1

	boss := new(bossInfo)
	boss.boss_id = BossGuanQiaInfo[cur].NextBossGuanQiaId
	bossKey = "user:bossinfo:" + strconv.Itoa(sess.user.uid) + ":" + strconv.Itoa(boss.boss_id)

	_, err = dbconn.Do("HMSET", bossKey, "boss_id", boss.boss_id, "boss_max_score", 0, "boss_today_max_score", 0, "boss_count", 0, "boss_rank", 0,
		"boss_tg_count", 0, "boss_pass", 0, "last_boss_end_time", 0)
	if err != nil {
		return 0, err
	}
	sess.user.bossInfos[boss.boss_id] = boss
	return boss.boss_id, nil
}

func (sess *Session) UpdateBossInfoAfterFight(bossID int, score int) error {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	boss, ok := sess.user.bossInfos[bossID]
	if !ok {
		sess.Error("not find bossid", bossID)
		return errors.New("not find bossid")
	}

	bossKey := "user:bossinfo:" + strconv.Itoa(sess.user.uid) + ":" + strconv.Itoa(bossID)

	if (boss.boss_max_score < score) || (score == 0 && boss.boss_max_score == 0) {
		boss.boss_max_score = score
		_, err := dbconn.Do("HSET", bossKey, "boss_max_score", boss.boss_max_score)
		if err != nil {
			sess.Error("Failed update boss_max_score", err)
			return err
		}
		_, err = dbconn.Do("ZADD", "boss:"+strconv.Itoa(bossID), boss.boss_max_score, sess.user.name)
		if err != nil {
			sess.Debug("Failed zadd new max score", err)
			return err
		}
		//sess.user.bossInfos[boss.boss_id]=boss
	}

	rank, err := redis.Int(dbconn.Do("ZREVRANK", "boss:"+strconv.Itoa(bossID), sess.user.name))
	if err != nil {
		sess.Debug("Failed get new rank of ", err)
		return err
	}
	boss.boss_rank = rank + 1
	boss.boss_count++
	boss.last_boss_end_time = time.Now().Unix()
	if boss.boss_today_max_score < score {
		boss.boss_today_max_score = score
	}
	_, err = dbconn.Do("HMSET", bossKey, "boss_count", boss.boss_count, "last_boss_end_time", boss.last_boss_end_time, "boss_rank", boss.boss_rank, "boss_today_max_score", boss.boss_today_max_score)
	if err != nil {
		return err
	}
	//sess.user.bossInfos[boss.boss_id]=boss
	return nil
}

func (sess *Session) AddBossTGCount(bossID int) error {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	boss, ok := sess.user.bossInfos[bossID]
	if !ok {
		sess.Error("not find bossid", bossID)
		return errors.New("not find bossid")
	}

	bossKey := "user:bossinfo:" + strconv.Itoa(sess.user.uid) + ":" + strconv.Itoa(bossID)

	boss.boss_tg_count++
	_, err := dbconn.Do("HSET", bossKey, "boss_tg_count", boss.boss_tg_count)
	if err != nil {
		return err
	}
	return nil
}

func (sess *Session) GetLeftTimeToBossFight(bossID int) int {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	sess.Debug("GetLeftTimeToBossFight", sess.user.chapter, sess.user.uid)

	//if sess.user.chapter == 1 {
	//return -1
	//}
	boss, ok := sess.user.bossInfos[bossID]
	if !ok {
		sess.Error("not find bossid", bossID)
		return -1
	}
	if boss.boss_count == 0 {
		return 0
	}

	if (boss.boss_pass == 0 && boss.boss_count >= 6) || (boss.boss_pass == 1 && boss.boss_count >= 1) {
		return int(86400 - time.Now().Unix()%86400)
	}

	sess.Debug("now and last is ", time.Now().Unix(), boss.last_boss_end_time, sess.user.uid)

	left_time := CD_Time - (time.Now().Unix() - boss.last_boss_end_time)
	if left_time < 0 {
		left_time = 0
	}
	return int(left_time)
}

type RankPlayer struct {
	Name  string
	Score int
	Photo string
}

func GetTopTenOfBossFight(sess *Session, bid int) ([]RankPlayer, error) {
	key := "boss:" + strconv.Itoa(bid)
	return sess.GetTopTenOfRank(key)
}
