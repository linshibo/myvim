package gameserver

import (
	//"encoding/json"
	"errors"
	"github.com/garyburd/redigo/redis"
	. "sanguo/base/util"
	"sanguo/db"
	. "sanguo/systemdata"
	"strconv"
)

var (
	SessErr = errors.New("Wired: sess get in quest is nil")
	SendErr = errors.New("Failed Send")
	DataErr = errors.New("The qid is not in system data")
)

type _QuestData struct {
	step int
}

type _QuestManager struct {
	accepted_quests             map[int]_QuestData
	finished_quests             map[int]bool
	unreward_quests             map[int]bool
	refresh_quests              map[int]bool
	fight_quest                 [FightQuestNum]int
	guanqia_quests              map[int]bool
	finished_arm_equip_quests   map[int]bool
	finished_hero_evolve_quests map[int]bool
	user                        *User
}

func NewQuestManager() *_QuestManager {
	var q _QuestManager
	q.accepted_quests = make(map[int]_QuestData)
	q.finished_quests = make(map[int]bool)
	q.unreward_quests = make(map[int]bool)
	q.refresh_quests = make(map[int]bool)
	q.guanqia_quests = make(map[int]bool)
	q.finished_arm_equip_quests = make(map[int]bool)
	q.finished_hero_evolve_quests = make(map[int]bool)

	return &q
}

func (this *_QuestManager) SetUser(u *User) {
	this.user = u
}

func (this *_QuestManager) Load() (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	reply, err := redis.Values(dbconn.Do("SMEMBERS", this.user.GetUidUsedInDB()+":accepted_quests"))
	if err != nil {
		return err
	}

	var qid int
	var tmp _QuestData
	for i := 0; i < len(reply); i++ {
		qid, err = redis.Int(reply[i], nil)
		if err != nil {
			this.user.Error("Failed accepted_quests")
			return err
		}

		tmp.step, err = redis.Int(dbconn.Do("HGET", this.user.GetUidUsedInDB()+":accepted_quest:"+strconv.Itoa(qid), "step"))
		if err != nil {
			this.user.Error("Failed HGET step", qid)
			return err
		}

		this.accepted_quests[qid] = tmp
	}

	reply, err = redis.Values(dbconn.Do("SMEMBERS", this.user.GetUidUsedInDB()+":finished_quests"))
	if err != nil {
		this.user.Error("Failed finished_quests")
		return err
	}

	for i := 0; i < len(reply); i++ {
		qid, err = redis.Int(reply[i], nil)
		if err != nil {
			return err
		}
		this.finished_quests[qid] = true
	}

	reply, err = redis.Values(dbconn.Do("SMEMBERS", this.user.GetUidUsedInDB()+":unrewardquests"))
	if err != nil {
		return err
	}

	for i := 0; i < len(reply); i++ {
		qid, err = redis.Int(reply[i], nil)
		if err != nil {
			this.user.Error("Failed unrewardquests", err)
			return err
		}
		this.unreward_quests[qid] = true
	}

	reply, err = redis.Values(dbconn.Do("SMEMBERS", this.user.GetUidUsedInDB()+":refresh_quests"))
	if err != nil {
		return err
	}

	for i := 0; i < len(reply); i++ {
		qid, err = redis.Int(reply[i], nil)
		if err != nil {
			this.user.Error("Failed refresh_quests", err)
			return err
		}
		this.refresh_quests[qid] = true
	}

	reply, err = redis.Values(dbconn.Do("SMEMBERS", this.user.GetUidUsedInDB()+":guanqia_quests:"+strconv.Itoa(this.user.GetChapter())))
	if err != nil {
		this.user.Error("Failed guanqia_quests", err)
		return err
	}

	for i := 0; i < len(reply); i++ {
		qid, err = redis.Int(reply[i], nil)
		if err != nil {
			return err
		}
		this.guanqia_quests[qid] = true
	}

	reply, err = redis.Values(dbconn.Do("SMEMBERS", this.user.GetUidUsedInDB()+":finished_hero_evolve_quests"))
	if err != nil {
		this.user.Error("Failed hero_evolve", err)
		return err
	}

	for i := 0; i < len(reply); i++ {
		qid, err = redis.Int(reply[i], nil)
		if err != nil {
			return err
		}
		this.finished_hero_evolve_quests[qid] = true
	}

	reply, err = redis.Values(dbconn.Do("SMEMBERS", this.user.GetUidUsedInDB()+":finished_arm_equip_quests"))
	if err != nil {
		this.user.Error("Failed arm_equip", err)
		return err
	}

	for i := 0; i < len(reply); i++ {
		qid, err = redis.Int(reply[i], nil)
		if err != nil {
			return err
		}
		this.finished_arm_equip_quests[qid] = true
	}

	return nil
}

func (this *_QuestManager) GetFinishedArmEquip() (back []int) {
	back = make([]int, len(this.finished_arm_equip_quests))
	index := 0
	for id, _ := range this.finished_arm_equip_quests {
		back[index] = id
		index++
	}
	return back
}

func (this *_QuestManager) GetFinishedHeroEvolve() (back []int) {
	back = make([]int, len(this.finished_hero_evolve_quests))
	index := 0
	for id, _ := range this.finished_hero_evolve_quests {
		back[index] = id
		index++
	}
	return back
}

func (this *_QuestManager) RefreshQuestInTheFirstLogin() (err error) {
	for qid, _ := range this.refresh_quests {
		if _, ok := this.accepted_quests[qid]; !ok {
			if Quest[qid].Maxlevel < this.user.GetLevel() {
				err = this.DelRefreshQuest(qid)
				if err != nil {
					this.user.Error("Failed SubmitRefreshQuest", err)
					return
				}
			}

			err = this.AcceptNewQuest(qid)
			if err != nil {
				this.user.Error("Failed AcceptNewQuest", err)
				return
			}
		}
	}
	return
}

//t mean QuestType(actiontype)   s mean SimpleGuanqia(actionparam)    v mean Value
func (this *_QuestManager) InspectQuest(t int, s int, v int) (err error) {

	var f func(int, int, int) error
	switch t {
	case 1:
		f = this.ProcessQuest_FinishSimpleGuanqia_1

	case 2:
		f = this.ProcessQuest_FinishChapterGuanqia_2

	case 3:
		f = this.ProcessQuest_FinishChapter_3

	case 4:
		f = this.ProcessQuest_DragCard_4

	case 5:
		f = this.ProcessQuest_FinishSimpleGuanqiaMoreTime_5

	case 6:
		f = this.ProcessQuest_UpdateSpecLevel_6

	case 9:
		f = this.ProcessQuest_LoginDays_9

	case 10:
		f = this.ProcessQuest_GetSpecGold_10

	case 12:
		f = this.ProcessQuest_GetSpecScore_12

	case QuestType_RecruitSpecArm:
		f = this.ProcessQuest_RecruitSpecArm_13

	case QuestType_UpdateArm, QuestType_FinishActivity, QuestType_FinishBoss, QuestType_SendFriendNum, QuestType_WinFight:
		f = this.ProcessQuest_N_time_14_15_16_18_23

	case QuestType_FriendNum:
		f = this.ProcessQuest_FriendNum_17

	case QuestType_GetHero:
		f = this.ProcessQuest_GetHeroInTheFight_19

	case QuestType_GetTrueHero:
		f = this.ProcessQuest_GetTrueHero_20

	case QuestType_ArmEvolveSpecQuality:
		f = this.ProcessQuest_ArmEvolveToSpecQuality_21

	case QuestType_HeroEvolveSpecQuality:
		f = this.ProcessQuest_HeroEvolveToSpecQuality_22

	case QuestType_CollectSpecArm:
		f = this.ProcessQuest_CollectSpecArm

	case QuestType_CollectArmWithSoul:
		f = this.ProcessQuest_CollectArmWithSoul

	case QuestType_CollectArmCount:
		f = this.ProcessQuest_CollectArmCount

	case QuestType_CollectSpecHeroLevel:
		f = this.ProcessQuest_CollectSpecHeroLevel

	case QuestType_CollectHeroCount:
		f = this.ProcessQuest_CollectHeroCount

	default:
		f = nil
	}

	if f == nil {
		return errors.New("No reponse quest process")
	}

	for qid, _ := range this.accepted_quests {
		if Quest[qid].Actiontype == t {
			err = f(qid, s, v)
			if err != nil {
				return err
			}
			continue
		}
	}

	for _, qid := range AllArmEquipQuests {
		if Quest[qid].Actiontype == t {
			if !this.finished_arm_equip_quests[qid] {
				err = f(qid, s, v)
				if err != nil {
					return err
				}
				continue
			}
		}
	}

	for _, qid := range AllHeroEvolveQuests {
		if Quest[qid].Actiontype == t {
			if !this.finished_hero_evolve_quests[qid] {
				err = f(qid, s, v)
				if err != nil {
					return err
				}
				continue
			}
		}
	}

	return nil
}

func (this *_QuestManager) DelRefreshQuest(qid int) (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	delete(this.refresh_quests, qid)
	_, err = dbconn.Do("SREM", this.user.GetUidUsedInDB()+":refresh_quests", qid)
	if err != nil {
		return err
	}

	/*this.finished_quests[qid] = true
	_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":finished_quests", qid)
	if err != nil {
		return err
	}*/

	return
}

func (this *_QuestManager) SubmitQuest(qid int) (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	this.user.Trace("InSubmitQuest", qid)
	if Quest[qid].Needpushreward == QuestMold_HeroAdvance {
		this.finished_hero_evolve_quests[qid] = true
		_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":finished_hero_evolve_quests", qid)
		if err != nil {
			this.user.Error("Failed SADD finished_hero", err)
			return err
		}
	} else if Quest[qid].Needpushreward == QuestMold_ArmEquip {
		this.finished_arm_equip_quests[qid] = true
		_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":finished_arm_equip_quests", qid)
		if err != nil {
			this.user.Error("Failed SADD finished_hero", err)
			return err
		}
	} else {

		delete(this.accepted_quests, qid)
		_, err = dbconn.Do("SREM", this.user.GetUidUsedInDB()+":accepted_quests", qid)
		if err != nil {
			return err
		}

		_, err = dbconn.Do("DEL", this.user.GetUidUsedInDB()+":accepted_quest:"+strconv.Itoa(qid))
		if err != nil {
			return err
		}

		if Quest[qid].Refreshtype == 3 {
			if !this.refresh_quests[qid] {
				this.refresh_quests[qid] = true
				_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":refresh_quests", qid)
				if err != nil {
					return err
				}
			}
		} else {
			this.finished_quests[qid] = true
			_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":finished_quests", qid)
			if err != nil {
				return err
			}
		}

		this.unreward_quests[qid] = true
		_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":unrewardquests", qid)
		if err != nil {
			return err
		}

	}
	return nil
}

//t 表示任务类型,同 QuestMod
func (this *_QuestManager) IsQuestFinished(t int, qid int) (flag bool) {
	switch t {
	case QuestMold_HeroAdvance:
		flag = this.finished_hero_evolve_quests[qid]

	case QuestMold_ArmEquip:
		flag = this.finished_arm_equip_quests[qid]

	default:
		flag = this.finished_quests[qid]
	}

	return flag
}

func (this *_QuestManager) CanNewQuestAccept(qid int) bool {
	this.user.Trace("Quest is", qid, "---", Quest[qid].Needpushreward)
	if _, ok := Quest[qid]; !ok {
		this.user.Error("The recieve quest id is not exist")
		return false
	}

	if _, ok := this.refresh_quests[qid]; ok {
		this.user.Error("The recieve quest id is in refresh_quests")
		return false
	}

	if _, ok := this.unreward_quests[qid]; ok {
		this.user.Error("The recieve quest id is in unreward_quests")
		return false
	}

	if _, ok := this.finished_quests[qid]; ok {
		this.user.Error("The recieve quest id is in finished_quests")
		return false
	}

	if this.user.GetLevel() < Quest[qid].Unlocklevel {
		this.user.Error("The user level is not enough to unlock quest")
		return false
	}

	if Quest[qid].PreId != 0 {
		if !this.finished_quests[Quest[qid].PreId] {
			this.user.Error("The preId is not completed", Quest[qid].PreId, qid)
			return false
		}
	}

	if Quest[qid].Needpushreward != QuestMold_Nomal || Quest[qid].Needpushreward != QuestMold_Chengjiu {
		this.user.Error("The type is wrong", Quest[qid].Needpushreward)
		return false
	}

	return true
}

func (this *_QuestManager) AcceptNewQuest(qid int) (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	var quest_tmp _QuestData
	quest_tmp.step = 0
	this.accepted_quests[qid] = quest_tmp
	_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":accepted_quests", qid)
	if err != nil {
		return err
	}

	_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":accepted_quest:"+strconv.Itoa(qid), "step", 0)
	if err != nil {
		return err
	}

	if Quest[qid].Refreshtype == 3 {
		if !this.refresh_quests[qid] {
			this.refresh_quests[qid] = true
			_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":refresh_quests", qid)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (this *_QuestManager) CanGetReward(qid int) bool {
	return this.unreward_quests[qid]
}

func (this *_QuestManager) GetQuestReward(qid int) (err error) {
	if !this.unreward_quests[qid] {
		return errors.New("The qid is not in unreward_quests")
	}

	_,_, err = this.user.ProcessReward(Quest[qid].Rewardtype, Quest[qid].Rewardcount)
	if err != nil {
		this.user.Error("Failed ProcessReward", qid)
		return err
	}

	delete(this.unreward_quests, qid)

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	_, err = dbconn.Do("SREM", this.user.GetUidUsedInDB()+":unrewardquests", qid)
	if err != nil {
		this.user.Error("Failed SREM", qid)
		return err
	}
	this.user.Trace("Will SREM")
	return nil
}

func (this *_QuestManager) GetOwnFinishedQuest() []int {
	q := make([]int, len(this.finished_quests))
	index := 0
	for id, _ := range this.finished_quests {
		q[index] = id
		index++
	}
	return q
}

func (this *_QuestManager) GetUnrewardQuests() []int {
	q := make([]int, len(this.unreward_quests))
	index := 0
	for id, _ := range this.unreward_quests {
		q[index] = id
		index++
	}
	return q
}

func (this *_QuestManager) GetOwnAcceptedQuest() []QuestStep {
	q := make([]QuestStep, len(this.accepted_quests))
	index := 0
	for id, v := range this.accepted_quests {
		q[index].Qid = id
		q[index].Step = v.step
		index++
	}
	return q
}

//Finish a simle_guanqia    Type 1
func (this *_QuestManager) ProcessQuest_FinishSimpleGuanqia_1(qid int, v1 int, v2 int) (err error) {
	v, ok := Quest[qid]
	if !ok {
		err = errors.New("The qid is not in system data")
		return
	}

	simple_guanqia := v.Actionparam
	flag := this.user.IsGetThroughSimpleGuanBefore(simple_guanqia)

	if !flag {
		return nil
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	sess := this.user.GetSession()
	if sess == nil {
		this.user.Error("Wired: sess get in quest is nil")
		return
	}

	back := map[string]interface{}{
		"qid":      qid,
		"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}

	return
}

//Finish a chapter_guanqia    Type 2
func (this *_QuestManager) ProcessQuest_FinishChapterGuanqia_2(qid int, v1 int, v2 int) (err error) {
	v, ok := Quest[qid]
	if !ok {
		err = errors.New("The qid is not in system data")
		return
	}

	chapter_guanqia := v.Actionparam
	length := len(ChapterGuanQiaInfo[chapter_guanqia].Allsimpleguanqias)
	if length == 0 {
		return
	}

	simple_guanqia := ChapterGuanQiaInfo[chapter_guanqia].Allsimpleguanqias[length-1]
	this.user.Trace("FinishChapterGuanqia", simple_guanqia, chapter_guanqia)

	flag := this.user.IsGetThroughSimpleGuanBefore(simple_guanqia)

	if !flag {
		return
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	back := map[string]interface{}{
		"qid":      qid,
		"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	sess := this.user.GetSession()
	if sess == nil {
		this.user.Error("Wired: sess get in quest is nil")
		return
	}

	sess.SendReplyBack(back, 13)

	return
}

//Finish a chapter    Type 3
func (this *_QuestManager) ProcessQuest_FinishChapter_3(qid int, v1 int, v2 int) (err error) {
	v, ok := Quest[qid]
	if !ok {
		err = errors.New("The qid is not in system data")
		return
	}

	chapter := v.Actionparam
	if chapter >= this.user.GetChapter() {
		return nil
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	sess := this.user.GetSession()
	if sess == nil {
		this.user.Error("Wired: sess get in quest is nil")
		return
	}
	back := map[string]interface{}{
		"qid":      qid,
		"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}
	return nil
}

//DragCard N times  4
func (this *_QuestManager) ProcessQuest_DragCard_4(qid int, v1 int, v2 int) (err error) {
	v, ok := Quest[qid]
	if !ok {
		err := errors.New("The qid is not in system data")
		return err
	}

	count_need := v.Value

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	if (this.accepted_quests[qid].step + 1) < count_need {
		quest_tmp := this.accepted_quests[qid]
		quest_tmp.step += 1
		this.accepted_quests[qid] = quest_tmp

		dbconn := db.Pool.Get()
		defer dbconn.Close()

		_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":accepted_quest:"+strconv.Itoa(qid), "step", this.accepted_quests[qid].step)
		if err != nil {
			return err
		}

		back := map[string]interface{}{
			"qid":      qid,
			"step":     this.accepted_quests[qid].step,
			"isfinish": false,
		}

		if !sess.SendReplyBack(back, 13) {
			return SendErr
		}

		return nil
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return err
	}

	back := map[string]interface{}{
		"qid":      qid,
		"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}
	return nil
}

//Finish a simple_guanqia N time   Type 5
func (this *_QuestManager) ProcessQuest_FinishSimpleGuanqiaMoreTime_5(id int, s int, vc int) (err error) {
	v, ok := Quest[id]
	if !ok {
		return DataErr
	}

	simple_guanqia := v.Actionparam

	if s != simple_guanqia {
		return nil
	}

	n := Quest[id].Value
	if n < 0 {
		return DataErr
	}

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	if (this.accepted_quests[id].step + 1) < n {
		quest_tmp := this.accepted_quests[id]
		quest_tmp.step++
		this.accepted_quests[id] = quest_tmp

		dbconn := db.Pool.Get()
		defer dbconn.Close()

		_, err = dbconn.Do("HMSET", this.user.GetUidUsedInDB()+":accepted_quest:"+strconv.Itoa(id), "step", this.accepted_quests[id].step, "isfinish", false)
		if err != nil {
			return err
		}

		back := map[string]interface{}{
			"qid":      id,
			"step":     this.accepted_quests[id].step,
			"isfinish": false,
		}

		if !sess.SendReplyBack(back, 13) {
			return SendErr
		}

		return nil
	}

	err = this.SubmitQuest(id)
	if err != nil {
		return err
	}

	back := map[string]interface{}{
		"qid":      id,
		"step":     this.accepted_quests[id].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}
	return nil
}

//Get a specific level    Type 6
func (this *_QuestManager) ProcessQuest_UpdateSpecLevel_6(id int, v1 int, v2 int) (err error) {
	v, ok := Quest[id]
	if !ok {
		err := errors.New("The qid is not in system data")
		return err
	}

	l := v.Value
	if this.user.GetLevel() < l {
		return nil
	}

	err = this.SubmitQuest(id)
	if err != nil {
		return err
	}

	back := map[string]interface{}{
		"qid":    id,
		"step":   this.accepted_quests[id].step,
		"finish": true,
	}

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}
	return nil
}

//Login for N days        Type 9
func (this *_QuestManager) ProcessQuest_LoginDays_9(id int, s int, vv int) (err error) {
	v, ok := Quest[id]
	if !ok {
		return DataErr
	}

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	day_need := v.Value
	if day_need == 1 {
		err = this.SubmitQuest(id)
		if err != nil {
			return err
		}

		back := map[string]interface{}{
			"qid":      id,
			"step":     this.accepted_quests[id].step,
			"isfinish": true,
		}

		if !sess.SendReplyBack(back, 13) {
			return SendErr
		}
		return nil
	}

	var quest_tmp _QuestData

	// Judge continuous
	/*if (s == 0) && !IsLoginContinuous(sess.user.last_login) {

		quest_tmp.step = 0
		this.accepted_quests[id] = quest_tmp

		dbconn := db.Pool.Get()
		defer dbconn.Close()

		_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":accepted_quest:"+strconv.Itoa(id), "step", this.accepted_quests[id].step)
		if err != nil {
			return err
		}
		return nil
	}*/

	if (s == 1) && this.accepted_quests[id].step != 0 {
		return nil
	}

	this.user.Trace("The user is continue login or just accepte new quest", this.user)

	if (this.accepted_quests[id].step + 1) < day_need {
		quest_tmp = this.accepted_quests[id]
		quest_tmp.step++
		this.accepted_quests[id] = quest_tmp

		dbconn := db.Pool.Get()
		defer dbconn.Close()

		_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":accepted_quest:"+strconv.Itoa(id), "step", this.accepted_quests[id].step)
		if err != nil {
			return err
		}

		back := map[string]interface{}{
			"qid":      id,
			"step":     this.accepted_quests[id].step,
			"isfinish": false,
		}

		if !sess.SendReplyBack(back, 13) {
			return SendErr
		}

		return nil
	}

	err = this.SubmitQuest(id)
	if err != nil {
		return err
	}

	back := map[string]interface{}{
		"qid":      id,
		"step":     this.accepted_quests[id].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}
	return nil
}

//Get a specific number of gold       Type 10
func (this *_QuestManager) ProcessQuest_GetSpecGold_10(id int, num int, v1 int) (err error) {
	v, ok := Quest[id]
	if !ok {
		return DataErr
	}

	this.user.Trace("ProcessQuest_GetSpecGold", v)

	gold_need := v.Value
	quest_tmp := this.accepted_quests[id]
	quest_tmp.step += num
	this.accepted_quests[id] = quest_tmp

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	this.user.Trace("The step is", quest_tmp)

	if this.accepted_quests[id].step < gold_need {

		dbconn := db.Pool.Get()
		defer dbconn.Close()

		_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":accepted_quest:"+strconv.Itoa(id), "step", this.accepted_quests[id].step)
		if err != nil {
			return err
		}

		back := map[string]interface{}{
			"qid":      id,
			"step":     this.accepted_quests[id].step,
			"isfinish": false,
		}

		if !sess.SendReplyBack(back, 13) {
			return SendErr
		}

		return nil
	}

	err = this.SubmitQuest(id)
	if err != nil {
		return err
	}

	back := map[string]interface{}{
		"qid":      id,
		"step":     this.accepted_quests[id].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}
	return nil
}

//Get a specific score in anyone guanqia            Type 12
func (this *_QuestManager) ProcessQuest_GetSpecScore_12(id int, s int, score int) (err error) {
	v, ok := Quest[id]
	if !ok {
		return DataErr
	}

	score_need := v.Value
	simple_guanqia := v.Actionparam

	if simple_guanqia != 0 {
		// a specific simple_guanqia
		if simple_guanqia != s {
			return nil
		}
	}

	if score < score_need {
		return nil
	}

	err = this.SubmitQuest(id)
	if err != nil {
		return err
	}

	back := map[string]interface{}{
		"qid":      id,
		"isfinish": true,
	}

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}
	return nil
}

//Recruit Arm                  Type 13
func (this *_QuestManager) ProcessQuest_RecruitSpecArm_13(qid int, armid int, v1 int) (err error) {
	this.user.Trace("ProcessQuest_RecruitSpecArm_13", qid, armid)
	v, ok := Quest[qid]
	if !ok {
		err = errors.New("The qid is not in system data")
		return
	}

	arm_require := v.Actionparam

	if arm_require != armid {
		return nil
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	sess := this.user.GetSession()
	if sess == nil {
		this.user.Error("Wired: sess get in quest is nil")
		return
	}

	back := map[string]interface{}{
		"qid":      qid,
		"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}

	return
}

//Update Arm n time            Type 14,15,16,18,23
func (this *_QuestManager) ProcessQuest_N_time_14_15_16_18_23(qid int, v1 int, v2 int) (err error) {
	this.user.Trace("WillDoProcessQuest_N_time_14_15_16_18_23", qid, "----", Quest[qid])
	v, ok := Quest[qid]
	if !ok {
		return DataErr
	}

	count_need := v.Value

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	if (this.accepted_quests[qid].step + 1) < count_need {
		quest_tmp := this.accepted_quests[qid]
		quest_tmp.step += 1
		this.accepted_quests[qid] = quest_tmp

		dbconn := db.Pool.Get()
		defer dbconn.Close()

		_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":accepted_quest:"+strconv.Itoa(qid), "step", this.accepted_quests[qid].step)
		if err != nil {
			return err
		}

		back := map[string]interface{}{
			"qid":      qid,
			"step":     this.accepted_quests[qid].step,
			"isfinish": false,
		}

		if !sess.SendReplyBack(back, 13) {
			return SendErr
		}

		return nil
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return err
	}

	back := map[string]interface{}{
		"qid":      qid,
		"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}
	return nil
}

//FriendNum
func (this *_QuestManager) ProcessQuest_FriendNum_17(qid int, v1 int, v2 int) (err error) {
	v, ok := Quest[qid]
	if !ok {
		return DataErr
	}

	num := v.Value

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	if this.user.Friends.FriendNum() < num {
		quest_tmp := this.accepted_quests[qid]
		quest_tmp.step = this.user.Friends.FriendNum()
		this.accepted_quests[qid] = quest_tmp

		dbconn := db.Pool.Get()
		defer dbconn.Close()

		_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":accepted_quest:"+strconv.Itoa(qid), "step", this.accepted_quests[qid].step)
		if err != nil {
			return err
		}

		back := map[string]interface{}{
			"qid":      qid,
			"step":     this.accepted_quests[qid].step,
			"isfinish": false,
		}

		if !sess.SendReplyBack(back, 13) {
			return SendErr
		}

		return nil

	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	back := map[string]interface{}{
		"qid":      qid,
		"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}

	return
}

// GetHeroInTheFight  Type 19
func (this *_QuestManager) ProcessQuest_GetHeroInTheFight_19(qid int, oid int, v2 int) (err error) {
	this.user.Trace("ProcessQuest_GetHeroInTheFight_19", Quest[qid].Actionparam, oid)
	v, ok := Quest[qid]
	if !ok {
		return DataErr
	}

	hoid := v.Actionparam

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	if !this.user.Hero.IsKindOwnedByOid(hoid) {
		return nil
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	back := map[string]interface{}{
		"qid":      qid,
		"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}

	return
}

// GetTrueHero   Type 20
func (this *_QuestManager) ProcessQuest_GetTrueHero_20(qid int, v1 int, v2 int) (err error) {
	v, ok := Quest[qid]
	if !ok {
		return DataErr
	}

	hoid := v.Actionparam

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	if !this.user.Hero.IsHeroTure(hoid) {
		return nil
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	back := map[string]interface{}{
		"qid":      qid,
		"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}

	return
}

//EvolveToSpecQuality                type21
func (this *_QuestManager) ProcessQuest_ArmEvolveToSpecQuality_21(qid int, quality int, star int) (err error) {
	v, ok := Quest[qid]
	if !ok {
		return DataErr
	}

	quality_need := v.Actionparam
	star_need := v.Actionparam2

	if quality_need != quality {
		return nil
	}

	if star_need != star {
		return nil
	}

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	back := map[string]interface{}{
		"qid":      qid,
		"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}

	return
}

//EvolveToSpecQualityOfSpecStar               type22
func (this *_QuestManager) ProcessQuest_HeroEvolveToSpecQuality_22(qid int, quality int, star int) (err error) {
	this.user.Trace("ProcessQuest_HeroEvolveToSpecQuality_22")
	v, ok := Quest[qid]
	if !ok {
		return DataErr
	}

	quality_need := v.Actionparam

	if quality_need != quality {
		return nil
	}

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	back := map[string]interface{}{
		"qid":      qid,
		"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}

	return
}

//GetThroughSpecBossId            type24
func (this *_QuestManager) ProcessQuest_GetThroughSpecBossId_24(qid int, v1 int, v2 int) (err error) {
	v, ok := Quest[qid]
	if !ok {
		return DataErr
	}

	bossid_need := v.Value

	if bossid_need == 0 {

	}

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	back := map[string]interface{}{
		"qid":      qid,
		"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}

	return
}

//QuestType_CollectSpecArm
func (this *_QuestManager) ProcessQuest_CollectSpecArm(qid int, v1 int, v2 int) (err error) {
	v, ok := Quest[qid]
	if !ok {
		return DataErr
	}

	id := v.Actionparam

	if !this.user.Arm.IsKindOwned(id) {
		return
	}

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	back := map[string]interface{}{
		"qid": qid,
		//"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}

	return
}

//QuestType_CollectArmWithSoul
func (this *_QuestManager) ProcessQuest_CollectArmWithSoul(qid int, v1 int, v2 int) (err error) {
	v, ok := Quest[qid]
	if !ok {
		return DataErr
	}

	star := v.Actionparam
	count := v.Value

	if count > this.user.Arm.GetArmCountOfStar(star) {
		return
	}

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	back := map[string]interface{}{
		"qid": qid,
		//"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}

	return
}

//CollectArmCount
func (this *_QuestManager) ProcessQuest_CollectArmCount(qid int, v1 int, v2 int) (err error) {
	v, ok := Quest[qid]
	if !ok {
		return DataErr
	}

	count := v.Value

	if count > this.user.Arm.GetArmCount() {
		return
	}

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	back := map[string]interface{}{
		"qid": qid,
		//"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}

	return
}

//CollectSpecHeroLevel
func (this *_QuestManager) ProcessQuest_CollectSpecHeroLevel(qid int, v1 int, v2 int) (err error) {
	v, ok := Quest[qid]
	if !ok {
		return DataErr
	}

	level := v.Value
	id := v.Actionparam

	if level > this.user.Hero.GetHeroLevel(id) {
		return
	}

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	back := map[string]interface{}{
		"qid": qid,
		//"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}

	return
}

//QuestType_CollectHeroCount
func (this *_QuestManager) ProcessQuest_CollectHeroCount(qid int, v1 int, v2 int) (err error) {
	v, ok := Quest[qid]
	if !ok {
		return DataErr
	}

	//id := v.Value
	count := v.Value

	if count > this.user.Hero.GetHeroCount() {
		return
	}

	sess := this.user.GetSession()
	if sess == nil {
		return SessErr
	}

	err = this.SubmitQuest(qid)
	if err != nil {
		return
	}

	back := map[string]interface{}{
		"qid": qid,
		//"step":     this.accepted_quests[qid].step,
		"isfinish": true,
	}

	if !sess.SendReplyBack(back, 13) {
		return SendErr
	}

	return
}

////////////////////////////////////// FightQuest /////////////////////////////////////////////
func (this *_QuestManager) LoadRandomFightQuestInTheFirstLoginOfDay() (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	for i := 0; i < FightQuestNum; i++ {
		this.fight_quest[i] = 0
	}

	//dbconn.Send("MULTI")
	_, err = dbconn.Do("DEL", this.user.GetUidUsedInDB()+":fight_quest")
	if err != nil {
		return err
	}

	for i := 0; i < FightQuestNum; i++ {
		this.fight_quest[i] = this.getRandomQuest()
		_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":fight_quest", this.fight_quest[i])
		if err != nil {
			return err
		}
	}

	//_, err = dbconn.Do("EXEC")
	//if err != nil {
	//	return err
	//}

	return nil
}

func (this *_QuestManager) LoadRandomFightQuest() (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	reply, err := redis.Values(dbconn.Do("SMEMBERS", this.user.GetUidUsedInDB()+":fight_quest"))
	if err != nil {
		return err
	}

	for i := 0; i < len(reply); i++ {
		this.fight_quest[i], err = redis.Int(reply[i], nil)
		if err != nil {
			return err
		}
	}
	return nil
}

func (this *_QuestManager) getRandomQuest() int {
	aid := 0
	level := this.user.GetLevel()
	index := GetRandomNum(UserFightQuestCount[level])
	for i := 0; i < UserFightQuestCount[level]; i++ {
		aid = UserFightQuestIndex[level][(index+i)%UserFightQuestCount[level]]
		if !this.isFightQuestRepeat(aid) {
			return aid
		}
	}
	return 0
}

func (this *_QuestManager) isFightQuestRepeat(id int) bool {
	for _, v := range this.fight_quest {
		if id == v {
			return true
		}
	}
	return false
}

func (this *_QuestManager) GetFightQuestReward(id int) (Reward_tmp, error) {
	var reward Reward_tmp
	reward.RewardType = Quest[id].Rewardtype
	reward.RewardValue = Quest[id].Rewardcount
	_, err := this.user.ProcessReward(reward.RewardType, reward.RewardValue)
	if err != nil {
		this.user.Error("Failed ProcessReward", err)
		return reward, err
	}
	return reward, nil
}

func (this *_QuestManager) DelFightQuest(id int) error {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	for index, v := range this.fight_quest {
		if v == id {
			this.fight_quest[index] = 0
		}
	}

	_, err := dbconn.Do("SREM", this.user.GetUidUsedInDB()+":fight_quest", id)
	if err != nil {
		return err
	}
	return nil
}

func (this *_QuestManager) GetAllOwnFightQuest() [3]int {
	return this.fight_quest
}

func (this *_QuestManager) FinishGuanqiaQuest(qid int) (err error) {
	this.guanqia_quests[qid] = true

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":guanqia_quests:"+strconv.Itoa(this.user.GetChapter()), qid)
	return err
}

func (this *_QuestManager) ChangeChapter() {
	for qid, _ := range this.guanqia_quests {
		delete(this.guanqia_quests, qid)
	}
}

func (this *_QuestManager) GetAllGuanqiaQuest() []int {
	length := len(this.guanqia_quests)
	if length == 0 {
		return nil
	}

	gqs := make([]int, length)
	index := 0
	for qid, _ := range this.guanqia_quests {
		gqs[index] = qid
		index++
	}
	return gqs
}
