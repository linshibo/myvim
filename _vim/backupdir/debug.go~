package gameserver

import (
	"encoding/json"
	"github.com/garyburd/redigo/redis"
	"sanguo/base/log"
	"sanguo/base/packet"
	"sanguo/db"
	//"sanguo/gameserver/constant"
	"strconv"
	//"time"
)

func DebugWinFight(sess *Session, reader *packet.Packet) bool {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	log.Debug("The data recv is ", string(reader.Data[:]), sess.user.uid)

	type DebugData struct {
		Sid int
	}

	var msg DebugData
	err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
	if err != nil {
		log.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}
	log.Debug("A data from client", msg, sess.user.uid)

	ret := true
	/*************************Verify hero id*************************************************
	heros_msg := msg.Heros
	for _, hero_id_level := range heros_msg {
		hero, ok := sess.user.heros[hero_id_level>>8]
		if ok != true {
			log.Error("The recieved hero id is not exist in user.arms", hero_id_level>>8, sess.user.uid)
			ret = false
			break
		}
		if hero.level != (hero_id_level & 0x0f) {
			log.Error("The recieved hero level is not exist in user.arms", hero_id_level&0x0f, sess.user.uid)
			ret = false
			break
		}
	}

	if ret == true {
		log.Debug("The recieved hero is ok", sess.user.uid)
		arms_msg := msg.Arms

		for _, arm_id_level := range arms_msg {
			v, ok := sess.user.arms[arm_id_level>>8]
			if ok != true {
				log.Error("The recieved arm id is not exist in user.arms", arm_id_level>>8, sess.user.uid)
				ret = false
				break
			}
			if v.level != (arm_id_level & 0x0f) {
				log.Error("The recieved arm level is not exist in user.arms", arm_id_level, arm_id_level&0x0f, sess.user.uid)
				ret = false
				break
			}
		}
	}

	if ret == true {
		log.Debug("The recieved arm is ok", sess.user.uid)

		heros_random := msg.Random_heros

		for _, hero := range heros_random {
			if hero.Damage != HeroInfo[hero.Id].damage {
				log.Debug("the damage of hero is not match with database of user:", sess.user.uid)
				ret = false
				break
			}
			if hero.DamageRatio != HeroInfo[hero.Id].damageRatio {
				log.Debug("the damageRatio of hero is not match with database of user:", sess.user.uid)
				ret = false
				break
			}
		}
	}

	if ret == true {
		log.Debug("The recieved rand heros is ok", sess.user.uid)

		arms_random := msg.Random_arms
		log.Debug("The recieved random_arms is", arms_random, sess.user.uid)

		for _, arm := range arms_random {
			if arm.Damage != ArmInfo[arm.Id].damage {
				log.Info("the damage of arm is not match with database of user:", sess.user.uid)
				ret = false
				break
			}
			if arm.Hp != ArmInfo[arm.Id].hp {
				log.Info("the hp of arm is not match with database of user:", sess.user.uid)
				ret = false
				break
			}
			if arm.DamageRatio != ArmInfo[arm.Id].damageRatio {
				log.Info("the damageRatio of arm is not match with database of user:", sess.user.uid)
				ret = false
				break
			}
		}
	}

	if ret == true {
		log.Debug("The recieved random arm is ok", sess.user.uid)

		// verify the enemy number and sequence

		var enemynum int
		enemyseq := make(map[int][]int)
		for _, danboId := range GuanqiaInfo[msg.Guanqiaid].allDanboIds {
			enemynum += DanboInfo[danboId].allUnitCount

			enemyseq[danboId] = DanboInfo[danboId].allUnitSeq
		}
		enemynum_recv := msg.Enemy_num

		if enemynum != enemynum_recv {
			log.Info("The enemy num is not match", sess.user.uid)
			ret = false
		}

		danbos := msg.Danbo
		log.Debug("The recieved danbo is", danbos, sess.user.uid)

		for _, danbo := range danbos {
			danbo_seq := enemyseq[danbo.Id]
			if len(danbo_seq) != len(danbo.Seq) {
				log.Info("The sequence num is not match.", "recieved:", len(danbo.Seq), "server:", len(danbo_seq), sess.user.uid)
				ret = false
				break
			}
			for i := 0; i < len(danbo_seq); i++ {
				if danbo.Seq[i] != danbo_seq[i] {
					log.Info("The sequence content is not match", sess.user.uid)
					ret = false
					break
				}
			}
			if !ret {
				break
			}
		}

	}

	if ret == true {
		log.Debug("The enemy number and sequence is ok", sess.user.uid)

		type enemy_rand struct {
			id     int
			damage int
			hp     int
		}

		enemys_random := msg.Random_enemy_arms
		log.Debug("The recieve random_enemy_arms is", enemys_random, sess.user.uid)

		for _, enemy := range enemys_random {

			if enemy.Damage != EnemyUnit[enemy.Id].damage {
				log.Info("the damage of arm is not match with database of user:", enemy.Damage, EnemyUnit[enemy.Id].damage, sess.user.uid)
				ret = false
				break
			}

			if enemy.Hp != EnemyUnit[enemy.Id].hp {
				log.Info("the hp of arm is not match with database of user:", sess.user.uid)
				ret = false
				break
			}
		}
	}

	************************** Verify finish, Reward And Quest Begin ************************************/

	back := make(map[string]interface{})
	if ret == false {
		log.Debug("Verify failed", sess.user.uid)

		back["ret"] = false

	} else {

		back["ret"] = true

		guanqia := msg.Sid

		/*****************************************tongguanReward****************************************
		tg_reward := make([]interface{})
		tg_reward, err := GetTongguanReward(sess, guanqia)
		if err != nil {
			log.Error("Failed get tongguan reward", err)
			return false
		}
		if tg_reward != nil {
			back["tg_reward"] = tg_reward
		}

		*****************************************score Reward*******************************************/
		score := int(10000)

		score_reward, err := GetScoreReward(sess, guanqia, score)
		if err != nil {
			log.Error("Failed get score reward", err)
			return false
		}
		if score_reward != nil {
			back["score_reward"] = score_reward
		}

		/*********************** Unlock next chapter or c_guan *************************************/

		if msg.Sid == sess.user.s_guanqia {
			log.Debug("Win the latest s_guanqia", sess.user.uid)
			// win the latest s_guanqia
			for index, simple_guan := range ChapterGuanQiaInfo[sess.user.c_guanqia].allsimpleguanqias {
				if simple_guan != msg.Sid {
					continue
				}
				if index < (len(ChapterGuanQiaInfo[sess.user.c_guanqia].allsimpleguanqias) - 1) {
					//Unlock next s_guanqia
					sess.user.s_guanqia = ChapterGuanQiaInfo[sess.user.c_guanqia].allsimpleguanqias[index+1]
					break
				}
				if index == (len(ChapterGuanQiaInfo[sess.user.c_guanqia].allsimpleguanqias) - 1) {
					// Judge unlock next chapter
					for i, chapter_guan := range ChapterInfo[sess.user.chapter].allCGuanQias {
						if sess.user.c_guanqia != chapter_guan {
							continue
						}
						if i < (len(ChapterInfo[sess.user.chapter].allCGuanQias) - 1) {
							//Unlock next c_guanqia and s_guanqia
							_, err = dbconn.Do("ZADD", sess.user.uid+":completed_c_guanqia", sess.user.chapter, sess.user.chapter<<8+sess.user.c_guanqia)
							if err != nil {
								log.Error("Cant add new unlock c_guaniqa into completed_c_guanqia", err, sess.user.uid)
								return false
							}
							sess.user.c_guanqia = ChapterInfo[sess.user.chapter].allCGuanQias[i+1]
							sess.user.s_guanqia = ChapterGuanQiaInfo[sess.user.c_guanqia].allsimpleguanqias[0]
							//sess.user.completed_c_guanqia = append(sess.user.completed_c_guanqia, sess.user.c_guanqia<<8+sess.user.c_guanqia)

							break
						}
						if i == (len(ChapterInfo[sess.user.chapter].allCGuanQias) - 1) {
							//Unlock next chapter and c_guanqia and s_guanqia
							if _, ok := ChapterInfo[sess.user.chapter+1]; ok {
								//TODO   fix a bug of final chapter reward
								/*****************************************tongguanReward****************************************/
								tg_reward, err := GetTongguanReward(sess)
								if err != nil {
									log.Error("Failed get tongguan reward", err)
									return false
								}
								if tg_reward != nil {
									back["tg_reward"] = tg_reward
								}
								/*****************************************finish tonggguan reward ******************************/
								//for i, _ := range sess.user.completed_c_guanqia {
								//	sess.user.completed_c_guanqia[i] = 0
								//}
								if _, ok := ChapterInfo[sess.user.chapter+1]; ok {
									sess.user.chapter++
									sess.user.c_guanqia = ChapterInfo[sess.user.chapter].allCGuanQias[0]
									sess.user.s_guanqia = ChapterGuanQiaInfo[sess.user.c_guanqia].allsimpleguanqias[0]
									break
								}
							}
						}
						// Cant find infomation about c_guanqia
						log.Error("Cant find infomation about c_guanqia", sess.user.uid)
						return false
					}
					break
				}
				log.Error("Cant find infomation about s_guanqia", sess.user.uid)
				return false
			}

			_, err = dbconn.Do("HMSET", sess.user.uid, "chapter", sess.user.chapter, "c_guanqia", sess.user.c_guanqia, "s_guanqia", sess.user.s_guanqia)
			if err != nil {
				log.Error("Cant update chapter and c_guanqia and s_guanqia in redis", err, sess.user.uid)
				return false
			}
		}

	}

	/****************************** Level Info ********************************************************/

	back["level"] = sess.user.level

	/************************** PowerReduce ******************************/
	if err = ReducePower(sess, 3); err != nil {
		return false
	}
	left_time, err := GetLeftTimeToAddPower(sess)
	if err != nil {
		log.Error("In start fight", err)
		return false
	}
	back["power"] = sess.user.power
	back["left_time"] = left_time
	/****************************** Finsh Process and send msg ****************************************/

	back_json, err := json.Marshal(back)
	if err != nil {
		log.Error("Can't decode json message in UserStartFight, err = %v", err, sess.user.uid)
		return false
	}
	log.Debug("The back json message is", string(back_json))
	if !sess.SendReply(back_json, 6) {
		log.Error("Send opcode6 error")
		return false
	}

	/****************************** Quest type 1,2,3,5,12 ****************************************/

	for qid, _ := range sess.user.accepted_quests {
		if Quest[qid].actiontype == 1 {
			_, err = IsFinishQuest_1(sess, qid)
			if err != nil {
				return false
			}
			continue

		}

		if Quest[qid].actiontype == 2 {
			_, err = IsFinishQuest_2(sess, qid)
			if err != nil {
				return false
			}
			continue

		}

		if Quest[qid].actiontype == 3 {
			_, err = IsFinishQuest_3(sess, qid)
			if err != nil {
				return false
			}
			continue

		}

		if Quest[qid].actiontype == 5 {
			_, err = IsFinishQuest_5(sess, qid, msg.Sid)
			if err != nil {
				return false
			}
			continue
		}

		score := int(10000)
		if Quest[qid].actiontype == 12 {
			_, err = IsFinishQuest_12(sess, qid, score, msg.Sid)
			if err != nil {
				return false
			}
			continue
		}
	}
	return true

}

func DebugGetThrough(sess *Session, reader *packet.Packet) bool {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	type DebugData struct {
		Sid int
		Cid int
		C   int
	}

	var msg DebugData
	err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
	if err != nil {
		log.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}
	log.Debug("A data from client", msg, sess.user.uid)

	_, err = dbconn.Do("HMSET", sess.user.uid, "chapter", msg.C, "c_guanqia", msg.Cid, "s_guanqia", msg.Sid)
	if err != nil {
		log.Error("Failed update debug info ", err, sess.user.uid)
		return false
	}

	exist_flag, err := redis.Bool(dbconn.Do("EXISTS", sess.user.uid+":"+strconv.Itoa(int(msg.Sid))))
	if err != nil {
		log.Error("Failed get existence of debug info", err, sess.user.uid)
		return false
	}
	if exist_flag {
		_, err := dbconn.Do("SET", sess.user.uid+":"+strconv.Itoa(int(msg.Sid)), 0)
		if err != nil {
			log.Error("Failed upset score of debug", err, sess.user.uid)
			return false
		}
	}
	return true
}

/*func DebugInitState(sess *Session, reader *packet.Packet) bool {
	id := sess.user.id

	log.Debug("The id is", id)

	_, err := dbconn.Do("DEL", sess.user.id)
	if err != nil {
		log.Error("Failed upset score of debug", err, sess.user.uid)
		return false
	}

	err = SetUserId(sess, id)
	if err != nil {
		return false
	}

	err = SetUserName(sess)
	if err != nil {
		return false
	}

	sess.user.gold = 100000
	sess.user.level = 1
	sess.user.money = 100000
	sess.user.exp = 0
	sess.user.power = FullPower
	sess.user.chapter = 1
	sess.user.stone = 10
	sess.user.c_guanqia = ChapterInfo[1].allCGuanQias[0]
	sess.user.s_guanqia = ChapterGuanQiaInfo[sess.user.c_guanqia].allsimpleguanqias[0]
	sess.user.last_login = int(time.Now().YearDay())
	sess.user.last_power_time = 0
	sess.user.vip = 0

	******card info***********
	sess.user.gold_card_count = 0
	sess.user.money_card_count = 0

	******boss info***********
	sess.user.boss_count = 0
	sess.user.boss_id = 0
	sess.user.boss_max_score = 0
	sess.user.boss_rank = 0
	sess.user.boss_tg_count = 0
	sess.user.boss_today_max_score = 0
	sess.user.last_boss_end_time = 0

	******friend info**********
	sess.user.friends_max_num = 15

	_, err = dbconn.Do("HMSET", sess.user.uid, "name", sess.user.name, "level", sess.user.level, "gold", sess.user.gold,
		"money", sess.user.money, "exp", sess.user.exp, "power", sess.user.power, "chapter", sess.user.chapter,
		"c_guanqia", sess.user.c_guanqia, "s_guanqia", sess.user.s_guanqia, "stone", sess.user.stone, "last_login", sess.user.last_login,
		"last_power_time", sess.user.last_power_time, "gold_card_count", sess.user.gold_card_count, "money_card_count", sess.user.money_card_count,
		"boss_id", sess.user.boss_id, "boss_rank", sess.user.boss_rank, "boss_count", sess.user.boss_count, "last_boss_end_time", sess.user.last_boss_end_time,
		"boss_today_max_score", sess.user.boss_today_max_score, "boss_tg_count", sess.user.boss_tg_count, "boss_max_score", sess.user.boss_max_score,
		"friends_max_num", sess.user.friends_max_num, "vip", 0)
	if err != nil {
		log.Error("Can't insert initial user info into redis of", sess.user.uid)
		return false
	}
	//if !flag {
	//	return errors.New("Failed init base player info")
	//}

	err = InitHeroInfo(sess)
	if err != nil {
		log.Error("Failed init Hero info", err)
		return false
	}

	err = InitArmInfo(sess)
	if err != nil {
		log.Error("Failed init Arm info", err)
		return false
	}

	err = InitSeenHeroInfo(sess)
	if err != nil {
		log.Error("Failed init SeenHero info", err)
		return false
	}

	err = InitSeenArmInfo(sess)
	if err != nil {
		log.Error("Failed init SeenArm info", err)
		return false
	}

	err = InitLastCard(sess)
	if err != nil {
		log.Error("Failed init LastCard info", err)
		return false
	}

	err = InitFormation(sess)
	if err != nil {
		log.Error("Failed init Formation info", err)
		return false
	}

	log.Debug("Init Over")
	return true
}*/

func DebugAddGold(sess *Session, reader *packet.Packet) bool {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	type Data struct {
		Gold int
	}

	var msg Data

	//	var msg map[string]interface{}
	err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
	if err != nil {
		log.Error("Can't decode json message, err = %v", err, sess.user.uid)
		return false
	}
	sess.user.gold += msg.Gold
	_, err = dbconn.Do("HSET", sess.user.uid, "gold", sess.user.gold)
	if err != nil {
		log.Error("Failed update debug info ", err, sess.user.uid)
		return false
	}

	back := make(map[string]interface{})
	back["gold"] = sess.user.gold

	return sess.SendReplyImprove(back, 0xf004)
}

//func DebugAddMoney1W(sess *Session, reader *packet.Packet) bool {
//
//	sess.user.money += 10000
//	_, err := dbconn.Do("HMSET", sess.user.uid, "money", sess.user.money)
//	if err != nil {
//		log.Error("Failed update debug info ", err, sess.user.uid)
//		return false
//	}
//	return true
//}

func DebugAddStone1W(sess *Session, reader *packet.Packet) bool {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	sess.user.stone += 10000
	_, err := dbconn.Do("HMSET", sess.user.uid, "stone", sess.user.stone)
	if err != nil {
		log.Error("Failed update debug info ", err, sess.user.uid)
		return false
	}

	return true
}

func DebugAddArm(sess *Session, reader *packet.Packet) bool {
	type DebugData struct {
		Id    int
		Level int
	}

	var msg DebugData
	err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
	if err != nil {
		log.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}
	log.Debug("A data from client", msg, sess.user.uid)

	for armid, _ := range sess.user.arms {
		if ArmInfo[armid].originalId == ArmInfo[msg.Id].originalId {
			log.Error("The original id repeat,", armid, sess.user.uid)
			return false
		}
	}

	err = AddNewArm(sess, msg.Id, msg.Level)
	if err != nil {
		log.Error("In debug failed add new arm,", err, sess.user.uid)
		return false
	}

	return true
}

func DebugAddHero(sess *Session, reader *packet.Packet) bool {
	type DebugData struct {
		Id    int
		Level int
	}

	var msg DebugData
	err := json.Unmarshal(reader.Data[reader.Pos:], &msg)
	if err != nil {
		log.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}
	log.Debug("A data from client", msg, sess.user.uid)

	for heroid, _ := range sess.user.heros {
		if ArmInfo[heroid].originalId == ArmInfo[msg.Id].originalId {
			log.Error("The original id repeat,", heroid, sess.user.uid)
			return false
		}
	}

	err = AddNewHero(sess, msg.Id, msg.Level)
	if err != nil {
		log.Error("In debug failed add new hero,", err, sess.user.uid)
		return false
	}

	return true
}

func DebugAddPower(sess *Session, reader *packet.Packet) bool {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	sess.user.power += 10
	_, err := dbconn.Do("HMSET", sess.user.uid, "power", sess.user.power)
	if err != nil {
		log.Error("Failed update debug info ", err, sess.user.uid)
		return false
	}
	return true
}
