package gameserver

import (
	"encoding/json"
	"github.com/garyburd/redigo/redis"
	"sanguo/base/log"
	//"sanguo/base/packet"
	"errors"
	"sanguo/db"
	. "sanguo/systemdata"
	"strconv"
	"time"
)

const (
	PowerPrice = 10
)

const (
	PurchaseType_NormalGold  = 1
	PurchaseType_SuperGold   = 2
	PurchaseType_NormalStone = 3
	PurchaseType_SuperStone  = 4
	PurchaseType_MonthPower  = 5
	PurchaseType_MonthStone  = 6
	PurchaseType_MonthHero   = 7
)

//opcode 90
func UserBuyPower(sess *Session, reader []byte) bool {
	//log.Debug("The data recv is ", string(reader.Data[:]), sess.user.uid)

	type Data struct {
		Num  int
		Type int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		log.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}
	log.Debug("A data from client", msg, sess.user.uid)

	if sess.user.stone < msg.Num {
		log.Error("The recv gold num is large than own", msg.Num, sess.user.stone)
		return false
	}

	n := msg.Num / PowerPrice
	log.Debug("The power will add is ", n, msg.Num)
	_, err = sess.user.ProcessReward(RewardType_Power, n)
	if err != nil {
		log.Error("Failed Add power of buy", err, sess.user.uid)
		return false
	}

	left_time, err := sess.user.GetLeftTimeToAddPower()
	if err != nil {
		log.Error("In UserBuyPower Failed GetLeftTimeToAddPower", err, sess.user.uid)
		return false
	}

	err = sess.user.CostWealth(RewardType_Stone, n*PowerPrice)
	if err != nil {
		log.Error("Failed ReduceGold", err, sess.user.uid)
		return false
	}
    GM.GMDayLog(sess.user.uid, StatIDBuyPower, n*PowerPrice)

	type DataBack struct {
		Gold          int
		Stone         int
		Power         int
		PowerLeftTime int
	}

	var back DataBack
	back.Power = sess.user.power
	back.PowerLeftTime = left_time
	back.Gold = sess.user.gold
	back.Stone = sess.user.stone

	return sess.SendReplyBack(back, 90)
}

//opcode21
func UserSendUnreward(sess *Session, reader []byte) bool {
	type DataBack struct {
		Reward []UnrewardBack
	}

	var back DataBack
	back.Reward = sess.user.purchase.GetAllUnreward()
	if back.Reward == nil {
		return true
	}
	return sess.SendReplyBack(back, 21)
}

//opcode22
func UserGetUnreward(sess *Session, reader []byte) bool {
	//log.Debug("The data recv is ", string(reader.Data[:]), sess.user.uid)

	type Data struct {
		PID int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		log.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}

	type DataBack struct {
		Ret   int
		PID   int
		Gold  int
		Stone int
	}
	var back DataBack
	back.PID = msg.PID

	if !sess.user.purchase.CanGetReward(msg.PID) {
		back.Ret = 1
		back.Gold = sess.user.gold
		back.Stone = sess.user.stone
		return sess.SendReplyBack(back, 22)
	}

	err = sess.user.purchase.GetReward(msg.PID)
	if err != nil {
		sess.Error("Failed GetReward", err)
		return false
	}

	back.Ret = 0
	back.Gold = sess.user.gold
	back.Stone = sess.user.stone

	return sess.SendReplyBack(back, 22)
}

//opcode28
func UserBuyCard(sess *Session, reader []byte) bool {
	//sess.Debug("The data recv is ", string(reader.Data[:]), sess.user.uid)

	type Data struct {
		Id   int
		Type int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}

	if msg.Type == RewardType_Hero {
		if sess.user.Hero.IsOwned(msg.Id) {
			sess.user.Error("The heroid is already have")
			return false
		}

		if HeroInfo[msg.Id].SellType != RewardType_Stone {
			sess.user.Error("The hero id is not for sell", msg.Id)
			return false
		}

	} else if msg.Type == RewardType_Arm {
		if sess.user.Arm.IsOwned(msg.Id) {
			sess.user.Error("The armid is already have")
			return false
		}

		if ArmInfo[msg.Id].SellType != RewardType_Stone {
			sess.user.Error("The arm id is not for sell", msg.Id)
			return false
		}

	} else {
		sess.user.Error("Wrong type")
		return false
	}

	price := GetPriceOfCard(msg.Id, msg.Type)
	if !sess.user.VerifyWealth(RewardType_Stone, price) {
		sess.user.Error("User has not enough stone")
		return false
	}
	if msg.Type == RewardType_Hero {
		err = sess.user.Hero.AddNewHero(msg.Id, 1, false)
		if err != nil {
			sess.user.Error("Failed AddNewHero", err)
			return false
		}
	} else if msg.Type == RewardType_Arm {
		err = sess.user.Arm.AddNewArm(msg.Id, 1)
		if err != nil {
			sess.user.Error("Failed AddNewArm", err)
			return false
		}
	}

	err = sess.user.CostWealth(RewardType_Stone, price)
	if err != nil {
		sess.user.Error("Failed CostStone", err)
		return false
	}

    GM.GMDayLog(sess.user.uid,StatIDBuyArmHero, price)

	type DataBack struct {
		Id    int
		Type  int
		Stone int
	}
	var back DataBack
	back.Id = msg.Id
	back.Type = msg.Type
	back.Stone = sess.user.stone

	return sess.SendReplyBack(back, 28)
}

///////////////////////////////////////////////////// Purchase ///////////////////////////////////////////
type _PurchaseData struct {
	id            int
	purchase_type int
	exit_time     int64
	recent_time   int64
}

type PurchaseReward struct {
	RewardType   int
	RewardValue  int
	PurchaseType int
	PurchaseId   int
}
type PurchaseManager struct {
	purchase map[int]_PurchaseData
	unreward map[int]PurchaseReward
	pkey     int
	user     *User
}

func NewPurchaseManager() *PurchaseManager {
	var p PurchaseManager
	p.purchase = make(map[int]_PurchaseData)
	p.unreward = make(map[int]PurchaseReward)
	return &p
}

func (this *PurchaseManager) SetUser(u *User) {
	this.user = u
}

func (this *PurchaseManager) FirstLoginOfDay() (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	for id, v := range this.purchase {
		switch v.purchase_type {
		case PurchaseType_NormalStone, PurchaseType_SuperStone, PurchaseType_MonthStone:
			err = this.processRewardPurchase(id)
			if err != nil {
				return err
			}
		case PurchaseType_MonthPower:
			err = this.endMonthPower(id)
			if err != nil {
				return err
			}
		case PurchaseType_MonthHero:
			err = this.endMonthHero(id)
			if err != nil {
				return err
			}
		default:
			err = this.processTimeLimitPurchase(id)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (this *PurchaseManager) Init() (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	this.pkey = 10
	_, err = dbconn.Do("SET", this.user.GetUidUsedInDB()+":p_key", 10)
	if err != nil {
		return err
	}
	return nil
}

func (this *PurchaseManager) Load() (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	reply, err := redis.Values(dbconn.Do("SMEMBERS", this.user.GetUidUsedInDB()+":purchases"))
	if err != nil {
		this.user.Error("Failed SMEMBERS purchase", err)
		return err
	}

	for i := 0; i < len(reply); i++ {
		id, err := redis.Int(reply[i], nil)
		if err != nil {
			return err
		}

		var tmp _PurchaseData
		reply2, err := redis.Values(dbconn.Do("HMGET", this.user.GetUidUsedInDB()+":purchase:"+strconv.Itoa(id), "purchase_type", "exit_time", "recent_time"))
		if err != nil {
			this.user.Error("failed get purchases", err)
			return err
		}
		tmp.id = id
		tmp.purchase_type, err = redis.Int(reply2[0], nil)
		tmp.exit_time, err = redis.Int64(reply2[1], nil)
		tmp.recent_time, err = redis.Int64(reply2[2], nil)
		if err != nil {
			return err
		}
		this.purchase[id] = tmp
	}

	reply, err = redis.Values(dbconn.Do("SMEMBERS", this.user.GetUidUsedInDB()+":unrewards"))
	if err != nil {
		return err
	}

	for i := 0; i < len(reply); i++ {
		id, err := redis.Int(reply[i], nil)
		if err != nil {
			return err
		}

		var tmp PurchaseReward
		reply2, err := redis.Values(dbconn.Do("HMGET", this.user.GetUidUsedInDB()+":unreward:"+strconv.Itoa(id), "reason", "type", "value"))
		if err != nil {
			this.user.Error("failed get unrewards", err)
			return err
		}
		tmp.PurchaseId = id
		tmp.PurchaseType, err = redis.Int(reply2[0], nil)
		tmp.RewardType, err = redis.Int(reply2[1], nil)
		tmp.RewardValue, err = redis.Int(reply2[2], nil)
		if err != nil {
			return err
		}
		this.unreward[id] = tmp
	}

	this.pkey, err = redis.Int(dbconn.Do("GET", this.user.GetUidUsedInDB()+":p_key"))
	if err != nil {
		this.user.Error("Failed GET pkey", err)
		return err
	}

	return nil
}

func (this *PurchaseManager) processTimeLimitPurchase(pid int) (err error) {
	end_day := time.Unix(this.purchase[pid].exit_time, 0).YearDay()
	today := time.Now().YearDay()
	if end_day < today {
		err = this.delPurchase(pid)
		if err != nil {
			return err
		}
	}
	return nil
}

func (this *PurchaseManager) endMonthPower(pid int) (err error) {
	err = this.user.SetMaxPower(10)
	if err != nil {
		return err
	}
	err = this.delPurchase(pid)
	if err != nil {
		this.user.Error("Failed delPurchase", err)
		return err
	}
	return nil
}

func (this *PurchaseManager) endMonthHero(pid int) (err error) {
	err = this.user.DisableHeroVIP()
	if err != nil {
		return err
	}
	err = this.delPurchase(pid)
	if err != nil {
		this.user.Error("Failed delPurchase", err)
		return err
	}
	return nil

}

func (this *PurchaseManager) processRewardPurchase(pid int) (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	end_day := time.Unix(this.purchase[pid].exit_time, 0).YearDay()
	recent_day := time.Unix(this.purchase[pid].recent_time, 0).YearDay()
	today := time.Now().YearDay()

	p_type := this.purchase[pid].purchase_type

	tmp, ok := this.unreward[pid]
	num := 0
	switch p_type {
	case PurchaseType_SuperStone:
		num = 1500
	case PurchaseType_NormalStone:
		num = 300
	case PurchaseType_MonthStone:
		num = 100
	}

	tmp.RewardType = RewardType_Stone
	for i := recent_day; i <= today; i++ {
		tmp.RewardValue += num
	}
	this.unreward[pid] = tmp

	if !ok {
		_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":unrewards", pid)
		if err != nil {
			return err
		}
	}

	_, err = dbconn.Do("HMSET", this.user.GetUidUsedInDB()+":unreward:"+strconv.Itoa(pid), "reward_type", tmp.RewardType, "reward_value", tmp.RewardValue, "purchase_type", p_type)
	if err != nil {
		return err
	}

	if end_day <= today {
		err = this.delPurchase(pid)
		if err != nil {
			return err
		}
	} else {
		tmp := this.purchase[pid]
		tmp.recent_time = time.Now().Unix()
		this.purchase[pid] = tmp

		_, err = dbconn.Do("HSET", this.user.GetUidUsedInDB()+":unreward:"+strconv.Itoa(pid), "recent_time", tmp.recent_time)
		if err != nil {
			return err
		}
	}
	return nil
}

func (this *PurchaseManager) delPurchase(pid int) (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	_, err = dbconn.Do("SREM", this.user.GetUidUsedInDB()+":purchases", pid)
	if err != nil {
		return err
	}
	_, err = dbconn.Do("DEL", this.user.GetUidUsedInDB()+":purchase:"+strconv.Itoa(pid))
	if err != nil {
		return err
	}
	delete(this.purchase, pid)
	return nil
}
func (this *PurchaseManager) CanGetReward(pid int) bool {
	_, ok := this.unreward[pid]
	return ok
}

func (this *PurchaseManager) GetReward(pid int) (err error) {
	v, ok := this.unreward[pid]
	if !ok {
		return nil
	}

	_, err = this.user.ProcessReward(v.RewardType, v.RewardValue)
	if err != nil {
		return err
	}

	delete(this.unreward, pid)

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	_, err = dbconn.Do("SREM", this.user.GetUidUsedInDB()+":unrewards", pid)
	if err != nil {
		return err
	}

	_, err = dbconn.Do("DEL", this.user.GetUidUsedInDB()+":unreward:"+strconv.Itoa(pid))
	if err != nil {
		return err
	}
	return nil
}

func (this *PurchaseManager) addPurchase(p _PurchaseData) (err error) {
	this.purchase[p.id] = p
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":purchases", p.id)
	if err != nil {
		return err
	}

	_, err = dbconn.Do("HMSET", this.user.GetUidUsedInDB()+":purchase:"+strconv.Itoa(p.id), "purchase_type", p.purchase_type, "exit_time", p.exit_time, "recent_time", p.recent_time)
	if err != nil {
		return err
	}
	return nil
}

func (this *PurchaseManager) addUnreward(r PurchaseReward) (err error) {
	v, ok := this.unreward[r.PurchaseId]
	if ok {
		r.RewardValue += v.RewardValue
	}

	this.unreward[r.PurchaseId] = r

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	if !ok {
		_, err = dbconn.Do("SADD", this.user.GetUidUsedInDB()+":unrewards", r.PurchaseId)
		if err != nil {
			return err
		}
	}

	_, err = dbconn.Do("HMSET", this.user.GetUidUsedInDB()+":unreward:"+strconv.Itoa(r.PurchaseId), "reward_type", r.RewardType, "reward_value", r.RewardValue, "purchase_type", r.PurchaseType)
	if err != nil {
		return err
	}
	return nil
}

func (this *PurchaseManager) purchaseNormalGold() (lt int, err error) {
	_, err = this.user.ProcessReward(RewardType_Gold, 3000)
	if err != nil {
		return -1, err
	}

	now := time.Now().Unix()
	var tmp _PurchaseData
	tmp.id = PurchaseType_NormalGold
	tmp.purchase_type = PurchaseType_NormalGold
	tmp.exit_time = SharpDay(now) + 24*60*60
	tmp.recent_time = now

	err = this.addPurchase(tmp)
	return int(tmp.exit_time - now), err
}

func (this *PurchaseManager) purchaseSuperGold() (lt int, err error) {
	_, err = this.user.ProcessReward(RewardType_Gold, 30000)
	if err != nil {
		return -1, err
	}

	now := time.Now().Unix()
	var tmp _PurchaseData
	tmp.id = PurchaseType_SuperGold
	tmp.purchase_type = PurchaseType_SuperGold
	tmp.exit_time = SharpDay(now) + 7*24*60*60
	tmp.recent_time = now

	err = this.addPurchase(tmp)
	return int(tmp.exit_time - now), err
}

func (this *PurchaseManager) purchaseSuperStone() (lt int, err error) {
	_, err = this.user.ProcessReward(RewardType_Stone, 4500)
	if err != nil {
		return 0, err
	}

	this.pkey, err = this.user.AssignUnrewardID()
	if err != nil {
		this.user.Error("Failed AssignUnrewardID", err)
		return 0, err
	}

	var tmp _PurchaseData
	tmp.id = this.pkey
	tmp.purchase_type = PurchaseType_SuperStone
	tmp.exit_time = SharpDay(time.Now().Unix()) + 2*24*60*60
	tmp.recent_time = time.Now().Unix()

	err = this.addPurchase(tmp)
	if err != nil {
		this.user.Error("Failed addPurchase", err)
		return 0, err
	}
	return 0, err
}

func (this *PurchaseManager) purchaseNormalStone() (lt int, err error) {
	_, err = this.user.ProcessReward(RewardType_Stone, 600)
	if err != nil {
		return -1, err
	}

	this.pkey, err = this.user.AssignUnrewardID()
	if err != nil {
		this.user.Error("Failed AssignUnrewardID", err)
		return 0, err
	}

	now := time.Now().Unix()
	var tmp _PurchaseData
	tmp.id = this.pkey
	tmp.purchase_type = PurchaseType_NormalStone
	tmp.exit_time = SharpDay(now) + 2*24*60*60
	tmp.recent_time = now

	err = this.addPurchase(tmp)
	return 0, err
}

func (this *PurchaseManager) purchaseMonthPower() (lt int, err error) {
	err = this.user.SetMaxPower(20)
	if err != nil {
		return -1, err
	}

	now := time.Now().Unix()
	var tmp _PurchaseData
	tmp.id = PurchaseType_MonthPower
	tmp.purchase_type = PurchaseType_MonthPower
	tmp.exit_time = SharpDay(now) + 60*60*24*30
	tmp.recent_time = now

	err = this.addPurchase(tmp)
	return int(tmp.exit_time - now), err
}

func (this *PurchaseManager) purchaseMonthStone() (lt int, err error) {
	now := time.Now().Unix()
	var tmp _PurchaseData
	tmp.id = PurchaseType_MonthStone
	tmp.purchase_type = PurchaseType_MonthStone
	tmp.exit_time = SharpDay(now) + 60*60*24*30
	tmp.recent_time = now

	err = this.addPurchase(tmp)
	if err != nil {
		return -1, err
	}

	var r PurchaseReward
	r.PurchaseId = tmp.id
	r.PurchaseType = tmp.purchase_type
	r.RewardType = RewardType_Stone
	r.RewardValue = 100

	err = this.addUnreward(r)
	if err != nil {
		this.user.Error("Failed addUnreward", err)
		return -1, err
	}

	var u UnrewardBack
	u.PID = r.PurchaseId
	u.PType = r.PurchaseType
	u.RType = r.RewardType
	u.RValue = r.RewardValue

	type DataBack struct {
		Reward []UnrewardBack
	}

	var back DataBack
	back.Reward = append(back.Reward, u)

	sess := this.user.GetSession()
	if sess == nil {
		return -1, SessErr
	}

	sess.SendReplyBack(back, 21)

	return int(tmp.exit_time - now), nil
}

func (this *PurchaseManager) purchaseMonthHero() (lt int, err error) {
	err = this.user.EnableHeroVIP()
	if err != nil {
		return -1, err
	}

	now := time.Now().Unix()
	var tmp _PurchaseData
	tmp.id = PurchaseType_MonthHero
	tmp.purchase_type = PurchaseType_MonthHero
	tmp.exit_time = SharpDay(now) + 60*60*24*30
	tmp.recent_time = now

	err = this.addPurchase(tmp)
	return int(tmp.exit_time - now), err
}

func (this *PurchaseManager) PurchaseHandle(id int) (lt int, err error) {
	var f func() (int, error)
	switch id {
	case PurchaseType_NormalGold:
		f = this.purchaseNormalGold
	case PurchaseType_SuperGold:
		f = this.purchaseSuperGold
	case PurchaseType_NormalStone:
		f = this.purchaseNormalStone
	case PurchaseType_SuperStone:
		f = this.purchaseSuperStone
	case PurchaseType_MonthPower:
		f = this.purchaseMonthPower
	case PurchaseType_MonthStone:
		f = this.purchaseMonthStone
	case PurchaseType_MonthHero:
		f = this.purchaseMonthHero
	default:
		return -1, errors.New("No reponse purchase handle process")
	}
	this.user.Debug("Find right handle")
	return f()
}

type PurchaseBack struct {
	PID   int
	PType int
	PEnd  int64
}

func (this *PurchaseManager) GetAllPurchaseState() (p []PurchaseBack) {
	p = make([]PurchaseBack, len(this.purchase))
	index := 0
	for pid, v := range this.purchase {
		p[index].PID = pid
		p[index].PType = v.purchase_type
		if v.purchase_type == PurchaseType_NormalStone {
			p[index].PEnd = 0
		} else if v.purchase_type == PurchaseType_SuperStone {
			p[index].PEnd = 0
		} else {
			p[index].PEnd = v.exit_time - time.Now().Unix()
		}
		index++
	}
	return p
}

type UnrewardBack struct {
	RType  int
	RValue int
	PType  int
	PID    int
}

func (this *PurchaseManager) GetAllUnreward() (r []UnrewardBack) {
	r = make([]UnrewardBack, len(this.unreward))
	index := 0
	for pid, v := range this.unreward {
		r[index].PID = pid
		r[index].PType = v.PurchaseType
		r[index].RType = v.RewardType
		r[index].RValue = v.RewardValue
		index++
	}
	return r
}

/////////////////////Buy card through stone ////////////////////////////////
var (
	PresentArm   = 74
	HistoryArms  = []int{}
	ArmEnd       = time.Date(2014, 4, 20, 0, 0, 0, 0, time.UTC).Unix()
	PresentHero  = 9
	HistoryHeros = []int{}
	HeroEnd      = time.Date(2014, 5, 1, 0, 0, 0, 0, time.UTC).Unix()
)

func getPriceOfArm(aid int) int {
	if aid == PresentArm {
		return ArmInfo[PresentArm].SellPrice
	}

	for _, id := range HistoryArms {
		if id == aid {
			return ArmInfo[PresentArm].SellPrice * 2
		}
	}
	return -1
}

func getPriceOfHero(hid int) int {
	if hid == PresentHero {
		return HeroInfo[PresentHero].SellPrice
	}

	for _, id := range HistoryHeros {
		if id == hid {
			return HeroInfo[PresentHero].SellPrice * 2
		}
	}
	return -1
}

func GetPriceOfCard(id int, t int) int {
	if t == RewardType_Arm {
		return getPriceOfArm(id)
	}
	if t == RewardType_Hero {
		return getPriceOfHero(id)
	}
	return -1
}
