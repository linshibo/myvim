package algorithm

import (
    "fmt"
    "math/rand"
    "time"
    "os"
    "io"
    "strings"
    "strconv"
)
func init(){
    rand.Seed(time.Now().UnixNano())
}

func swap(a, b *int){
    tmp:=*a
    *a=*b
    *b=tmp
}

func LCS(x, y string){
    b:=make([][]int, len(x))
    c:=make([][]int, len(x))
    for i:=0;i<len(x);i++{
        c[i]=make([]int, len(y))
        b[i]=make([]int, len(y))
    }
    up:=1
    left:=2
    leftUp:=3
    for i:=range x{
        for j:=range y{
            if i==0 || j==0 {
                if x[i]==y[j] {
                    c[i][j]=1
                    b[i][j]=leftUp
                }else{
                    if j>0{
                        c[i][j]=c[i][j-1]
                        b[i][j]=left
                    }
                    if i>0{
                        c[i][j]=c[i-1][j]
                        b[i][j]=up
                    }
                }
            }else{
                if x[i]==y[j] {
                    c[i][j]=c[i-1][j-1]+1
                    b[i][j]=leftUp
                }else if c[i-1][j]>=c[i][j-1] {
                    c[i][j]=c[i-1][j]
                    b[i][j]=up
                }else  {
                    c[i][j]=c[i][j-1]
                    b[i][j]=left
                }
            }
        }
    }
    for i, j:=len(x)-1,len(y)-1;i>=0 && j>=0 ;{
        //fmt.Println(i, j)
        if b[i][j]==leftUp{
            fmt.Printf("%c", x[i])
            i--
            j--
        }else if b[i][j]==up {
            i--
        }else if b[i][j]==left{
            j--
        }else {
            break
        }
    }
    fmt.Println(" ")
}

func FakeRandShuffle(data []int){
    for i:=0;i<len(data);i++{
        k:=rand.Intn(len(data))
        swap(&data[i], &data[k])
    }
}

func RandShuffle(data []int){
    if len(data)<=1 {
        return
    }
    for i:=0;i<len(data)-1;i++{
        k:=rand.Intn(len(data)-i-1)+i+1
        swap(&data[i], &data[k])
    }
    swap(&data[len(data)-1], &data[len(data)-2])
}

func BinarySearch(data []int, key int )int{
    if len(data)==0 {
        return -1
    }
    start:=0
    end:=len(data)-1
    for;start<=end;{
        m:=(start+end)/2
        if data[m]> key{
            end=m-1
        }else if data[m] < key {
            start=m+1
        }else{
            fmt.Println("BinarySearch succ ", m)
            return m
        }
    }
    return -1
}
func max(data []int)int{
    max:=0
    index:=0
    for i:= range data{
        if max < data[i]  {
            max = data[i]
        }
    }
    return index
}

//func FileSort(){
    //source , err:= os.Open("test.txt")
    //if err != nil {
        //fmt.Println(err)
        //return 
    //}
    //dst , err:= os.Open("dst.txt")
    //if err != nil {
        //fmt.Println(err)
        //return 
    //}
    //data:=make([]byte, 4000000)
    //data2:=make([]int, 1000000)
    //files:=make([]*os.File, 10)
    //for i:=0;i<10;i++{
        //_, err :=source.Read(data)
        //if err != nil {
            //fmt.Println(err)
            //return 
        //}
        //str := strings.Split(string(data), " ")
        //for j:=range data2{
            //data[j]=int(binary.Varint(data[index:index+4]))
            //index += 4
        //}
        //QuickSort(data)
        //files[i],err=os.Open(fmt.Sprintf("tmp_%s",i))
        //if err != nil {
            //fmt.Println(err)
            //return 
        //}
    //}
    //MergeSort(files, dst)
//}

type Buffer struct{
    data []int
    file *os.File
    pos int
}

func (b *Buffer)Getint()int{
    if b.data == nil || b.pos >= len(b.data)-1 {
        b.data= nil
        data:=make([]byte, 256)
        n, err := b.file.Read(data)
        if err != nil && err != io.EOF{
            fmt.Println(err)
            return -1
        }
        if n ==0  {
            fmt.Println(err)
            return -1
        }
        str:=strings.Split(string(data[0:n]), " ")
        fmt.Println("monitor ", string(data[0:n]))
        b.data=make([]int, len(str))
        for i:=range str{
            b.data[i], _ = strconv.Atoi(str[i])
        }
        fmt.Println("data  ", len(b.data), b.data)
    }
    //fmt.Println(b.pos, b.data)
    ret:=b.data[b.pos]
    b.pos++
    return ret
}

func newBuffer(f *os.File)*Buffer{
    b := Buffer{
        pos:0,
        file:f,
        data:nil,
    }
    return &b
}

//func MergeSort(files []*os.File, write *os.File){
    //data:=make([]int32, len(files))
    //buffs:=make([]Buffer, 10)
    //for i:= range data{
        //buffs[i]=newBuffer(files[i])
    //}
    //var idx int
    //for quit:= false;!quit;{
        //idx=max(data)
        //if data[i] == -1 {
            //break
        //}else{
            //write.write(data[idx])
            //data[i]=buffs[i].Getint()
        //}
    //}
//}

type BitMap struct{
    data []int32
}
func (b *BitMap)getBit(pos int)int{
    bucket := pos/32
    bucketPos := uint32( pos % 32 )
    return int((b.data[bucket]>>bucketPos)&1)
}
func (b *BitMap)setBit(pos ,value int){
    bucket := pos/32
    bucketPos := uint32 (pos % 32)
    if value ==0  {
        b.data[bucket] = b.data[bucket] & (^(1<<bucketPos))
    }else{
        b.data[bucket] = b.data[bucket] | (1<<bucketPos)
    }
}
func NewBitMap(n int)*BitMap{
    tmp:=BitMap{
        data:make([]int32, n/32+1), 
    }
    return &tmp
}

func BitSort(data []int){
    b:=NewBitMap(1000000)
    for i:=range data{
        b.setBit(data[i], 1)
    }
    for i:=0;i<1000000;i++{
        if b.getBit(i)==1 {
            fmt.Println(i)
        }
    }
}

func quicksortPartision(data []int ) int{
    if len(data)<=1 {
        return 0 
    }
    key:=data[len(data)-1]
    i:=0
    for j:=0 ; j<len(data)-1;j++{
        if data[j] <= key {
            swap(&data[i], &data[j])
            i++
        }
    }
    swap(&data[len(data)-1], &data[i])
    return i
}

func QuickSort(data []int ){
    if len(data) <= 1 {
        return 
    }
    k := quicksortPartision(data)
    if k != 0 {
       QuickSort(data[0:k])
    }
    if k != len(data)-1 {
       QuickSort(data[k+1:])
    }
}

func KMPNext(sub string) []byte{
    next:=make([]byte, len(sub))
    next[0]=1
    k:=byte(0)
    for i:=1; i<len(sub); i++{
        for;k>0 && sub[k] != sub[i];{
            k = next[k]
        }
        if sub[k] == sub[i]{
            k++
        }
        next[i]=k
    }
    return next
}

func KMPMatch(src, sub string) {
    fmt.Println("KMP src:" , src, "sub:", sub)
    j := byte(0)
    next := KMPNext(sub)
    for i := byte(0); i < byte(len(src)) && j< byte(len(sub)); i++ {
        for j > 0 && sub[j] != src[i] {
            j = next[j] 
        }
        if sub[j] == src[i] {
            j++
        }
        if j == byte(len(sub)) {
            fmt.Println("match succ ", i-byte(len(sub))+1,i)
            j = next[j-1]
        }
    }
}
type Heap struct{
    data []int
    len int
}
func NewHeap(s []int)*Heap{
    return &Heap{
        data:s, 
    }
}
func Parent(i int)int{
    if i==0 {
        return 0
    }
    return (i+1)/2-1; 
}
func LeftChild(i int)int{
    return (i+1)*2-1; 
}
func RightChild(i int)int{
    return (i+1)*2; 
}

//var aa,bb int

func (h *Heap)maxHeapfyPromote(i ,len  int ){
    //aa++
    l := LeftChild(i)
    r := RightChild(i)
    large:=i
    if l<len && r<len{
        if h.data[r] > h.data[l] {
            large = r
        }else{
            large = l
        }
    }else{
        if l<len {
            large = l
        }
        if r <len {
            large = r
        }
    }
    if large != i {
        swap(&h.data[large], &h.data[i])
        h.maxHeapfyPromote(large, len)
    }
}

func (h *Heap)HeapSortPromote(){
    lenth:=len(h.data)
    h.buildMaxHeap()
    s:=make([]int, lenth)
    for i:=0;i<len(h.data);i++{
        s[i]=h.data[0]
        h.data[0]=0
        h.maxHeapfyPromote(0, lenth)
    }
    //for i:=range s{
        //h.data[i]=s[i]
    //}
}

func (h *Heap)HeapSort(){
    lenth:=len(h.data)
    h.buildMaxHeap()
    //fmt.Println("buildMaxHeap finish", h.data)
    for i:=len(h.data)-1;i>=1;i--{
        tmp:=h.data[0] 
        h.data[0]=h.data[i]
        h.data[i]=tmp
        lenth--
        h.maxHeapfy(0, lenth)
    }
}

func (h *Heap)buildMaxHeap(){
    for i:=len(h.data)/2-1;i>=0;i--{
        h.maxHeapfy(i, len(h.data))
    }
}

func (h *Heap)maxHeapfy(i ,len  int ){
    //bb++
    l := LeftChild(i)
    r := RightChild(i)
    large:=0
    if l<len && h.data[l] > h.data[i] {
        large = l
    }else{
        large = i
    }
    if r<len && h.data[r] > h.data[large] {
        large = r
    }
    if large != i {
        tmp:=h.data[i] 
        h.data[i]=h.data[large]
        h.data[large]=tmp
        h.maxHeapfy(large, len)
    }
}

func (h *Heap)buildMinHeap(){
    for i:=len(h.data)/2-1;i>=0;i--{
        h.minHeapfy(i, len(h.data))
    }
}

func (h *Heap)minHeapfy(i ,len  int ){
    l := LeftChild(i)
    r := RightChild(i)
    min:=0
    if l<len && h.data[l] < h.data[i] {
        min = l
    }else{
        min = i
    }
    if r<len && h.data[r] < h.data[min] {
        min = r
    }
    if min != i {
        tmp:=h.data[i] 
        h.data[i]=h.data[min]
        h.data[min]=tmp
        h.minHeapfy(min, len)
    }
}

func GetTopKLess2(data []int, k int){
    if len(data)<=k {
        return 
    }
    r:=rand.Intn(len(data))
    //swap(&data[len(data)-1], &data[r])
    key:=data[r]
    i:=0
    for j:=0 ; j<len(data);j++{
        if data[j] <= key {
            swap(&data[i], &data[j])
            i++
        }
    }
    if i <  k {
        GetTopKLess2(data[i:], k-i)
    }else if i > k {
        GetTopKLess2(data[0:i], k)
    }
    //fmt.Println(data[0:k])

}

func GetTopKLess(data []int, k int){
    h:=NewHeap(data[0:k])
    h.buildMaxHeap()
    //fmt.Println(h.data)
    for i:=k;i<len(data);i++{
        if data[i] < h.data[0] {
            //fmt.Println("exchange ",data[i], h.data[0])
            tmp:=data[i] 
            data[i]=h.data[0]
            h.data[0]=tmp
            h.maxHeapfy(0, k)
            //fmt.Println("ls ", h.data)
        }
    }
    return 
}
