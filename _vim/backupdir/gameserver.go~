package gameserver

import (
	"encoding/binary"
	"github.com/garyburd/redigo/redis"
	"io"
	"net"
	"os"
	"sanguo/base/log"
	"sanguo/db"
	. "sanguo/systemdata"
	"sync"
)

type GameServer struct {
	online map[int32]*Session
	lock   sync.RWMutex
	Host   string
}

var GM GMQueue

func (server *GameServer) Start() {
	// load system data
	err := InitRedisGlobleVar()
	if err != nil {
		log.Error("Failed InitRedisGlobleVar", err)
		return
	}
	ret := LoadSystemDataFromConf()
	if !ret {
		log.Error("Failed load system data")
		return
	}

	if !LoadTopic() {
		log.Error("Failed load topic data")
		return
	}

	go GM.Start()

	go LoadActivityEveryDay()

	go autoUpdatePKUsers()

	tcpAddr, err := net.ResolveTCPAddr("tcp4", server.Host)
	if err != nil {
		log.Error(err.Error())
		os.Exit(-1)
	}
	listener, err := net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		log.Error(err.Error())
		os.Exit(-1)
	}
	for {
		conn, err := listener.Accept()
		if err != nil {
			continue
		}
		log.Debug("Accept a new connection")
		go handleClient(conn)
	}
}

func handleClient(conn net.Conn) {

	defer conn.Close()
	channel := make(chan []byte, 1024)
	go StartSession(channel, conn)

	header := make([]byte, 2)
	for {
		/**block until recieve len(header)**/
		n, err := io.ReadFull(conn, header)
		if n == 0 && err == io.EOF {
			//Opposite socket is closed
			log.Debug("Socket closed and read 0 and eof")
			break
		} else if err != nil {
			//Sth wrong with this socket
			log.Debug("Socket read wrong", err)
			break
		}

		//data length is in header, and flag + opcode is 4
		size := binary.LittleEndian.Uint16(header) + 4

		data := make([]byte, size)
		n, err = io.ReadFull(conn, data)
		if n == 0 && err == io.EOF {
			log.Debug("Socket closed")
			break
		} else if err != nil {
			log.Debug("Socket wrong", err)
			break
		}
		channel <- data //send data to Client to process
	}
	close(channel)
}

func InitRedisGlobleVar() error {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	uid_flag, err := redis.Bool(dbconn.Do("EXISTS", "uid"))
	if err != nil {
		return err
	}

	if !uid_flag {
		_, err := dbconn.Do("SET", "uid", 0)
		if err != nil {
			return nil
		}
	}

	nameid_flag, err := redis.Bool(dbconn.Do("EXISTS", "nameid"))
	if err != nil {
		return err
	}

	if !nameid_flag {
		_, err := dbconn.Do("SET", "nameid", 0)
		if err != nil {
			return nil
		}
	}

	tid_flag, err := redis.Bool(dbconn.Do("EXISTS", "tid"))
	if err != nil {
		return err
	}

	if !tid_flag {
		_, err := dbconn.Do("SET", "tid", 0)
		if err != nil {
			return nil
		}
	}

	top_1_flag, err := redis.Bool(dbconn.Do("EXISTS", "top_c_1"))
	if err != nil {
		return err
	}

	if !top_1_flag {
		_, err := dbconn.Do("SET", "top_c_1", 0)
		if err != nil {
			return nil
		}
	}

	top_2_flag, err := redis.Bool(dbconn.Do("EXISTS", "top_c_2"))
	if err != nil {
		return err
	}

	if !top_2_flag {
		_, err := dbconn.Do("SET", "top_c_2", 0)
		if err != nil {
			return nil
		}
	}

	return nil
}
