package router

import (
	"GameManager/config"
	"GameManager/gameserver"
	"GameManager/user"
	"database/sql"
	"encoding/json"
	"fmt"
	_ "github.com/Go-SQL-Driver/MySQL"
	"github.com/garyburd/redigo/redis"
	"github.com/go-martini/martini"
	"github.com/martini-contrib/binding"
	"github.com/martini-contrib/render"
	"github.com/martini-contrib/sessionauth"
	"github.com/martini-contrib/sessions"
	"io/ioutil"
	"net/http"
	"os"
	"sanguo/base/log"
	"sort"
	//"strconv"
	"bytes"
	"os/exec"
	"strings"
	"time"
)

const (
	StatIDRegister   = 100000
	StatIDLogin      = 100001
	StatIDOnlineNum  = 100002
	StatIDOnlineTime = 100003
	StatIDFightBegin = 100004
	StatIDFightWin   = 100005
	StatIDFightLose  = 100006
	//宝石消耗
	StatIDDrawCard           = 100100
	StatIDBuyPower           = 100101
	StatIDUseItemBeforeFight = 100102
	StatIDBuyArmHero         = 100103
)

const (
	cmd_check_user_online = 0xf001
	cmd_user_add          = 0xf002
	cmd_skip_guanqia      = 0xf003
	cmd_add_soldier       = 0xf004
	cmd_query_user_info   = 0xf005
	cmd_which_server      = 0xf006
	cmd_all_user_add      = 0xf007
	cmd_performance_test  = 0xf008
	cmd_player_infor      = 0xf009
)

type Return struct {
	Ret int
}

var (
	InitArm  = []int{53, 83, 376, 377}
	InitHero = []int{5}
)

var Pool_55556 *redis.Pool

var Pool_55555 *redis.Pool

const (
	MaxConnection = 10
)

type Handler struct {
	gameHandler  *gameserver.GameServer
	mysqlHandler *sql.DB
}
type Platforms struct {
	data map[string]Handler
}

var platforms Platforms

func UpdateServer(s *gameserver.GameServer) {
	h, ok := platforms.data[s.Name]
	log.Debug("UpdateServer ",s.Name, ok, s, h.gameHandler)
	if ok {
		h.gameHandler = s
		platforms.data[s.Name]=h
	}
	//for k, v := range platforms.data{
	//log.Debug("monitor ",k , v)
	//}
}
func (p *Platforms) getMysqlHandler(name string) *sql.DB {
	h, ok := p.data[name]
	if ok {
		return h.mysqlHandler
	}
	return nil
}

func (p *Platforms) getServerHandler(name string) *gameserver.GameServer {
	h, ok := p.data[name]
	if ok {
		return h.gameHandler
	}
	return nil
}

//var mysqlHandler *sql.DB

func init() {
	platforms.data = make(map[string]Handler)
	return
}

/**
* @brief 对ID取count(*) 操作
 */
func DoGetIDCount(mysqlHandler *sql.DB, id int) int {
	sqlStr := fmt.Sprintf("select count(*) from t_gm_permenent  where id=%d", id)
	log.Debug(sqlStr)
	return DoQueryReturnOne(mysqlHandler, sqlStr)
}

func DoGetDayIDCount(mysqlHandler *sql.DB, id int, day time.Time) int {
	sqlStr := fmt.Sprintf("select count(*) from t_gm_day_%4d%02d%02d where id=%d", day.Year(), day.Month(), day.Day(), id)
	log.Debug(sqlStr)
	return DoQueryReturnOne(mysqlHandler, sqlStr)

}

func DoGetDayIDCount1(mysqlHandler *sql.DB, id int, day time.Time) int {

	sqlStr := fmt.Sprintf("select sum(value) from t_gm_day_%4d%02d%02d where id=%d", day.Year(), day.Month(), day.Day(), id)
	log.Debug(sqlStr)
	return DoQueryReturnOne(mysqlHandler, sqlStr)

}

func DoQueryReturnTwo(mysqlHandler *sql.DB, sqlStr string) (int, int) {
	rows, err := mysqlHandler.Query(sqlStr)
	var result1 int = 0
	var result2 int = 0
	if err != nil {
		log.Error(err.Error())
		return result1, result2
	}
	for rows.Next() {
		rerr := rows.Scan(&result1, &result2)
		if rerr != nil {
			return result1, result2
		}
	}
	return result1, result2
}

func DoQueryReturnSlice(mysqlHandler *sql.DB, sqlStr string) []int {
	rows, err := mysqlHandler.Query(sqlStr)
	tmp := make([]int, 0)
	var result int = 0
	if err != nil {
		log.Error(err.Error())
		return tmp
	}
	for rows.Next() {
		rerr := rows.Scan(&result)
		if rerr != nil {
			return tmp
		}
		tmp = append(tmp, result)
	}
	return tmp
}

func DoQueryReturnOne(mysqlHandler *sql.DB, sqlStr string) int {
	rows, err := mysqlHandler.Query(sqlStr)
	var result int = 0
	if err != nil {
		log.Error(err.Error())
		return result
	}
	for rows.Next() {
		rerr := rows.Scan(&result)
		if rerr != nil {
			return result
		}
	}
	log.Debug("result", result)
	return result
}

func doReply(w http.ResponseWriter, back map[string]interface{}) {
	back_json, err := json.Marshal(back)
	if err != nil {
		log.Error("Failed encode json", err)
		return
	}
	w.Write(back_json)
	return
}

func RouterInit(m *martini.ClassicMartini) {
	m.Get("/api/public", func(r render.Render) {
		r.HTML(200, "public", nil)
	})
	m.Get("/api", sessionauth.LoginRequired, func(r render.Render) {
		r.HTML(200, "index", nil)
	})
	m.Get("/api/login", func(r render.Render) {
		r.HTML(200, "login", nil)
	})
	m.Get("/api/logout", sessionauth.LoginRequired, func(session sessions.Session, user sessionauth.User, r render.Render) {
		sessionauth.Logout(session, user)
		r.Redirect("/api/login")
	})
	m.Post("/api/login", binding.Bind(user.MyUserModel{}), func(session sessions.Session, postedUser user.MyUserModel, r render.Render, req *http.Request) {
		// You should verify credentials against a database or some other mechanism at this point.
		// Then you can authenticate this session.
		user := user.MyUserModel{}
		log.Debug("new login", postedUser.Username, postedUser.Password)
		if postedUser.Username == config.Config.User && postedUser.Password == config.Config.Passwd {
			log.Debug("AuthenticateSession")
			err := sessionauth.AuthenticateSession(session, &user)
			if err != nil {
				log.Error("AuthenticateSession fail")
				r.JSON(500, err)
				return
			}
			params := req.URL.Query()
			redirect := params.Get(sessionauth.RedirectParam)
			r.Redirect(redirect)
		} else {
			r.HTML(200, "login err", nil)
		}
		return
	})
	m.Get("/api/private", sessionauth.LoginRequired, func(r render.Render) {
		r.HTML(200, "private", nil)
	})

	//m.Post("/api/InitPlayer", InitPlayerInfo)
	m.Post("/api/Whichserver", sessionauth.LoginRequired, Whichserver)
	m.Post("/api/QueryUserInfo", sessionauth.LoginRequired, QueryUserInfo)
	//m.Get("/crossdomain.xml", sessionauth.LoginRequired, CrossDomain)
	m.Post("/api/SetGuanqia", sessionauth.LoginRequired, SetGuanqia)
	//m.Post("/api/AddGold", sessionauth.LoginRequired, AddGold)
	m.Post("/api/UserAdd", sessionauth.LoginRequired, UserAdd)
	//m.Post("/api/AddHero", AddHero)
	//m.Post("/api/AddPower", AddPower)
	m.Post("/api/AddSoldier", sessionauth.LoginRequired, AddSoldier)
	//m.Post("/api/AddStone", sessionauth.LoginRequired, AddStone)
	m.Post("/api/AddAllThing", sessionauth.LoginRequired, AddAllThing)
	m.Post("/api/GetRemain", sessionauth.LoginRequired, GetRemain)
	m.Post("/api/GetGuanqiaStat", sessionauth.LoginRequired, GetGuanqiaStat)
	//m.Post("/api/GetOnlineNum", GetOnlineNum)
	m.Post("/api/GetDayCharge", sessionauth.LoginRequired, GetDayCharge)
	m.Post("/api/GetDayxiaofei", sessionauth.LoginRequired, GetDayxiaofei)
	m.Post("/api/GetMonthCharge", sessionauth.LoginRequired, GetMonthCharge)
	m.Post("/api/Performance", sessionauth.LoginRequired, Performance)
	m.Post("/api/GetTotalCharge", sessionauth.LoginRequired, GetTotalCharge)
	m.Post("/api/GetTotalRegister", sessionauth.LoginRequired, GetTotalRegister)
	m.Post("/api/GetDayStat", sessionauth.LoginRequired, GetDayStat)
	m.Post("/api/CheckUserOnline", sessionauth.LoginRequired, CheckUserOnline)
	m.Post("/api/GetGuanqiaTotal", sessionauth.LoginRequired, GetGuanqiaTotal)
	m.Post("/api/SaveCrash", SaveCrash)
	m.Post("/api/i4/SaveCrash", SaveCrashi4)
	m.Post("/api/itools/SaveCrash", SaveCrashitools)
	m.Post("/api/SystemCmd", sessionauth.LoginRequired, SystemCmd)
	m.Post("/api/Tongbu", sessionauth.LoginRequired, Tongbu)
	m.Post("/api/Startgame", sessionauth.LoginRequired, Startgame)
	m.Post("/api/Stopgame", sessionauth.LoginRequired, Stopgame) 
	m.Post("/api/SystemCmddl", sessionauth.LoginRequired, SystemCmddl)
	m.Post("/api/Sqlbackup", sessionauth.LoginRequired, Sqlbackup)
	m.Post("/api/Playinfo", sessionauth.LoginRequired, Playinfo)
	m.Get("/api/SaveCrash", sessionauth.LoginRequired, func(r render.Render) {
		r.HTML(200, "SaveCrash", nil)
	})
	//说明：第一个参数"mysql"表示打开一个MYSQL链接
	//第二个参数是一个DSN，格式是：[username[:password]@][protocol[(address)]]/dbname[?param1=value1&paramN=valueN]
	log.Debug(config.Config.Platforms)
	for i := range config.Config.Platforms {
		mysqlHandler, err := sql.Open("mysql", fmt.Sprintf("%s:%s@tcp(%s)/%s?charset=utf8", config.Config.Platforms[i].DBUser, config.Config.Platforms[i].DBPasswd, config.Config.Platforms[i].DBHost, config.Config.Platforms[i].DBDatabase))
		if err != nil {
			log.Error("mysql conn error\n")
			//return
		}
		err = mysqlHandler.Ping()
		if err != nil {
			log.Error("mysql ping error\n")
			//return
		}
		gameHandler := gameserver.Start(config.Config.Platforms[i].Platform, config.Config.Platforms[i].GameServerHost)
		if gameHandler == nil {
			fmt.Println("Failed connect gameserver", config.Config.Platforms[i].Platform)
		}
		platforms.data[config.Config.Platforms[i].Platform] = Handler{
			mysqlHandler: mysqlHandler,
			gameHandler:  gameHandler,
		}
	}
}

func CheckUserOnline(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return
	}

	type Data struct {
		Name     string
		Platform string
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
		return
	}

	log.Debug("In CheckUserOnline")
	in := make(map[string]interface{})
	in["name"] = msg.Name
	h := platforms.getServerHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	data, ret := h.DoRequest(in, cmd_check_user_online)
	if !ret {
		log.Debug(ret)
		return
	}
	type ret_data struct {
		Ret int
	}
	var msg2 ret_data
	err = json.Unmarshal(data, &msg2)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
		return
	}
	var m string
	if msg2.Ret == 0 {
		m = "玩家在线"
	} else if msg2.Ret == 1 {
		m = "玩家不在线"
	}
	w.Write([]byte(m))
	//fmt.Println(data)
	//back := make(map[string]interface{})

	//back["ret"] = 0
	//back["flag"] = msg2.Ret

	//doReply(w, back)
	return
}

const (
	PurchaseType_NormalGold  = 1
	PurchaseType_SuperGold   = 2
	PurchaseType_NormalStone = 3
	PurchaseType_SuperStone  = 4
	PurchaseType_MonthPower  = 5
	PurchaseType_MonthStone  = 6
	PurchaseType_MonthHero   = 7
)

func SaveCrash(w http.ResponseWriter, r *http.Request) {

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		return
	}
	filename := time.Now().String()
	filename = strings.TrimRight(filename, " +0800 CST")
	filename = strings.Replace(filename, " ", "_", -1)
	now := time.Now()
	filename = "./Crash/test/" + fmt.Sprintf("%4d%02d%02d", now.Year(), now.Month(), now.Day()) + "/" + filename + ".crash"
	fmt.Println("save Crash", body)
	file, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)
	if err != nil {
		log.Error(err)
		return
	}
	defer file.Close()
	file.Write(body)
	doReply(w, nil)
}

func SaveCrashi4(w http.ResponseWriter, r *http.Request) {

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		return
	}
	filename := time.Now().String()
	filename = strings.TrimRight(filename, " +0800 CST")
	filename = strings.Replace(filename, " ", "_", -1)
	now := time.Now()
	filename = "./Crash/i4/" + fmt.Sprintf("%4d%02d%02d", now.Year(), now.Month(), now.Day()) + "/" + filename + ".crash"
	fmt.Println("save Crash", body)
	file, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)
	if err != nil {
		log.Error(err)
		return
	}
	defer file.Close()
	file.Write(body)
	doReply(w, nil)
}

func SaveCrashitools(w http.ResponseWriter, r *http.Request) {

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		return
	}
	filename := time.Now().String()
	filename = strings.TrimRight(filename, " +0800 CST")
	filename = strings.Replace(filename, " ", "_", -1)
	now := time.Now()
	filename = "./Crash/itools/" + fmt.Sprintf("%4d%02d%02d", now.Year(), now.Month(), now.Day()) + "/" + filename + ".crash"
	fmt.Println("save Crash", body)
	file, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)
	if err != nil {
		log.Error(err)
		return
	}
	defer file.Close()
	file.Write(body)
	doReply(w, nil)
}

func GetTotalRegister(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return
	}

	type Data struct {
		Platform string
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
		return
	}

	h := platforms.getMysqlHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	totalRegister := DoGetIDCount(h, StatIDRegister)

	w.Write([]byte(fmt.Sprintf("总注册人数:%d", totalRegister)))

	return
}

func GetTotalCharge(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return
	}

	type Data struct {
		Platform string
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
		return
	}

	h := platforms.getMysqlHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}

	log.Debug("In GetTotalCharge")

	sqlStr := fmt.Sprintf("select count(distinct uid) from t_charge ;")
	totalCount := DoQueryReturnOne(h, sqlStr)

	sqlStr = fmt.Sprintf("select values from t_charge ;")
	itemSlice := DoQueryReturnSlice(h, sqlStr)
	var totalCharge int
	for item := range itemSlice {
		switch item {
		case PurchaseType_NormalGold:
			totalCharge += 1
		case PurchaseType_SuperGold:
			totalCharge += 1
		case PurchaseType_NormalStone:
			totalCharge += 1
		case PurchaseType_SuperStone:
			totalCharge += 1
		case PurchaseType_MonthPower:
			totalCharge += 1
		case PurchaseType_MonthStone:
			totalCharge += 1
		case PurchaseType_MonthHero:
			totalCharge += 1
		}
	}

	totalRegister := DoGetIDCount(h, StatIDRegister)

	w.Write([]byte(fmt.Sprintf("总充值人数:%d  总充值金额:%d   总注册人数:%d", totalCount, totalCharge, totalRegister)))
	return
}

func GetMonthCharge(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return
	}

	type Data struct {
		Platform string
		Year     int
		Mon      int
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		w.Write([]byte(err.Error()))
		log.Error("Failed decoding json", err)
	}

	h := platforms.getMysqlHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	log.Debug("In GetMonCharge")

	date := time.Date(msg.Year, (time.Month)(msg.Mon), 1, 0, 0, 0, 0, time.Local)
	nextMonDate := date.AddDate(0, 1, 0)

	sqlStr := fmt.Sprintf("select count(distinct uid) from t_charge where logtime >= %d and logtime <= %d ", date.Unix(), nextMonDate.Unix())
	monCount := DoQueryReturnOne(h, sqlStr)

	sqlStr = fmt.Sprintf("select value from t_charge where logtime >= %d and logtime <= %d ", date.Unix(), nextMonDate.Unix())
	itemSlice := DoQueryReturnSlice(h, sqlStr)
	var monCharge int
	for item := range itemSlice {
		switch item {
		case PurchaseType_NormalGold:
			monCharge += 1
		case PurchaseType_SuperGold:
			monCharge += 1
		case PurchaseType_NormalStone:
			monCharge += 1
		case PurchaseType_SuperStone:
			monCharge += 1
		case PurchaseType_MonthPower:
			monCharge += 1
		case PurchaseType_MonthStone:
			monCharge += 1
		case PurchaseType_MonthHero:
			monCharge += 1
		}
	}
	w.Write([]byte(fmt.Sprintf("月充值人数:%d  月充值金额:%d", monCount, monCharge)))

	return
}

func GetDayCharge(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return
	}

	type Data struct {
		Platform string
		Year     int
		Mon      int
		Day      int
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
	}

	h := platforms.getMysqlHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	log.Debug("In GetDayCharge")

	date := time.Date(msg.Year, (time.Month)(msg.Mon), msg.Day, 0, 0, 0, 0, time.Local)
	sqlStr := fmt.Sprintf("select count(distinct uid) from t_charge where logtime >= %d and logtime <= %d ", date.Unix(), date.AddDate(0, 0, 1).Unix())
	dayCount := DoQueryReturnOne(h, sqlStr)

	sqlStr = fmt.Sprintf("select value from t_charge where logtime >= %d and logtime <= %d ", date.Unix(), date.AddDate(0, 0, 1).Unix())
	itemSlice := DoQueryReturnSlice(h, sqlStr)
	var dayCharge int
	for item := range itemSlice {
		switch item {
		case PurchaseType_NormalGold:
			dayCharge += 1
		case PurchaseType_SuperGold:
			dayCharge += 1
		case PurchaseType_NormalStone:
			dayCharge += 1
		case PurchaseType_SuperStone:
			dayCharge += 1
		case PurchaseType_MonthPower:
			dayCharge += 1
		case PurchaseType_MonthStone:
			dayCharge += 1
		case PurchaseType_MonthHero:
			dayCharge += 1
		}
	}

	w.Write([]byte(fmt.Sprintf("日充值人数:%d  日充值金额:%d", dayCount, dayCharge)))
	return
}

func GetDayxiaofei(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return
	}

	type Data struct {
		Platform string
		Year2    int
		Mon2     int
		Day2     int
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
	}

	h := platforms.getMysqlHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	log.Debug("In GetDayxiaofei")

	date := time.Date(msg.Year2, (time.Month)(msg.Mon2), msg.Day2, 0, 0, 0, 0, time.Local)
	log.Debug(date)

	sqlStr := fmt.Sprintf("select count(distinct id) from t_gm_day_%4d%02d%02d", date.Year(), date.Month(), date.Day())
	dayxiaofei := DoQueryReturnOne(h, sqlStr)

	card := DoGetDayIDCount1(h, StatIDDrawCard, date)

	buypower := DoGetDayIDCount1(h, StatIDBuyPower, date)

	forefight := DoGetDayIDCount1(h, StatIDUseItemBeforeFight, date)

	rmhero := DoGetDayIDCount1(h, StatIDBuyArmHero, date)

	w.Write([]byte(fmt.Sprintf("日消费人数:%d  日消费金额:%d 抽卡使用量:%d 购买体力使用量:%d 战前道具使用量:%d 直接买兵买将使用量:%d", dayxiaofei, card+buypower+forefight+rmhero, card, buypower, forefight, rmhero)))
	return
}

func GetOnlineNum(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		return
	}

	type Data struct {
		Platform string
		Year     int
		Mon      int
		Day      int
		Hour     int
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
	}

	log.Debug("In GetOnlineNum")

	h := platforms.getMysqlHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	day := time.Date(msg.Year, (time.Month)(msg.Mon), msg.Day, msg.Hour, 0, 0, 0, time.Local)
	sqlStr := fmt.Sprintf("select value from t_gm_day_%4d%02d%02d where id=%d and logtime >= %d and logtime < %d order by logtime desc limit 1", day.Year(), day.Month(), day.Day(), StatIDOnlineNum, day.Unix(), day.Unix()+3600)
	log.Debug(sqlStr)
	value := DoQueryReturnOne(h, sqlStr)

	back := make(map[string]interface{})
	back["ret"] = 0
	back["value"] = value

	log.Debug(back)

	back_json, err := json.Marshal(back)
	if err != nil {
		log.Error("Failed encode json", err)
		return
	}
	w.Write(back_json)
	return
}

type guanqiaStat struct {
	Id    int
	Count int
}
type guanqiaSlic []guanqiaStat

func (p guanqiaSlic) Len() int {
	return len(p)
}
func (p guanqiaSlic) Less(i, j int) bool {
	return p[i].Count > p[j].Count || (p[i].Count == p[j].Count && p[i].Id < p[j].Id)
}
func (p guanqiaSlic) Swap(i, j int) {
	p[i], p[j] = p[j], p[i]
}
func GetGuanqiaTotal(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return
	}
	type Data struct {
		Platform string
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		w.Write([]byte(err.Error()))
		log.Error("Failed decoding json", err)
	}

	h := platforms.getMysqlHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}

	fmt.Println("GetGuanqiaTotal")
	totalRegister := DoGetIDCount(h, StatIDRegister)
	result := fmt.Sprintf("<br/>总注册人数:%d  <br/>", totalRegister)

	sqlStr := fmt.Sprintf("select id, Count(id) from t_gm_permenent  where id<10000 group by id")
	rows, err := h.Query(sqlStr)
	if err != nil {
		log.Error(err.Error())
	}
	ids := make(guanqiaSlic, 0)
	var tmp guanqiaStat
	for rows.Next() {
		rerr := rows.Scan(&tmp.Id, &tmp.Count)
		if rerr != nil {
			break
		}
		ids = append(ids, tmp)
	}
	sort.Sort(ids)
	for i := 0; i < len(ids); i++ {
		var tmp float32 = 0
		if i > 0 {
			tmp = float32(ids[i].Count) / float32(ids[i-1].Count) * 100
		}
		result += fmt.Sprintf("关卡:%d 通关人数:%d 与上一关百分比:%04.2f 通关百分比:%04.2f <br/>", ids[i].Id, ids[i].Count, tmp, float32(ids[i].Count)/float32(totalRegister)*100.0)
	}

	w.Write([]byte(result))
	return
}
func GetGuanqiaStat(w http.ResponseWriter, r *http.Request) {
	fmt.Println("GetGuanqiaStat")
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return
	}

	type Data struct {
		Platform string
		ID       int
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
		return
	}

	h := platforms.getMysqlHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	log.Debug("In GetGuanqiaStat", msg)

	count := DoGetIDCount(h, msg.ID)

	w.Write([]byte(fmt.Sprintf("关卡%d 通关人数:%d", msg.ID, count)))

	return
}
func GetDayStat(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		return
	}

	type Data struct {
		Platform string
		Year     int
		Mon      int
		Day      int
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
		return
	}

	day := time.Date(msg.Year, (time.Month)(msg.Mon), msg.Day, 0, 0, 0, 0, time.Local)

	sqlStr := fmt.Sprintf("select count(*) from (select distinct uid from t_gm_day_%4d%02d%02d where id=%d group by uid) as a", day.Year(), day.Month(), day.Day(), StatIDLogin)

	h := platforms.getMysqlHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	log.Debug(sqlStr)
	loginCount := DoQueryReturnOne(h, sqlStr)

	onlinetime := DoGetDayIDCount1(h, StatIDOnlineTime, day)

	registerCount := DoGetDayIDCount(h, StatIDRegister, day)

	FightBegin := DoGetDayIDCount(h, StatIDFightBegin, day)

	FightWin := DoGetDayIDCount(h, StatIDFightWin, day)

	FightLose := DoGetDayIDCount(h, StatIDFightLose, day)
	w.Write([]byte(fmt.Sprintf("%s 今日注册人数:%d ; 今日登录人数:%d 平均在线时间: %d:%d:%d ; 开始战斗: %d 战斗胜利: %d 战斗失败: %d 闪退强退: %d 胜利率：%d%% 失败率: %d%% 闪退强退率: %d%%", day.String()[0:10], registerCount, loginCount, onlinetime/loginCount/3600, onlinetime/loginCount/60-onlinetime/loginCount/3600*60, onlinetime/loginCount-onlinetime/loginCount/60*60, FightBegin, FightWin, FightLose, FightBegin-(FightWin+FightLose), FightWin*100/FightBegin, FightLose*100/FightBegin, (FightBegin-FightWin-FightLose)*100/FightBegin)))
	return
}

func GetRemain(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		return
	}

	type Data struct {
		Platform string
		Year     int
		Mon      int
		Day      int
		N        int
		M        int
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
		return
	}

	day := time.Date(msg.Year, (time.Month)(msg.Mon), msg.Day, 0, 0, 0, 0, time.Local)

	log.Debug("In GetRemain", msg, day)

	table1 := fmt.Sprintf("select distinct uid from t_gm_day_%4d%02d%02d  where id=%d", day.Year(), day.Month(), day.Day(), StatIDRegister)
	table2 := ""
	for i := msg.N; i <= msg.M; i++ {
		destDay := day.AddDate(0, 0, i)
		table2 += fmt.Sprintf("(select distinct uid from t_gm_day_%4d%02d%02d where id=%d)", destDay.Year(), destDay.Month(), destDay.Day(), StatIDLogin)
		if i != msg.M {
			table2 += " union "
		}
	}
	sqlStr := fmt.Sprintf("select count(*) from (%s) as a join (%s) as b on a.uid=b.uid;", table1, table2)
	log.Debug(sqlStr)

	h := platforms.getMysqlHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	loginCount := DoQueryReturnOne(h, sqlStr)

	registerCount := DoGetDayIDCount(h, StatIDRegister, day)

	w.Write([]byte(fmt.Sprintf("%s 注册人数:%d ; %s ~ %s 登录人数:%d 留存率:%f", day.String()[0:10], registerCount,
		day.AddDate(0, 0, msg.N).String()[5:10],
		day.AddDate(0, 0, msg.M).String()[5:10],
		loginCount, float32(loginCount)/float32(registerCount)*100)))

	return
}

func SetGuanqia(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return
	}

	type Data struct {
		Platform  string
		Name      string
		Chapter   int
		C_guanqia int
		S_guanqia int
		DB        int
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
	}
	log.Debug("In SetGuanqia", msg)

	in := make(map[string]interface{})
	in["name"] = msg.Name
	in["chapter"] = msg.Chapter
	in["c_guan"] = msg.C_guanqia
	in["s_guan"] = msg.S_guanqia

	h := platforms.getServerHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	data, ret := h.DoRequest(in, cmd_skip_guanqia)
	if !ret {
		log.Debug(ret)
		return
	}
	type ret_data struct {
		Ret int
	}
	var msg2 ret_data
	err = json.Unmarshal(data, &msg2)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
	}

	if msg2.Ret == 0 {
		w.Write([]byte("成功"))
	} else if msg2.Ret == 5 {
		w.Write([]byte("名字不存在"))
	} else {
		w.Write([]byte("系统错误"))
	}
	return
}

const (
	RewardType_Exp                 = 1
	RewardType_Gold                = 2
	RewardType_Arm                 = 3
	RewardType_Hero                = 4
	RewardType_Power               = 5
	RewardType_Stone               = 6
	RewardType_Money               = 7
	RewardType_RandomHeroByQuality = 8
	RewardType_RandomArmByStar     = 9
	RewardType_RandomArmByQuality  = 10
	RewardType_TrueHero            = 11
	RewardType_ArmCurr             = 12
	RewardType_HeroCurr            = 13
)

func UserAdd(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return
	}
	log.Debug("UserAdd", string(body))
	type Data struct {
		Platform string
		Name     string
		Type     int
		Value    int
	}
	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
	}

	in := make(map[string]interface{})
	in["Name"] = msg.Name
	in["Type"] = msg.Type
	in["Value"] = msg.Value
	h := platforms.getServerHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	data, ret := h.DoRequest(in, cmd_user_add)
	if !ret {
		log.Debug(ret)
		w.Write([]byte("出错啦"))
		return
	}
	var msg2 Return
	err = json.Unmarshal(data, &msg2)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
	}

	if msg2.Ret == 0 {
		w.Write([]byte("成功"))
	} else if msg2.Ret == 5 {
		w.Write([]byte("名字不存在"))
	} else {
		w.Write([]byte("系统错误"))
	}
	return
}

func Performance(w http.ResponseWriter, r *http.Request) {
	log.Debug("QueryPlayerInfo will start")
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		return
	}

	type Data struct {
		Platform string
		Type     string
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
		return
	}

	h := platforms.getServerHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}

	_, ret := h.DoRequest(msg, cmd_performance_test)
	if !ret {
		log.Debug("DoRequest return ", ret)
		return
	}
}

func Playinfo(w http.ResponseWriter, r *http.Request) {
	log.Debug("QueryPlayerInfo will start")
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		return
	}

	type Data struct {
		Platform string
		Name     string
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
		return
	}

	h := platforms.getServerHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}

	in := make(map[string]interface{})
	in["name"]=msg.Name
	_, ret := h.DoRequest(in, cmd_player_infor)
	if !ret {
		log.Debug("DoRequest return ", ret)
		return
	}
}

func QueryUserInfo(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		return
	}
	log.Debug("QueryPlayerInfo will start", string(body))
	type Data struct {
		Platform string
		Name     string
	}
	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
		return
	}

	in := make(map[string]interface{})
	in["name"] = msg.Name
	h := platforms.getServerHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	data, ret := h.DoRequest(in, cmd_query_user_info)
	if !ret {
		log.Debug("DoRequest return ", ret)
		return
	}

	type Data2 struct {
		Ret          int
		Gold         int
		Power        int
		Stone        int
		Chapter      int
		C_guanqia    int
		S_guanqia    int
		HeroCurr     int
		ArmCurr      int
		LastLogin    int
		RegisterTime int
		Uid          int
		Sid          int
	}
	var msg2 Data2
	err = json.Unmarshal(data, &msg2)
	if err != nil && msg2.Ret == 0 {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
		return
	}

	h2 := platforms.getMysqlHandler(msg.Platform)
	if h2 == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	lastlogin := time.Unix(int64(msg2.LastLogin), 0)
	//day := time.Date(msg.Year, (time.Month)(msg.Mon), msg.Day, 0, 0, 0, 0, time.Local)

	sqlStr := fmt.Sprintf("select sum(value) from t_gm_day_%4d%02d%02d where uid=%d and id=%d", lastlogin.Year(), lastlogin.Month(), lastlogin.Day(), msg2.Uid, StatIDOnlineTime)

	online := DoQueryReturnOne(h2, sqlStr)

	w.Write([]byte(fmt.Sprintf("Uid:%d Sid:%d 金币:%d 体力:%d 宝石:%d 兵魂:%d 将魂:%d 关卡:%d %d %d 最后登录时间:%s 注册时间:%s 在线时间的统计: %d:%d:%d", msg2.Uid, msg2.Sid, msg2.Gold, msg2.Power, msg2.Stone, msg2.ArmCurr, msg2.HeroCurr, msg2.Chapter, msg2.C_guanqia, msg2.S_guanqia, time.Unix(int64(msg2.LastLogin), 0), time.Unix(int64(msg2.RegisterTime), 0), online/3600, online/60-online/3600*60, online-online/60*60)))

	return
}

func AddSoldier(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		return
	}
	type Data struct {
		Platform string
		Name     string
		Id       int
		Level    int
		Type     int
	}
	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
	}
	in := make(map[string]interface{})
	in["name"] = msg.Name
	in["level"] = msg.Level
	in["id"] = msg.Id
	if msg.Type == 0 {
		in["type"] = RewardType_Arm
	} else {
		in["type"] = RewardType_Hero
	}
	h := platforms.getServerHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	data, ret := h.DoRequest(in, cmd_add_soldier)
	if !ret {
		log.Debug(ret)
		return
	}
	var msg2 Return
	err = json.Unmarshal(data, &msg2)
	if err != nil {
		log.Error("Failed decoding json", err)
	}

	if msg2.Ret == 0 {
		w.Write([]byte("成功"))
	} else if msg2.Ret == 5 {
		w.Write([]byte("名字不存在"))
	} else {
		w.Write([]byte("系统错误"))
	}
}

func AddAllThing(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		return
	}
	type Data struct {
		Platform string
		Num      int
		Type     int
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
	}

	in := make(map[string]interface{})
	if msg.Type == 0 {
		in["type"] = RewardType_Stone
	} else {
		in["type"] = RewardType_Gold
	}
	in["type"] = RewardType_Stone
	in["value"] = msg.Num
	h := platforms.getServerHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler")
		w.Write([]byte("系统错误"))
		return
	}
	data, ret := h.DoRequest(in, cmd_all_user_add)
	if !ret {
		log.Debug(ret)
		return
	}
	var msg2 Return
	err = json.Unmarshal(data, &msg2)
	if err != nil {
		log.Error("Failed decoding json", err)
	}
	if msg2.Ret == 0 {
		w.Write([]byte("成功"))
	} else if msg2.Ret == 5 {
		w.Write([]byte("名字不存在"))
	} else {
		w.Write([]byte("系统错误"))
	}
	return
}

func Whichserver(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return
	}
	log.Debug("Whichserver", string(body))
	type Data struct {
		Platform string
		Name     string
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
	}

	in := make(map[string]interface{})
	in["Name"] = msg.Name
	h := platforms.getServerHandler(msg.Platform)
	if h == nil {
		log.Error("get nil handler", msg.Platform)
		w.Write([]byte("系统错误"))
		return
	}

	data, ret := h.DoRequest(in, cmd_which_server)
	if !ret {
		log.Debug(ret)
		w.Write([]byte("出错啦"))
		return
	}

	var msg2 struct {
		Sid int
		Uid int
	}

	err = json.Unmarshal(data, &msg2)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
	}

	err = json.Unmarshal(data, &msg2)
	if err != nil {
		log.Error("Failed decoding json", err)
		w.Write([]byte(err.Error()))
	}

	w.Write([]byte(fmt.Sprintf("sid:%v uid:%v", msg2.Sid, msg2.Uid)))
	return
}

func system(s string) string {

	cmd := exec.Command("/bin/sh", "-c", s)
	var out bytes.Buffer
	cmd.Stdout = &out
	err := cmd.Run()
	if err != nil {
		log.Error(err)
	}
	log.Debug("xxxx %s", out.String())
	return out.String()
}

func SystemCmd(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return
	}
	log.Debug("SystemCmd", string(body))
	type Data struct {
		Name string
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
	}
	w.Write([]byte(system(fmt.Sprintf("/data/sh/mysql.sh %s", msg.Name))))
	return
}

func SystemCmddl(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {

		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return

	}
	log.Debug("SystemCmddl", string(body))
	type Data struct {
		Name string
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
	}
	w.Write([]byte(system(fmt.Sprintf("/data/sh/dlmysql.sh %s", msg.Name))))
	return
}

func Sqlbackup(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return
	}
	log.Debug("Sqlbackup", string(body))
	w.Write([]byte(system(fmt.Sprintf("/data/sh/sqlbackup.sh"))))

}

func Tongbu(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {

		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return

	}
	log.Debug("Tongbu", string(body))
	type Data struct {
		Name string
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
	}
	w.Write([]byte(system(fmt.Sprintf("/data/sh/updatagame.sh %s", msg.Name))))
	return
}

func Startgame(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {

		log.Error("Failed read body", err)
		w.Write([]byte(err.Error()))
		return

	}
	log.Debug("Startgame", string(body))
	type Data struct {
		Name string
	}

	var msg Data
	err = json.Unmarshal(body, &msg)
	if err != nil {
		log.Error("Failed decoding json", err)
	}
	w.Write([]byte(system(fmt.Sprintf("/data/sh/start_game.sh %s", msg.Name))))
	return
}

func Stopgame(w http.ResponseWriter, r *http.Request) {
    body, err := ioutil.ReadAll(r.Body)
    if err != nil {
	
       log.Error("Failed read body", err)
       w.Write([]byte(err.Error()))
       return

    }
    log.Debug("Stopgame", string(body))
    type Data struct {
        Name string
    }
			
    var msg Data
    err = json.Unmarshal(body, &msg)
    if err != nil {
        log.Error("Failed decoding json", err)
    }
    w.Write([]byte(system(fmt.Sprintf("/data/sh/stop_gameserver.sh %s", msg.Name))))
    return
}
