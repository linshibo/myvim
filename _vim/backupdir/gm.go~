package gameserver

import (
	"database/sql"
	"encoding/json"
	"fmt"
	_ "github.com/Go-SQL-Driver/MySQL"
	"github.com/garyburd/redigo/redis"
	"sanguo/base/log"
	"sanguo/db"
	"sanguo/pprof"
	. "sanguo/systemdata"
	"strconv"
	"sync"
	"time"
	//"sanguo/config"
)

const (
	GMLength = 5000
)
const (
	StatIDRegister  = 100000
	StatIDLogin     = 100001
	StatIDOnlineNum = 100002
	//宝石消耗
	StatIDDrawCard           = 100100
	StatIDBuyPower           = 100101
	StatIDUseItemBeforeFight = 100102
	StatIDBuyArmHero         = 100103
)

type GMQueue struct {
	sql        [GMLength]string
	head       int
	tail       int
	lock       sync.RWMutex
	db_handler *sql.DB
}

func (this *GMQueue) push(s string) {
	this.lock.Lock()
	defer this.lock.Unlock()

	if this.tail-this.head == GMLength {
		return
	}

	this.sql[this.tail%GMLength] = s
	this.tail++
}

func (this *GMQueue) pop() (s string) {
	this.lock.Lock()
	defer this.lock.Unlock()

	if this.head == this.tail {
		return ""
	}

	s = this.sql[this.head%GMLength]
	this.head++
	return s
}

func (this *GMQueue) GMDayLog(uid, id, value int) {
	table := fmt.Sprintf("t_gm_day_%4d%02d%02d", time.Now().Year(), time.Now().Month(), time.Now().Day())
	str := fmt.Sprintf("insert into %s (id,logtime,uid, value) values(%d,%d,%d,%d);", table, id, time.Now().Unix(), uid, value)
	log.Info(str)
	this.push(str)
}

func (this *GMQueue) GMLogin(uid int) {
	/*uid, err := strconv.Atoi(strings.Split(userid, ":")[1])
	if err != nil {
		fmt.Println("Failed Atoi", err)
	}*/

	id := StatIDLogin
	value := 0
	table := fmt.Sprintf("t_gm_day_%4d%02d%02d", time.Now().Year(), time.Now().Month(), time.Now().Day())
	str := fmt.Sprintf("insert into %s (id,logtime,uid, value) values(%d,%d,%d,%d);", table, id, time.Now().Unix(), uid, value)

	log.Info(str)

	this.push(str)
}

func (this *GMQueue) GMRegister(uid int) {
	id := StatIDRegister
	value := 0
	table := fmt.Sprintf("t_gm_day_%4d%02d%02d", time.Now().Year(), time.Now().Month(), time.Now().Day())
	str := fmt.Sprintf("insert into %s (id,logtime,uid, value) values(%d,%d,%d,%d);", table, id, time.Now().Unix(), uid, value)
	this.push(str)

	table = "t_gm_permenent"
	str = fmt.Sprintf("insert into %s (id,logtime,uid, value) values(%d,%d,%d,%d);", table, id, time.Now().Unix(), uid, value)

	log.Info(str)

	this.push(str)
}

func (this *GMQueue) GMTongguan(uid int, sid int) {
	id := sid
	value := 0
	table := "t_gm_permenent"
	str := fmt.Sprintf("insert into %s (id,logtime,uid, value) values(%d,%d,%d,%d);", table, id, time.Now().Unix(), uid, value)

	log.Info(str)

	this.push(str)
}

func (this *GMQueue) GMPurchase(uid int, t int, chapter int) {
	table := "t_charge"
	str := fmt.Sprintf("insert into %s (logtime,uid, value, level) values(%d,%d,%d,%d);", table, time.Now().Unix(), uid, t, chapter)

	log.Info(str)

	this.push(str)
}

func (this *GMQueue) Start() {
	/*
		    //this.db_handler, err = sql.Open("mysql", "root:feixiongtech_mysql@tcp(42.62.67.240:3306)/zone?charset=utf8")

		        var err error
		        this.db_handler, err = sql.Open("mysql", fmt.Sprintf("%s:%s@tcp(%s)/%s?charset=utf8", config.Config.DBUser, config.Config.DBPasswd, config.Config.DBHost, config.Config.Database))
				if err != nil {
			        fmt.Printf("conn error.",err)
			        return
			    }

			    fmt.Println("Conn success")

				for {
					str := this.pop()
					if str == "" {
						time.Sleep(10 * time.Second)
						continue
					}

					_,err = this.db_handler.Exec(str)
					if err != nil {
						fmt.Printf("exec error.",err)
					}
				}
	*/
}

const (
	Success               = 0
	PlayerNotOnline       = 1
	ErrorNameNotExist     = 5
	ErrorOperationTrouble = 6
)

/*************************GM of kefu **********************************/
//opcode 0xf001
func GMPlayerOnline(reader []byte) bool {
	type Data struct {
		UID int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		log.Error("Can't decode json message, err = %v", err)
		return false
	}

	type DataBack struct {
		Ret int
	}
	var back DataBack

	s := PlayerManager.QueryOnline(msg.UID)
	if s == nil {
		back.Ret = PlayerNotOnline
	} else {
		back.Ret = Success
	}

	return SendToHub(back, 0xf001)
}

const (
	SYSTEM = 1
)

//opcode 0xf002
func GMUserAdd(reader []byte) bool {
	type Data struct {
		UID   int
		Value int
		Type  int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		log.Error("Can't decode json message, err = %v", err)
		return false
	}

	if msg.UID == 0 {
		log.Error("The uid should not be 0")
		return true
	}

	type DataBack struct {
		Ret int
	}
	var back DataBack

	type ipc struct {
		Value int
		Type  int
	}

	var ipcmsg ipc
	ipcmsg.Value = msg.Value
	ipcmsg.Type = msg.Type

	if !IPCSendByUid(SYSTEM, msg.UID, 0, 55, ipcmsg) {
		back.Ret = ErrorOperationTrouble
		return SendToHub(back, 0xf002)
	}

	back.Ret = Success

	return SendToHub(back, 0xf002)
}

//opcode 0xf008
func GMDoPProf(reader []byte) bool {
	type Data struct {
		Type  string
	}
	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		log.Error("Can't decode json message, err = %v", err)
		return false
	}
	pprof.LookUp(msg.Type)
	return true
}

//opcode 0xf007
func GMUserAllReward(reader []byte) bool {
	type Data struct {
		Value int
		Type  int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		log.Error("Can't decode json message, err = %v", err)
		return false
	}

	type DataBack struct {
		Ret int
	}
	var back DataBack

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	max, err := redis.Int(dbconn.Do("GET", "uid"))
	if err != nil {
		log.Error("Failed get uid", err)
		return false
	}

	type ipc struct {
		Value int
		Type  int
	}

	var ipcmsg ipc
	ipcmsg.Value = msg.Value
	ipcmsg.Type = msg.Type

	for uid := 1; uid <= max; uid++ {
		IPCSendByUid(SYSTEM, uid, 0, 55, ipcmsg)
	}

	back.Ret = Success

	return SendToHub(back, 0xf007)
}

//opcode 0xf003
func GMUserGuanqia(reader []byte) bool {
	type Data struct {
		UID     int
		Chapter int
		C_guan  int
		S_guan  int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		log.Error("Can't decode json message, err = %v", err)
		return false
	}

	type DataBack struct {
		Ret int
	}
	var back DataBack

	user := PlayerManager.GetUserByUid(msg.UID)
	//user.C
	err = user.ChangeGuanqia(msg.Chapter, msg.C_guan, msg.S_guan)
	if err != nil {
		back.Ret = ErrorOperationTrouble
		return SendToHub(back, 0xf003)
	}

	back.Ret = Success

	return SendToHub(back, 0xf003)
}

//opcode 0xf004
func GMUserAddCard(reader []byte) bool {
	log.Trace("AddCard", string(reader))
	type Data struct {
		UID   int
		Level int
		Id    int
		Type  int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		log.Error("Can't decode json message, err = %v", err)
		return false
	}

	type DataBack struct {
		Ret int
	}
	var back DataBack

	//uid, _ := strconv.Atoi(strings.Split(msg.UID, ":")[1])
	user := PlayerManager.GetUserByUid(msg.UID)

	if msg.Type == RewardType_Arm {
		err = user.Arm.AddNewArm(msg.Id, msg.Level)
	} else if msg.Type == RewardType_Hero {
		err = user.Hero.AddNewHero(msg.Id, msg.Level, false)
	} else {
		return false
	}

	if err != nil {
		log.Error(err)
		back.Ret = ErrorOperationTrouble
		return SendToHub(back, 0xf004)
	}

	back.Ret = Success

	return SendToHub(back, 0xf004)
}

//opcode 0xf005
func GMUserInfo(reader []byte) bool {
	type Data struct {
		UID int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		log.Error("Can't decode json message, err = %v", err)
		return false
	}

	type DataBack struct {
		Ret          int
		Gold         int
		Power        int
		Stone        int
		ArmCurr      int
		HeroCurr     int
		Chapter      int
		C_guanqia    int
		S_guanqia    int
		LastLogin    int
		RegisterTime int
	}
	var back DataBack

	user := PlayerManager.GetUserByUid(msg.UID)
	if user == nil {
		log.Error("Failed GetUserByUid", msg.UID)
		return false
	}
	back.ArmCurr = user.arm_currency
	back.C_guanqia = user.c_guanqia
	back.Chapter = user.chapter
	back.Gold = user.gold
	back.HeroCurr = user.hero_currency
	back.Power, _ = user.GetPower()
	back.S_guanqia = user.s_guanqia
	back.Stone = user.stone
	back.Ret = Success
	back.LastLogin = int(user.last_login)
	back.RegisterTime = int(user.register_time)

	return SendToHub(back, 0xf005)
}

func GMIPCAdd(sess *Session, p *IPCMsg) bool {
	sess.Debug("IPCRecvArm")

	type ipc struct {
		Value int
		Type  int
	}

	var msg ipc
	err := json.Unmarshal(p.Content, &msg)
	if err != nil {
		sess.Error("Failed decode", err)
		return false
	}

	return UserAddUnreward(sess, msg.Value, msg.Type, 1)
}

//opcode55
func UserAddUnreward(sess *Session, v, t, r int) bool {

	rid, err := sess.user.AddUnreward(v, t, r)
	if err != nil {
		sess.user.Error("Failed AddUnreward", err)
		return false
	}

	sess.user.Trace("In UserAddUnreward", rid)

	type DataBack struct {
		UR []UnrewardBack_
	}

	tmp := make([]UnrewardBack_, 1)
	tmp[0].M = 1
	tmp[0].Rid = rid
	tmp[0].Value = v
	tmp[0].Type = t

	var back DataBack
	back.UR = tmp

	return sess.SendReplyBack(back, 55)
}

func (this *User) AddUnreward(value, t, r int) (rid int, err error) {
	rid, err = this.AssignUnrewardID()
	if err != nil {
		this.Error("Failed AssignUnrewardID", err)
		return
	}

	var tmp Unreward
	tmp.Value = value
	tmp.Type = t
	tmp.Reason = r

	this.unreward[rid] = tmp

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	_, err = dbconn.Do("SADD", this.GetUidUsedInDB()+":_unrewards", rid)
	if err != nil {
		this.Error("Failed Sadd unreward", err)
		return
	}

	_, err = dbconn.Do("HMSET", this.GetUidUsedInDB()+":_unreward:"+strconv.Itoa(rid), "value", value, "type", t, "reason", r)
	if err != nil {
		this.Error("Failed hmset unreward", err)
		return
	}

	return
}

type UnrewardBack_ struct {
	Value int
	Type  int
	Rid   int
	M     int
}

func (this *User) GetAllUnreward() []UnrewardBack_ {
	if len(this.unreward) == 0 {
		return nil
	}

	u := make([]UnrewardBack_, len(this.unreward))

	index := 0
	for id, v := range this.unreward {
		u[index].Rid = id
		u[index].Type = v.Type
		u[index].Value = v.Value
		u[index].M = v.Reason
		index++
	}
	return u
}

func (this *User) GetUnreward(rid int) (err error) {
	v, ok := this.unreward[rid]
	if !ok {
		return nil
	}

	this.Debug("unreward is", v)

	_,_, err = this.ProcessReward(v.Type, v.Value)
	if err != nil {
		this.Error("Failed ProcessReward", err)
		return err
	}

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	_, err = dbconn.Do("SREM", this.GetUidUsedInDB()+":_unrewards", rid)
	if err != nil {
		this.Error("Failed SREM unrewads", err)
		return err
	}

	_, err = dbconn.Do("DEL", this.GetUidUsedInDB()+":_unreward:"+strconv.Itoa(rid))
	if err != nil {
		this.Error("Failed del unreward", err)
		return
	}

	delete(this.unreward, rid)

	return nil
}

func (this *User) LoadUnreward() (err error) {
	dbconn := db.Pool.Get()
	defer dbconn.Close()

	reply, err := redis.Values(dbconn.Do("SMEMBERS", this.GetUidUsedInDB()+":_unrewards"))
	if err != nil {
		this.Error("Can't get user:arms from redis")
		return err
	}

	num := len(reply)
	var tmp Unreward
	for i := 0; i < num; i++ {
		id, err := redis.Int(reply[i], nil)
		if err != nil {
			this.Error("Can't convert unreward to int")
			return err
		}

		r, err := redis.Values(dbconn.Do("HMGET", this.GetUidUsedInDB()+":_unreward:"+strconv.Itoa(id), "value", "type", "reason"))
		if err != nil {
			return err
		}

		tmp.Value, err = redis.Int(r[0], nil)
		if err != nil {
			return err
		}

		tmp.Type, err = redis.Int(r[1], nil)
		if err != nil {
			return err
		}

		tmp.Reason, err = redis.Int(r[2], nil)
		if err != nil {
			return err
		}

		this.unreward[id] = tmp
	}
	return nil
}

//opcode55
func UserSendSystemUnreward(sess *Session, reader []byte) bool {
	type DataBack struct {
		UR []UnrewardBack_
	}

	var back DataBack
	back.UR = sess.user.GetAllUnreward()

	return sess.SendReplyBack(back, 55)
}

//opcode56
func UserGetSystemUnreward(sess *Session, reader []byte) bool {
	type Data struct {
		Rid int
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.user.Error("Can't decode json message, err = %v", err, sess.user.uid)
		return false
	}

	err = sess.user.GetUnreward(msg.Rid)
	if err != nil {
		sess.user.Error("Failed GetUnreward", err)
		return false
	}

	type DataBack struct {
		Stone    int
		Gold     int
		ArmCurr  int
		HeroCurr int
		//Power int
	}

	var back DataBack
	back.Gold = sess.user.gold
	back.Stone = sess.user.stone
	back.ArmCurr = sess.user.arm_currency
	back.HeroCurr = sess.user.hero_currency

	return sess.SendReplyBack(back, 56)
}
