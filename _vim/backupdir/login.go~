package gameserver

import (
	"encoding/json"
	"sanguo/base/log"
	//"sanguo/base/packet"
	"github.com/garyburd/redigo/redis"
	"sanguo/config"
	"sanguo/db"
	. "sanguo/systemdata"
	"time"
	"io/ioutil"
	"net/http"
	"crypto/md5"
	"io"
	"fmt"
)

func (this *User)bindAccountToUid(account string) (err error) {
    dbconn := db.ZonePool.Get()
    defer dbconn.Close()                                                                                                                                                     

    _, err = dbconn.Do("HSET", "gateway:account2uid", account, this.uid)
    if err != nil {
        log.Error("Failed HGET sid", err)
        return err
    }

    return nil
}

func CanRegister(id string) (flag bool, err error) {
	//return true, nil

	dbconn := db.ZonePool.Get()
	defer dbconn.Close()

	sid, err := redis.Int(dbconn.Do("HGET", "gateway:gid2sid", id))
	if err != nil {
		log.Error("Failed HGET sid", err)
		return false, err
	}

	if sid != config.Config.GSID {
		log.Warn("The id is not assign in this server", sid)
		return false, nil
	}

	return true, nil
}

func UserLogin_(sess *Session, reader []byte) bool {
	type Data struct {
		Id string
		Token string
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message, err = %v", err)
		return false
	}
	log.Debug("Login: user id is ", msg.Id)
	
	applyID := "413"
	tmp := "appid=413&sessionid="+msg.Token
	
	h := md5.New()

	io.WriteString(h, tmp)
	//tmp_md5 := h.Sum(nil)
	url := fmt.Sprintf("https://pay.slooti.com/?r=auth/verify&appid=413&sessionid=%s&sign=%x", msg.Token, h.Sum(nil))
	
	//log.Debug("tmp_md5",len(tmp_md5), string(tmp_md5))
	
	//url := "https://pay.slooti.com/?r=auth/verify&" + tmp + "&sign=" + string(tmp_md5)
	
	log.Trace("HHHHofurlis",url)
	
	response, err := http.Get(url)
	if err != nil {
		log.Error("Failed send http require to appstore", err)
		return false
	}

	defer response.Body.Close()
	
	apple_body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		log.Error("Failed read all info", err)
		return false
	}
	log.Critical("Response recv in Appstore is", string(apple_body))

	type TokenVerifyData struct {

		Status        string

	}	

	var res TokenVerifyData
	err = json.Unmarshal(apple_body, &res)
	if err != nil {
		sess.Error("Can't decode json message,", err)
		return false
	}
	sess.Debug("hzz", res)
	
	//if res.
	
	uid := PlayerManager.GetUidById(msg.Id)
	if uid == 0 {
		log.Debug("The uid is not exist (uid = 0), will register", msg.Id)

		register_flag, err := CanRegister(msg.Id)
		if err != nil {
			log.Error("Failed CanRegister", err)
			return false
		}

		if !register_flag {
			back := map[string]interface{}{
				"ret": false,
			}
			return sess.SendReplyBack(back, 1)
		}

		uid, err = PlayerManager.AddPlayer(msg.Id)
		if err != nil {
			log.Error("Failed AddPlayer", err)
			return false
		}
		GM.GMRegister(uid)
	}

	log.Debug("The uid is", uid)
	sess.user = PlayerManager.GetUserByUid(uid)
	if sess.user == nil {
		log.Error("Failed load user")
		return false
	}
	sess.user.sess = sess

	//GM.GMLogin(sess.user.uid)

	/*************************** Power recover time ************************************************/
	power_left_time, err := sess.user.GetLeftTimeToAddPower()
	if err != nil {
		log.Error("Cant get left time to add power", err, sess.user.uid)
		return false
	}
	log.Trace("The left time to add power is ", power_left_time, sess.user.uid)

	/************************** BossInfo Update *************************************/
	if IsFirstLoginOfToday(sess.user.last_login) {
		sess.user.Trace("The user is FirstLogin")
		// First login in the day
		err = sess.UpdateLoginArmInTheFirstLoginOfDay()
		if err != nil {
			log.Error("Failed UpdateLoginArmInTheFirstLoginOfDay", err, sess.user.uid)
			return false
		}

		err = sess.UpdateBossInfoInTheFirstLoginOfDay()
		if err != nil {
			log.Error("Failed UpdateBossInfoInTheFirstLoginOfDay", err, sess.user.uid)
			return false
		}
		err = sess.user.Activity.InitActivityInTheFirstLogin()
		if err != nil {
			sess.Error("Failed InitActivityInTheFirstLogin", err, sess.user.uid)
			return false
		}

		if err = sess.user.quest.LoadRandomFightQuestInTheFirstLoginOfDay(); err != nil {
			sess.Error("Failed LoadRandomFightQuestInTheFirstLoginOfDay", err)
			return false
		}

		err = UpdateGetStoneFlagEveryday(sess)
		if err != nil {
			sess.Error("Failed UpdateGetStoneFlagEveryday", err)
			return false
		}

		err = sess.InitStrangerTimeEveryDay()
		if err != nil {
			sess.Error("Failed InitStrangerTimeEveryDay", err)
			return false
		}

		err = sess.user.Friends.InitFriendFirstLogin()
		if err != nil {
			sess.Error("Failed InitFriendFirstLogin", err)
			return false
		}

		err = sess.user.purchase.FirstLoginOfDay()
		if err != nil {
			sess.Error("Failed purchase FirstLoginOfDay", err)
			return false
		}

		err = sess.user.quest.RefreshQuestInTheFirstLogin()
		if err != nil {
			sess.Error("Failed RefreshQuestInTheFirstLogin", err)
			return false
		}

		err = sess.user.InitBoxRewadInTheFirstLogin()
		if err != nil {
			sess.Error("Failed InitBoxRewadInTheFirstLogin", err)
			return false
		}

		err = sess.user.setPKCount(0)
		if err != nil {
			sess.Error("Failed setPKCount", err)
			return false
		}
	}

	bosses := sess.GetAllBossInfo()

	heros := sess.user.Hero.GetAllHeros()

	arms := sess.user.Arm.GetAllArms()

	e := sess.user.E_Arm.ListAllExtraArm()

	now := time.Now().Unix()
	sess.user.loginTime = now
	back := map[string]interface{}{
		"ret":              true,
		"uid":              sess.user.uid,
		"level":            sess.user.level,
		"name":             sess.user.name,
		"gold":             sess.user.gold,
		"power":            sess.user.power,
		"chapter":          sess.user.chapter,
		"c_guanqia":        sess.user.c_guanqia,
		"s_guanqia":        sess.user.s_guanqia,
		"heros":            heros,
		"arms":             arms,
		"formation":        sess.user.Arm.formation,
		"stone":            sess.user.stone,
		"accepted_quests":  sess.user.quest.GetOwnAcceptedQuest(),
		"power_left_time":  power_left_time,
		"f_quests":         sess.user.quest.GetOwnFinishedQuest(),
		"unreward_qid":     sess.user.quest.GetUnrewardQuests(),
		"new_arm":          sess.user.Arm.GetNewArm(),
		"new_hero":         sess.user.Hero.GetNewHero(),
		"bossInfo":         bosses,
		"ConvenedBossID":   sess.user.convenedBossID,
		"friends_max_num":  15,
		"vip":              sess.user.vip,
		"Photo":            sess.user.photo,
		"card_count":       sess.user.card_count,
		"login_arm":        sess.user.login_arm,
		"fight_quest":      sess.user.quest.GetAllOwnFightQuest(),
		"wizards":          sess.user.wizards,
		"register_time":    sess.user.register_time,
		"stone_flag":       sess.user.stone_get_flag,
		"final_chapter":    config.Config.FinalChapter,
		"extra_arm":        e,
		"EventId":          sess.user.event_id,
		"EventCount":       sess.user.GetEventLeftCount(),
		"EventTime":        sess.user.GetEventLeftTime(),
		"LockChapter":      sess.user.lock_chapter,
		"LockBegin":        sess.user.lock_start_time,
		"GS":               sess.user.GetGuanqiaScore(),
		"CBS":              sess.user.GetChapterBossScore(),
		"T":                now,
		"FriendRd":         sess.user.Friends.GetUnRecvRewardCount(),
		"MaxPower":         sess.user.max_power,
		"HeroVIP":          sess.user.heroVIP,
		"Purchases":        sess.user.purchase.GetAllPurchaseState(),
		"PArm":             PresentArm,
		"AEndTime":         ArmEnd - now,
		"OArms":            HistoryArms,
		"PHero":            PresentHero,
		"HEndTime":         HeroEnd - now,
		"OHeros":           HistoryHeros,
		"SignFlag":         sess.user.GetSignUpFlag(),
		"SignCount":        sess.user.GetSignUpCount(),
		"BoxLeftTime":      sess.user.GetBoxLeftCDTime(),
		"ArmCurr":          sess.user.arm_currency,
		"HeroCurr":         sess.user.hero_currency,
		"ChapterQuests":    sess.user.quest.GetAllGuanqiaQuest(),
		"ArmEquip":         sess.user.GetArmEquip(),
		"ArmEquipQuests":   sess.user.quest.GetFinishedArmEquip(),
		"HeroEvolveQuests": sess.user.quest.GetFinishedHeroEvolve(),
		"MHeroID":          sess.user.Hero.GetMainHero(),
		"HeroChip":         sess.user.Hero.GetAllHeroChip(),
		"Line":             sess.user.time_line.GetAllNode(),
		"ExtraBaoxiang": sess.user.GetExtraBaoxiang(),
		"RecruitArm":sess.user.getRecruitArm(),
	}

	if !sess.SendReplyBack(back, 1) {
		log.Error("Send opcode1 error")
		return false
	}

	if !UserGetFriendList(sess, nil) {
		return false
	}

	GM.GMLogin(sess.user.uid)

	err = sess.user.InitCombatScoreWhenServerStart()
	if err != nil {
		sess.user.Error("Failed InitCombatScoreWhenServerStart", err)
		return false
	}

	////////////////////////////// Quest type 9 ////////////////////////////////////////////////////////////////////
	if IsFirstLoginOfToday(sess.user.last_login) {
		sess.user.Trace("XJ_This is the first login of today")
		err = sess.user.quest.InspectQuest(QuestType_LoginDays, 0, 0)
		if err != nil {
			sess.Error("QuestType_LoginDays ", err)
			return false
		}
	}

	if !UserLoginActivity(sess, nil) {
		return false
	}

	if !UserGetTime(sess, nil) {
		return false
	}

	if !UserLoginReward(sess) {
		return false
	}

	if !UserLoginArm(sess) {
		return false
	}

	if !UserSendUnreward(sess, nil) {
		sess.Error("Failed UserSendUnreward")
		return false
	}

	UserSendSystemUnreward(sess, nil)

	err = HandlerOfflineMsg(sess)
	if err != nil {
		log.Error("Failed handle offline msg", err, sess.user.uid)
		return false
	}

	err = sess.user.UpdateLastLoginTime()
	if err != nil {
		log.Error("Failed update last_login_time", err)
		return false
	}

	PlayerManager.RegisterOnline(sess, sess.user.GetUidOfInt())

	return true
}

/*
func UserMerge(sess *Session, reader []byte) bool {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	type Data struct {
		Id  string
		Gid string
	}

	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		log.Error("Can't decode json message, err = %v", err, sess.user.uid)
		return false
	}

	var ret = true
	if msg.Id != sess.user.mid {
		sess.Error("Cant bind gid to a none exit id", msg.Id, msg.Gid)
		ret = false
	} else {
		sess.user.gid = msg.Gid

		_, err = dbconn.Do("SET", msg.Gid, sess.user.uid)
		if err != nil {
			sess.Error("Failed replace id with gid", sess.user.uid)
			return false
		}

		_, err = dbconn.Do("HSET", sess.user.uid, "gid", msg.Gid)
		if err != nil {
			sess.Error("Failed HSET uid 'gid' gid ", err)
			return false
		}
	}

	back := map[string]interface{}{"ret": ret}
	back_json, err := json.Marshal(back)
	if err != nil {
		sess.Error("Can't decode json message, err = %v", err, sess.user.uid)
		return false
	}
	sess.Debug("The back json message is", string(back_json), sess.user.uid)

	return sess.SendReply(back_json, 3)
}

func UserIsGidExist(sess *Session, reader []byte) bool {
	dbconn := db.Pool.Get()
	defer dbconn.Close()
	type GidExist struct {
		Gid string
	}

	var msg GidExist

	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message, err = %v", err, sess.user.uid)
		return false
	}
	sess.Debug("A msg from client", msg, sess.user.uid)

	exist_flag, err := redis.Int(dbconn.Do("EXISTS", msg.Gid))
	if err != nil {
		sess.Error("Something wrong with database to judge gid exist:", sess.user.uid)
		return false
	}

	var back map[string]interface{}

	if exist_flag == 0 {
		back = map[string]interface{}{"ret": false}
	} else {
		ireply, err := dbconn.Do("GET", msg.Gid)
		if err != nil {
			sess.Error("Can't get name of user:", msg.Gid, "and err is", err, sess.user.uid)
			return false
		}
		uid, err := redis.String(ireply, nil)
		if err != nil {
			sess.Error("cant convert ireply to string and ireply is", ireply, sess.user.uid)
			return false
		}

		name, err := redis.String(dbconn.Do("HGET", uid, "name"))
		if err != nil {
			sess.Error("Failed get name of uid", uid, name, sess.user.uid)
			return false
		}
		back = map[string]interface{}{"ret": true, "name": name}
	}

	back_json, err := json.Marshal(back)
	if err != nil {
		sess.Error("Can't decode json message in UserStartFight, err = %v", err, sess.user.uid)
		return false
	}
	sess.Debug("The back json message is", string(back_json), sess.user.uid)

	return sess.SendReply(back_json, 8)
}*/
