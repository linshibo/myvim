package gameserver

import (
	"encoding/json"
	"sanguo/db"
	. "sanguo/systemdata"
)

//opcode50
func UserOpenBossFight(sess *Session, reader []byte) bool {
	back := make(map[string]interface{})
	back["bid"] = 8

	err := sess.SetBossIdOfUser(8)
	if err != nil {
		sess.Error("Failed set init id of boss guanqia", err, sess.user.uid)
		return false
	}

	/*back_json, err := json.Marshal(back)
	  if err != nil {
	  	sess.Error("Can't decode json message in UserStartFight", err, sess.user.uid)
	  	return false
	  }
	  sess.Debug("The back json message is", string(back_json), sess.user.uid)*/

	return sess.SendReplyBack(back, 50)
}

func IsEnoughPowerToBossFight(sess *Session) bool {
	if sess.user.power < Power_Boss {
		return false
	}
	return true
}

//opcode51
func UserStartBossFight(sess *Session, reader []byte) bool {
	back := make(map[string]interface{})
	//if !IsEnoughPowerToBossFight(sess) {
	//	back["ret"] = false
	//	return sess.SendReplyBack(back, 51)
	//}
	type Data struct {
		BossId int
	}
	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}

	left_time := sess.GetLeftTimeToBossFight(msg.BossId)
	if left_time <= 0 {
		back["ret"] = true
	} else {
		back["ret"] = false
		back["left_time"] = left_time
	}
	boss, ok := sess.user.bossInfos[msg.BossId]
	if !ok {
		sess.Error("not find bossid", msg.BossId)
		return false
	}

	back["count"] = boss.boss_count
	back["today_max_score"] = boss.boss_today_max_score

	/*back_json, err := json.Marshal(back)
	  if err != nil {
	  	sess.Error("Can't decode json message in UserStartFight", err, sess.user.uid)
	  	return false
	  }
	  sess.Debug("The back json message is", string(back_json), sess.user.uid)*/

	return sess.SendReplyBack(back, 51)
}

//opcode52
func UserWinBossFight(sess *Session, reader []byte) bool {
	sess.Debug("The data recv is ", string(reader), sess.user.uid)

	type DataBossFight struct {
		BossId int
		Ret    bool
		Fight  FightDataVerify
	}

	var msg DataBossFight
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}
	sess.Debug("A data from client", msg, sess.user.uid)

	boss, ok := sess.user.bossInfos[msg.BossId]
	if !ok {
		sess.Error("not find boss id", msg.BossId)
		return false
	}

	gid := BossGuanQiaInfo[msg.BossId].ContentGuanQiaId

	var ret = true
	if msg.Ret {
		//ret = VerifyFightData(sess, gid, &msg.Fight, 0)
		ret = sess.user.VerifyFightData(gid, &msg.Fight, 0)
	}
	/************************** Verify finish, Reward And Quest Begin ************************************/

	back := make(map[string]interface{})
	if !ret {
		back["ret"] = false
	} else {
		back["ret"] = true

		err = DelLoginArm(sess)
		if err != nil {
			sess.Error("Failed DelLoginArm", err, sess.user.uid)
			return false
		}
		back["login_arm"] = msg.Fight.Login_arm
		reward, err := sess.GetBossReward(boss, msg.Fight.Score)
		if err != nil {
			sess.Error("Failed get score reward", err)
			return false
		}
		if reward != nil {
			back["reward"] = reward
		}

		err = sess.UpdateBossInfoAfterFight(msg.BossId, msg.Fight.Score)
		if err != nil {
			sess.Error("Failed update boss info", err, sess.user.uid)
			return false
		}

		if msg.Ret && boss.boss_pass == 0 {
			err = sess.AddBossTGCount(msg.BossId)
			if err != nil {
				sess.Error("Failed add boss tongguan count", err, sess.user.uid)
				return false
			}

			max_score_flag := true

			for _, v := range GuanqiaInfo[BossGuanQiaInfo[msg.BossId].ContentGuanQiaId].ScoreReward {
				if msg.Fight.Score < v.Score {
					max_score_flag = false
					break
				}
			}

			sess.Critical("The max_score_flag is:", max_score_flag)
			if max_score_flag || boss.boss_tg_count == BossGuanQiaInfo[msg.BossId].NeedFinishTimes {
				//解锁
				back["bid"], err = sess.UnlockNextBoss(msg.BossId)
				if err != nil {
					sess.Error("Failed unlock next boss", err, sess.user.uid)
					return false
				}
				//back["bid"] = boss.boss_id
			} else {
				back["bid"] = boss.boss_id
			}
		}
		back["rank"] = boss.boss_rank

		topten, err := GetTopTenOfBossFight(sess, msg.BossId)
		if err != nil {
			sess.Error("Failed get top ten player in boss guan", err, sess.user.uid)
			return false
		}
		back["top10"] = topten
		back["tg_count"] = boss.boss_tg_count
	}

	/************************** PowerReduce ******************************/
	//if !ReducePower(sess, Power_Boss) {
	//	return false
	//}
	left_time, err := sess.user.GetLeftTimeToAddPower()
	if err != nil {
		sess.Error("In start fight", err)
		return false
	}
	back["Power"] = sess.user.power
	back["Left"] = left_time

	////////////////////////  CoinsGot in fight //////////////////////////
	if msg.Fight.CoinsGot > 0 {
		_, err = sess.user.ProcessReward(RewardType_Gold, msg.Fight.CoinsGot)
		if err != nil {
			sess.Error("Failed AddGold", err, sess.user.uid)
			return false
		}
	}

	back["level"] = sess.user.level
	/****************************** Finsh Process and send msg ****************************************/

	back_json, err := json.Marshal(back)
	if err != nil {
		sess.Error("Can't decode json message in UserStartFight, err = %v", err, sess.user.uid)
		return false
	}

	sess.Debug("The back json message is", string(back_json))
	if !sess.SendReplyBack(back, 52) {
		sess.Error("Send opcode6 error")
		return false
	}

	err = sess.user.quest.InspectQuest(QuestType_FinishBoss, 0, 0)
	if err != nil {
		sess.Error("Failed QuestType_FinishBoss", err)
		return false
	}
	return true
}

//opcode53
func UserGetBossRank(sess *Session, reader []byte) bool {
	type Data struct {
		BossId int
	}
	type DataBack struct {
		BossId int
		Score  int
		Rank   int
		Top10  []RankPlayer
	}
	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}

	boss, ok := sess.user.bossInfos[msg.BossId]
	if !ok {
		sess.Error("not find boss id", msg.BossId)
		return false
	}

	var back DataBack

	back.BossId = msg.BossId
	back.Rank = boss.boss_rank
	back.Score = boss.boss_max_score
	back.Top10, err = GetTopTenOfBossFight(sess, boss.boss_id)
	if err != nil {
		sess.user.Error("Failed GetTopTenOfBossFight", err)
		return false
	}
	return sess.SendReplyBack(back, 53)
}

//UserSetConveneBoss [opcode 132]  设置召唤的神兽
func UserSetConveneBoss(sess *Session, reader []byte) bool {
	type Data struct {
		BossId int
	}
	var msg Data
	err := json.Unmarshal(reader, &msg)
	if err != nil {
		sess.Error("Can't decode json message,", err, sess.user.uid)
		return false
	}
	boss, ok := sess.user.bossInfos[msg.BossId]
	if !ok {
		sess.Error("not find boss id", msg.BossId)
		return false
	}
	sess.user.convenedBossID = msg.BossId
	MaxScoreFlag := true
	for _, v := range GuanqiaInfo[BossGuanQiaInfo[msg.BossId].ContentGuanQiaId].ScoreReward {
		if boss.boss_max_score < v.Score {
			MaxScoreFlag = false
			break
		}
	}
	if !MaxScoreFlag {
		sess.Error("not unlock boss", msg.BossId)
		return false
	}

	dbconn := db.Pool.Get()
	defer dbconn.Close()

	_, err = dbconn.Do("HSET", sess.user.GetUidUsedInDB(), "convenedBossID", sess.user.convenedBossID)
	if err != nil {
		sess.user.Error("Failed HSET", err)
		return false
	}

	back := make(map[string]interface{})
	back["ret"] = 0
	return sess.SendReplyBack(back, 132)
}
