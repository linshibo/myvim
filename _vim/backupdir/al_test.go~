package algorithm
import(
    "testing"
    "math/rand"
    "fmt"
    "time"
    "sort"
    "os"
    //"runtime" 
)
func isSort(data []int)bool{
    for i:=range data{
        if i>0 && data[i] < data[i-1]{
            return false
        }
    }
    return true
}

func TestKmp(t *testing.T){
    KMPMatch("abcdefghigh", "gh")
    KMPMatch("abcdefghigh", "abcdefghigh")
    KMPMatch("abaabbaaaaabbbccaabaa", "abb")
    KMPMatch("gh", "abcdefghigh")
}

func TestHeapSortPromote(t *testing.T){
    s := make([]int, 0)
    rand.Seed(time.Now().UnixNano())
    for i:=0;i<10;i++{
        s = append(s, rand.Intn(100))
    }
    h := NewHeap(s);
    fmt.Println(len(h.data), h.data)
    h.HeapSortPromote()
    fmt.Println(len(h.data), h.data)
    //t.Log("HeapSort",isSort(h))
}

func TestHeapSort(t *testing.T){
    s := make([]int, 0)
    rand.Seed(time.Now().UnixNano())
    for i:=0;i<10;i++{
        s = append(s, rand.Intn(100))
    }
    h := NewHeap(s);
    fmt.Println(len(h.data), h.data)
    h.HeapSort()
    fmt.Println(len(h.data), h.data)
    //t.Log("HeapSort",isSort(h))
}

func TestTopK2(t *testing.T){
    s := make([]int, 0)
    rand.Seed(time.Now().UnixNano())
    for i:=0;i<10;i++{
        s = append(s, rand.Intn(100))
    }
    fmt.Println(s)
    GetTopKLess2(s, 5) 
    fmt.Println(s)
}

func TestTopK(t *testing.T){
    s := make([]int, 0)
    rand.Seed(time.Now().UnixNano())
    for i:=0;i<10;i++{
        s = append(s, rand.Intn(100))
    }
    fmt.Println(s)
    GetTopKLess(s, 5) 
    fmt.Println(s)
}

func TestQuickSort(t *testing.T){
    s := make([]int, 0)
    rand.Seed(time.Now().UnixNano())
    for i:=0;i<20;i++{
        s = append(s, rand.Intn(100))
    }
    fmt.Println(s)
    QuickSort(s) 
    //t.Log("QuickSort",isSort(h))
    fmt.Println(s)
}

func TestRandShuffle(t *testing.T){
    s:=[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    var tt [10][10]int
    for i:=0;i<1000;i++{
        RandShuffle(s)
        for j:=range s{
            tt[s[j]-1][j]++
        }
    }
    //for i:=0;i<10;i++{
        //fmt.Println(tt[i])
    //}
}
func TestFakeRandShuffle(t *testing.T){
    s:=[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    var tt [10][10]int
    for i:=0;i<1000;i++{
        RandShuffle(s)
        for j:=range s{
            tt[s[j]-1][j]++
        }
    }
    //for i:=0;i<10;i++{
        //fmt.Println(tt[i])
    //}
}

func TestBinarySearch(t *testing.T){
    s := make([]int, 0)
    rand.Seed(time.Now().UnixNano())
    s = append(s, 10)
    for i:=1;i<10;i++{
        s = append(s, s[i-1]+rand.Intn(10))
    }
    fmt.Println(s)
    BinarySearch(s, s[2])
    BinarySearch(s, s[8])
    BinarySearch(s, 9)

}
func TestLCS(t *testing.T){
    rand.Seed(time.Now().UnixNano())
    base:="abcdefgh"
    x:=""
    y:=""
    for i:=0;i<10;i++{
        r:=rand.Intn(8)
        x =x + string(base[r])
    }
    for i:=0;i<10;i++{
        r:=rand.Intn(8)
        y =y + string(base[r])
    }
    fmt.Println(x, y)
    LCS(x, y)
}

func TestBitSort(t *testing.T){
    s := []int{
        1,30,394,4,100,49,48,100, 
    }
    BitSort(s)
}
func TestBuffer(t *testing.T){
    source , err:= os.Open("test.txt")
    if err != nil {
        fmt.Println(err)
        return 
    }
    b:= newBuffer(source)
    for  i:=0;i<100 ;i++{
        fmt.Println(b.Getint())
    }
}

func BenchmarkQuickSort(b *testing.B){
    s := make([]int, 0)
    rand.Seed(time.Now().UnixNano())
    for i:=0;i<1000000;i++{
        s = append(s, rand.Intn(1000000))
    }
    b.StartTimer()
    QuickSort(s) 
    b.StopTimer()
}

func BenchmarkHeapSortPromote(b *testing.B){
    s := make([]int, 0)
    rand.Seed(time.Now().UnixNano())
    for i:=0;i<1000000;i++{
        s = append(s, rand.Intn(1000000))
    }
    h := NewHeap(s);
    b.StartTimer()
    h.HeapSortPromote() 
    b.StopTimer()
    //fmt.Println("maxHeapPromote times", aa)

}
func BenchmarkHeapSort(b *testing.B){
    s := make([]int, 0)
    rand.Seed(time.Now().UnixNano())
    for i:=0;i<1000000;i++{
        s = append(s, rand.Intn(1000000))
    }
    h := NewHeap(s);
    b.StartTimer()
    h.HeapSort() 
    b.StopTimer()
    //fmt.Println("maxHeaptimes", bb)

}
func BenchmarkSort(b *testing.B){
    s := make([]int, 0)
    rand.Seed(time.Now().UnixNano())
    for i:=0;i<1000000;i++{
        s = append(s, rand.Intn(1000000))
    }
    b.StartTimer()
    sort.Ints(s)
    b.StopTimer()
}
func BenchmarkTopK(b *testing.B){
    s := make([]int, 0)
    rand.Seed(time.Now().UnixNano())
    for i:=0;i<10000;i++{
        s = append(s, rand.Intn(1000000))
    }
    b.StartTimer()
    GetTopKLess(s, 10)
    b.StopTimer()
}
func BenchmarkTopK2(b *testing.B){
    s := make([]int, 0)
    rand.Seed(time.Now().UnixNano())
    for i:=0;i<10000;i++{
        s = append(s, rand.Intn(1000000))
    }
    b.StartTimer()
    GetTopKLess2(s, 10)
    b.StopTimer()
}
